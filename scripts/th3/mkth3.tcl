#!/usr/bin/tclsh
#
# Run this script to generate the source code to a th3 test harness.
# The source code will appear on standard output.  Arguments are the
# test modules and configuration files to appear in the source code.
#
###############################################################################
#

# Line counter
set nLine 1

# The lcputs function writes its argument on standard output.  At the
# same time, it keeps track of the number of lines of code that have been
# output and updates the ::nLine variable accordingly.
#
proc lcputs {txt} {
  global nLine
  incr nLine
  regsub -all {[^\n]*} $txt {} nl
  incr nLine [string length $nl]
  puts $txt
}

# Valid property names.  This information is used to verify the property
# names that appear on configuration and module headers, and to construct
# some internal routines.
#
foreach pname {
  AUTOVACUUM
  INCRVACUUM
  UTF16BE
  UTF16LE
  FORMAT4
  JOURNAL_DELETE
  JOURNAL_OFF
  JOURNAL_MEMORY
  JOURNAL_PERSIST
  JOURNAL_TRUNCATE
  JOURNAL_WAL
  LOCKMODE_EXCLUSIVE
  NO_OOM
  NO_MEMSTATUS
  TEST_VFS
  SINGLETHREAD
  MULTITHREAD
  SERIALIZED
  ATOMICIO
  SAFEAPPEND
  SEQUENTIALIO
  UNDELETABLE_WHEN_OPEN
  CHECK_STACK
  TEST_MUTEX
  NO_MUTEX_TRY
  TEMPSTORE_FILE
  TEMPSTORE_MEM
  MEMDB
  ALT_PCACHE
  ALT_PCACHE_STRESS
  SHARED_CACHE
  BIND_STATIC
  BIND_TRANSIENT
  BIND_FREE
  BIND_ZEROTERMINATE
  CLEARTEXT
  THREADS
  EXCLUSIVE_ONLY
  RECURSIVE_TRIGGERS
  FOREIGN_KEYS
  NO_OPT
  SECURE_DELETE
  LOG
  NO_TRUNCATE
  NO_AUTOINDEX
  ZEROSIZE_FILES_EXIST
  CHECK_MEMSIZE
  ZIPVFS
  INITIALIZE_OK
  SYSCALL
  URI
  8_3_NAMES
} {
  set valid_prop($pname) 1
}

# Output a header for the generated C code.
lcputs {/* DO NOT EDIT. This is automatically generated code.  DO NOT EDIT */}
lcputs "/* This file contains coded generated by the $argv0 TCL script
** The code in this file was generated using the following command:
**
**     [info nameofexec] $argv0 [string map {/* /?*} $argv]
**
*/"
foreach arg $argv {
  if {[regexp {^-D(.*)} $arg all macro]} {
    set macro [split $macro =]
    lcputs "#ifndef [lindex $macro 0]"
    lcputs "# define [lindex $macro 0] [lindex $macro 1]"
    lcputs "#endif"
  }
}
lcputs {#if !defined(SQLITE_DEBUG) && !defined(NDEBUG)
# define NDEBUG 1
#endif

#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "sqlite3.h"
}

# Output C code to implement most of the services needed by the test harness.
# This C code header constitutes the bulk of this script and a good fraction
# of the resulting test harness.  Search for "END OF C-CODE PREFIX" to find
# the end of this block of C code.
#
lcputs {#line 119 "mkth3.tcl"
/*
** Macro for determining the size of arrays
*/
#define COUNT(X)  (sizeof(X)/sizeof(X[0]))

/*
** If compiling with SQLITE_OMIT_FLOATING_POINT, make arrangements to
** represent floating point values as 64-bit integers.
*/
#ifdef SQLITE_OMIT_FLOATING_POINT
#define double sqlite3_int64
#endif

/*
** Command-line arguments set as global variables so that test modules
** can get access to them.  (script.c uses this, for example)
*/
static int th3Argc;
static char **th3Argv;


/*
** Forward references 
*/
typedef struct TestConfiguration TestConfiguration;
typedef struct TestModule TestModule;
typedef struct th3vfsSector th3vfsSector;
typedef struct th3vfsFile th3vfsFile;
typedef struct th3vfsFd th3vfsFd;
typedef struct th3vfsFSys th3vfsFSys;
typedef struct th3state th3state;
typedef struct th3db th3db;
typedef struct th3mem th3mem;
typedef struct th3prng th3prng;
typedef struct th3var th3var;

/*
** Useful datatypes
*/
typedef unsigned char u8;
typedef unsigned short u16;
typedef unsigned int u32;
typedef sqlite3_uint64 u64;

/*
** An instance of the following object defines the SQLite configuration
** to be used for a test.
*/
struct TestConfiguration {
  const char *zConfigName;       /* Text configuration name */
  u64 maskProp;                  /* Mask of properties */
  unsigned int szPage;           /* PRAGMA page_size=%d */
  unsigned int szCache;          /* PRAGMA cache_size=%d */
  unsigned int szLookaside;      /* Size of each lookaside allocation */
  unsigned int nLookaside;       /* Number of lookaside allocations */
  unsigned int szPagecache;      /* Size of each pagecache allocation */
  unsigned int nPagecache;       /* Number of pagecache allocations */
  unsigned int szScratch;        /* Size of each scratch allocation */
  unsigned int nScratch;         /* Number of scratch allocations */
  unsigned int szHeap;           /* Size of heap.  0 for unlimited */
  unsigned int mnHeapAlloc;      /* Minimum heap allocation size */
  unsigned int szSector;         /* Size of each VFS simulated disk sector */
  unsigned int szDisk;           /* Disk space available (in sectors) */
  unsigned int szTemp;           /* Temp disk space available (in sectors) */
  unsigned int discardChance;    /* Chance of discard in ALT_PCACHE */
  unsigned int stressChance;     /* Chance of allocation fault in ALT_PCACHE */
  unsigned int pendingByte;      /* Location of PENDING_BYTE in db files */
  int softHeapLimit;             /* Value of the soft heap limit */
  int nStmtCache;                /* Default statement cache size */
  int prngSeed;                  /* Seed for the random number generator */
  void (*xInitializer)(void);    /* Initializer Proc */
  void (*xFinalizer)(void);      /* Finalizer Proc */
  const char *zDfltVfs;          /* Name of the default VFS to set */
  const char *zCodecKey;         /* Key for the codec */
};


/*
** Each test module is represented by an instance of the following
** object.
*/
struct TestModule {
  const char *zModuleName;       /* Name of the test module */
  int (*xProc)(th3state*);       /* The test module entry point */
  u64 maskReq;                   /* These properties required */
  u64 maskOmit;                  /* These properties prohibited */
  unsigned int minHeap;          /* Requires no more than this much heap */
  unsigned int minDisk;          /* Requires no more than this much disk */
  unsigned int minTemp;          /* Needs no more than this much temp disk */
  unsigned int maxFormat;        /* Longest format string */
  int nStmtCache;                /* Stmt cache size.  Overrides configuration */
  const char *zIncompatible;     /* Glob patterns for incompatible configs */
  const char *zCompatible;       /* Glob patterns for compatible configs */
};

/*
** Macro to shift a 32-bit integer literal into the upper 32 bits of
** a 64-bit integer.
*/
#define top32(X)   (((sqlite3_uint64)(X))<<32)

/* run PRAGMA auto_vacuum=FULL or =INCREMENTAL on every new connection */
#define TH3_AUTOVACUUM               0x00000001
#define TH3_INCRVACUUM               0x00000002

/* run PRAGMA encoding=X on every new connection */
#define TH3_UTF16BE                  0x00000004
#define TH3_UTF16LE                  0x00000008

/* run PRAGMA legacy_file_format=OFF on every new connection */
#define TH3_FORMAT4                  0x00000010

/* run PRAGMA journal_mode=X on every new connection */
#define TH3_JOURNAL_DELETE           0x00000020  /* The default */
#define TH3_JOURNAL_OFF              0x00000040
#define TH3_JOURNAL_MEMORY           0x00000080
#define TH3_JOURNAL_PERSIST          0x00000100
#define TH3_JOURNAL_TRUNCATE         0x00000200
#define TH3_JOURNAL_WAL              0x00000400

/* Do not use sqlite3_config(SQLITE_CONFIG_MALLOC,...) to insert the
** OOM memory allocator layer. */
#define TH3_NO_OOM                   0x00000800

/* Run sqlite3_config(SQLITE_CONFIG_MEMSTATUS,0) at setup */
#define TH3_NO_MEMSTATUS             0x00001000

/* Configure the default VFS to the be the test VFS at setup */
#define TH3_TEST_VFS                 0x00002000

/* Run sqlite3_config(SQLITE_CONFIG_x) at setup */
#define TH3_SINGLETHREAD             0x00004000
#define TH3_MULTITHREAD              0x00008000
#define TH3_SERIALIZED               0x00010000

/* Setup the test VFS to support various characteristics */
#define TH3_ATOMICIO                 0x00020000
#define TH3_SAFEAPPEND               0x00040000
#define TH3_SEQUENTIALIO             0x00080000
#define TH3_UNDELETABLE_WHEN_OPEN    0x00100000

/* Use sqlite3_config(SQLITE_CONFIG_MUTEX,...) to insert the test mutex
** implementation.  With NO_MUTEX_TRY, make sure every call to 
** sqlite3_mutex_try() fails. */
#define TH3_TEST_MUTEX               0x00200000
#define TH3_NO_MUTEX_TRY             0x00400000

/* Run PRAGMA temp_store=X on every new connection */
#define TH3_TEMPSTORE_FILE           0x00800000
#define TH3_TEMPSTORE_MEM            0x01000000

/* When opening the database "test.db" change the name to ":memory:" */
#define TH3_MEMDB                    0x02000000

/* Use an alternative page cache implementation */
#define TH3_ALT_PCACHE               0x04000000
#define TH3_ALT_PCACHE_STRESS        0x08000000

/* Run in shared-cache mode */
#define TH3_SHARED_CACHE             0x10000000

/* Control how blob and string data is submitted to bindings in the
** th3dbEval() primitive.
*/
#define TH3_BIND_STATIC              0x20000000  /* This is the default */
#define TH3_BIND_TRANSIENT           0x40000000
#define TH3_BIND_FREE                0x80000000
#define TH3_BIND_ZEROTERMINATE top32(0x00000001)

/* Disable encryption and compression if set */
#define TH3_CLEARTEXT          top32(0x00000002)

/* Different tests are run simulataneously in multiple threads */
#define TH3_THREADS            top32(0x00000004)

/* In some VFSes, all locks are EXCLUSIVE locks.  In other words, there are
** no separate lock states: SHARED, RESERVED, PENDING, EXCLUSIVE.  All
** locks jump immediately to EXCLUSIVE.  When such a VFS is used, this bit
** is set to disable some tests that depend on the full 5-layer locking. */
#define TH3_EXCLUSIVE_ONLY     top32(0x00000008)

/* If present, run PRAGMA recursive_triggers=ON on each connection.
** If omitted, run PRAGMA recursive_triggers=OFF. */
#define TH3_RECURSIVE_TRIGGERS top32(0x00000010)

/* If present, run PRAGMA foreign_keys=ON on each connection.
** If omitted, run PRAGMA foreign_keys=OFF. */
#define TH3_FOREIGN_KEYS       top32(0x00000020)

/* If present, call sqlite3_test_control(SQLITE_TESTCTRL_OPTIMIZATIONS,...)
** to omit all optimizations. */
#define TH3_NO_OPT             top32(0x00000040)

/* Enable the secure_delete pragma */
#define TH3_SECURE_DELETE      top32(0x00000080)

/* Enable the sqlite3_log() interface */
#define TH3_LOG                top32(0x00000100)

/* Truncate to sizes larger than 0 becomes a no-op */
#define TH3_NO_TRUNCATE        top32(0x00000200)

/* Truncate to sizes larger than 0 becomes a no-op */
#define TH3_NO_AUTOINDEX       top32(0x00000400)

/* run PRAGMA locking_mode=EXCLUSIVE on every new connection */
#define TH3_LOCKMODE_EXCLUSIVE top32(0x00000800)

/* Run a check of the amount stack space used after each test module */
#define TH3_CHECK_STACK        top32(0x00001000)

/* If true, the TEST_VFS is modified so that xAccess() returns TRUE if
** zero-length files are reported as existing.  By default, zero-length
** files are reported as non-existant */
#define TH3_ZEROSIZE_FILES_EXIST top32(0x00002000)

/* If true and OOM testing is enabled, run checks to make sure that
** SQLITE_DBSTATUS_SCHEMA_USED and SQLITE_DBSTATUS_STMT_USED do not
** cause problems.
*/
#define TH3_CHECK_MEMSIZE      top32(0x00004000)

/* If true, use the zipvfs.
*/
#define TH3_ZIPVFS             top32(0x00008000)

/* Any test module that invokes sqlite3_initialize() must require this
** property.
*/
#define TH3_INITIALIZE_OK      top32(0x00010000)

/* Configuration that makes use of the xSetSystemCall method in the VFS
** must claim this property.  Test modules that want to use xSetSystemCall
** themselves should disallow this property.
*/
#define TH3_SYSCALL            top32(0x00020000)

/* Enable the use of URI filenames by default */
#define TH3_URI                top32(0x00040000)

/* Use 8+3 filenames where possible */
#define TH3_8_3_NAMES          top32(0x00080000)


/* Some tests depend on pthreads.  Create a macro to indicate that
** pthreads are available.
*/
#if !defined(SQLITE_OS_WIN) && !defined(SQLITE_OS_OTHER) \
  && !defined(_WIN32) && !defined(WIN32) && !defined(__CYGWIN__) \
  && !defined(__MINGW32__) && !defined(__BORLANDC__)
# define TH3_HAVE_PTHREADS 1
#else
# define TH3_HAVE_PTHREADS 0
#endif


/* The th3propName[] table maps property names into their corresponding
** mask values.
*/
static const struct th3propName {
  const char *zName;     /* Name of the property */
  sqlite3_int64 iMask;   /* Mask value */
} th3propName[] = }; lcputs "\173";
foreach x [lsort [array names valid_prop]] {
  lcputs [format {  { %-30s %-30s },} \"$x\", TH3_$x]
}
lcputs "\175;"
lcputs {#line 387 "mkth3.tcl"
/****************************************************************************
** Structure used by the TEST_VFS:  a virtual file system that stores
** everything in memory.
*/
/*
** A single sector of content in the filesystem.
*/
struct th3vfsSector {
  th3vfsSector *pNext, *pPrev;  /* list of all sectors in the filesystem */
  th3vfsFile *pFile;            /* File that sector is part of */
  int idx;                      /* Sector index number */
  int notSynced;                /* True if not synchronized */
  char a[4];                    /* Content. Size is th3vfsFd.szSector bytes */
};

/*
** A single file in the filesystem
*/
struct th3vfsFile {
  th3vfsFile *pNext, *pPrev;  /* List of all files in the filesystem */
  int nRef;                   /* Number of references to this file */
  sqlite3_int64 sz;           /* Size of the file including zero gap */
  sqlite3_int64 szSync;       /* Synchronized size */
  int zerogapStart;           /* First sector in the zero gap.  0==no gap */
  int zerogapCount;           /* Number of sectors in the zero gap */
  u8 notSynced;               /* True if inode is unsynchronized */
  u8 deleteOnClose;           /* True to delete file after closed */
  u8 isExclusive;             /* File cannot be opened more than once */
  u8 readOnly;                /* 0=rd/wr.  1=readonly.  2=SHM readonly */
  u8 autoSchema;              /* Increment the schema cookie when unlocked */
  u8 mxLock;                  /* Maximum file lock value */
  u8 nShm;                    /* Number of connections using shared memory */
  int nReadLock;              /* Number of outstanding read locks */
  sqlite3_int64 rowid;        /* Rowid for when accessed by the VFS-VTAB */
  th3vfsSector **apSector;    /* Array of pointers to sectors */
  int nShmRegion;             /* Number of allocated shared memory regions */
  int szShmRegion;            /* Size of each shared-memory region */
  char **apShm;               /* Shared memory regions */
  char zFilename[1];          /* Must be last.  Uses space allocated at end. */
};

/*
** An open file.
**
** The ignoreWrite flag causes th3vfsWrite() and th3vfsTruncate() and
** similar routines to become noops.  By setting the ignoreWrite flag on
** a database file descriptor then closing the connection, we can simulate
** the death of a process without an sqlite3_close() call - to make sure 
** that other processes reading the same database file continue to function.
*/
struct th3vfsFd {
  sqlite3_file base;         /* Base class.  Must be first */
  int iVfsFdMagic;           /* Magic number */
  u8 readOnly;               /* 0=rd/wr.  1=rdonly file.  2=rdonly shm */
  u8 ignoreWrite;            /* Silently ignore write requests */
  u8 fileLock;               /* Lock held by this file descriptor */
  u8 shmOpen;                /* True if SHM is open */
  u16 shmReadLock;           /* Shared locks held by the shared memory */
  u16 shmWriteLock;          /* Exclusive locks held by the shared memory */
  int openFlags;             /* xOpen() flags used to open this connection */
  th3vfsFSys *pFsys;         /* The filesystem */
  th3vfsFd *pNext, *pPrev;   /* List of all open files in the filesystem */
  th3vfsFile *pFile;         /* The file that is open */
  const char *zOpenName;     /* Name passed to xOpen() */
};
#define TH3VFS_MAGIC_FDOPEN  0x5f3de3e8

/*
** All information about the filesystem
*/
struct th3vfsFSys {
  th3state *p;           /* Test state - needed for th3malloc() */
  int szSector;          /* Sector size */
  int mxSector;          /* Maximum number of sectors */
  int nSector;           /* Current number of sectors + number of files */
  int trace;             /* True to print tracing information */
  sqlite3_int64 nxRowid; /* Next available rowid */
  th3vfsFile *pFile;     /* List of all files in the filesystem */
  th3vfsSector *pSector; /* List of all content sectors */
  th3vfsFd *pOpen;       /* List of open file descriptors */
  struct th3ioerrInfo {
    int iCntdown;          /* I/O operations until an error occurs */
    int iTestIter;         /* Test iteration counter */
    int mask;              /* Only fail on these kinds of errors */
    u8 isHit;              /* True if an error has occurred */
    u8 enable;             /* True to enable I/O errors */
    u8 inTest;             /* True if a test is active */
    u8 useRepeat;          /* True if in multi-failure mode */
    u8 nOverrun;           /* Number of test cases with no failure */
    char zTestName[100];   /* The name of this test */
    int nTestName;         /* Size of the basename of the test */
  } ioerr;
  int nNotSynced;        /* Number of unsynced sectors and files */
  int ssCntdown;         /* Do a snapshot on 1 to 0 transition */
  int ssOmitMask;        /* Ignore these operations when triggering snapshot */
  th3vfsFSys *pFsysSS;   /* Make the snapshot into this filesystem */
  sqlite3_int64 iNow;    /* Current time */
  u8 isAtomic;           /* Sector writes are atomic */
  u8 isSequential;       /* I/O occurs in order */
  u8 isSafeAppend;       /* Data is written before metadata */
  u8 undeletableWhenOpen;/* Unable to delete an open file */
  u8 zerosizeFilesExist; /* Report existance of zero-length files */
  u8 noTruncate;         /* Make non-zero truncates a no-op */
  char zReadonly[50];    /* Files matching this glob-list are read-only */
  int devChar;           /* Device characteristics */
  int nTemp;             /* Number of temporary files created so far */
  int nOpen;             /* Number of open operations performed */
  int nOpenDb;           /* Number of opens of database files */
  int nClose;            /* Number of calls to xClose */
  sqlite3_int64 nRead;   /* Number of bytes read */
  sqlite3_int64 nWrite;  /* Number of bytes written */
  int nSync;             /* Number of sync operations */
  int nFullSync;         /* Number of syncs with SQLITE_SYNC_FULL set */
  int nDataSync;         /* Number of syncs with SQLITE_SYNC_DATA set */
  int nDelete;           /* Number of file deletes */
  int nTruncate;         /* Number of file truncations */
  int nLock;             /* Number of calls to file locking primitives */
  int nSyscall;          /* Number of system calls */
  int nShmop;            /* Number of shared-memory operations */
  const sqlite3_io_methods *pMethods; /* Use this I/O method set, if not NULL */
};

/*
** Bitmask values for the different kinds of simulated I/O failures.
*/
#define TH3VFS_IOERR_OPEN                         0x00000001
#define TH3VFS_IOERR_DELETE                       0x00000002
#define TH3VFS_IOERR_ACCESS                       0x00000004
#define TH3VFS_IOERR_READ                         0x00000008
#define TH3VFS_IOERR_WRITE                        0x00000010
#define TH3VFS_IOERR_TRUNCATE                     0x00000020
#define TH3VFS_IOERR_SYNC                         0x00000040
#define TH3VFS_IOERR_FILESIZE                     0x00000080
#define TH3VFS_IOERR_LOCK                         0x00000100
#define TH3VFS_IOERR_UNLOCK                       0x00000200
#define TH3VFS_IOERR_CHECKRESERVEDLOCK            0x00000400
#define TH3VFS_IOERR_SECTORSIZE                   0x00000800
#define TH3VFS_IOERR_DEVICECHARACTERISTICS        0x00001000
#define TH3VFS_IOERR_GETTEMPNAME                  0x00002000
#define TH3VFS_IOERR_FULLPATHNAME                 0x00004000
#define TH3VFS_IOERR_SHMOPEN                      0x00008000
#define TH3VFS_IOERR_SHMLOCK                      0x00010000
#define TH3VFS_IOERR_SHMLOCK_BUSY                 0x00100000
#define TH3VFS_IOERR_SHMMAP                       0x00020000
#define TH3VFS_IOERR_ALL                          0x000fffff
/* Used to trigger a snapshot *before* a delete operation.  This
** helps to implement --commit-snapshot */
#define TH3VFS_IOERR_PREDELETE                    0x00100000
/* Simulate disk-full errors */
#define TH3VFS_IOERR_FULL                         0x00200000
/* Force repeated errors only.  Omit one-time errors */
#define TH3VFS_IOERR_REPEAT                       0x40000000

/* Symbolic names for all I/O error masks */
static const struct {
  const char *zName;    /* Symbolic name */
  int mask;             /* Mask */
} th3ioerrType[] = {
  { "full",             TH3VFS_IOERR_FULL | TH3VFS_IOERR_REPEAT   },
  { "shmmap",           TH3VFS_IOERR_SHMMAP                       },
  { "shmlockbusy",      TH3VFS_IOERR_SHMLOCK_BUSY                 },
  { "filesize",         TH3VFS_IOERR_FILESIZE                     },
  { "truncate",         TH3VFS_IOERR_TRUNCATE                     },
  { "all",              TH3VFS_IOERR_ALL                          },
};


/* Here ends the definitions for the TEST_VFS virtual filesystem.
****************************************************************************/

/*
** Maximum number of open database connections used by the
** th3db infrastructure.
*/
#define TH3_MAX_DB   6

/*
** Maximum number of open files used by the th3file infrastructure.
*/
#define TH3_MAX_FILE 4

/*
** Each th3Db database connection is an instance of this object.
*/
struct th3db {
  sqlite3 *db;                   /* The open database connection */
  th3state *p;                   /* Pointer back to the containing state obj */
  char columnMode;               /* include column names in output */
  char typeMode;                 /* include datatype names in output */
  char *zDest;            /* Name of table in which to store results */
};

/*
** A memory allocation used by the test harness - distinct from
** the memory allocations used by SQLite.
*/
struct th3mem {
  int nByte;             /* Size of this allocation */
  th3mem *pNext, *pPrev; /* List of all outstanding allocations */
};

/*
** Context for an md5 checksum
*/
struct md5Context {
  int isInit;
  u32 buf[4];
  u32 bits[2];
  unsigned char in[64];
};
typedef struct md5Context md5Context;

/*
** State of a PRNG
*/
struct th3prng {
  unsigned int x, y;
};

/*
** The name and value of a variable that will be automatically bound to
** SQL statement evaluated using th3dbEval().
**
** Content for zName and in u.z is stored in memory obtained from
** th3malloc().
*/
struct th3var {
  char *zName;       /* Name to bind against. Anonymous params not supported */
  short int eType;   /* Binding type.  TH3_BIND_* */
  short int iExtra;  /* extra data space */
  union {
    struct {
      char *z;           /* Content for string and BLOB types */
      int n;             /* Bytes in content (not counting zero terminator) */
    } b;
    sqlite3_int64 i;     /* Content for integer types */
    double r;            /* Content for real types */
  } u;
};

/*
** Number of Bind Variable Store entries.
*/
#define TH3_N_BVS 10

/*
** Allowed binding types for a th3var:
*/
#define TH3_BIND_BLOB          1
#define TH3_BIND_DOUBLE        2
#define TH3_BIND_INT           3
#define TH3_BIND_INT64         4
#define TH3_BIND_NULL          5
#define TH3_BIND_TEXT          6
#define TH3_BIND_TEXT16        7
#define TH3_BIND_ZEROBLOB      8

/*
** Maximum size of the statement cache
*/
#define TH3_N_STMTCACHE 10


/*
** The state vector for a test running in a single thread.  There is
** one instance of this object for each thread of the test harness.
*/
struct th3state {
  TestConfiguration config;      /* Configuration for current test */
  TestModule module;             /* Module currently under test */
  int tid;                       /* Thread id */
  char *zResult;                 /* Buffer holding test results */
  int nResult;                   /* Number of characters in zResult[] */
  int nResultAlloc;              /* Space allocated for zResult[] */
  int bRawResult;                /* Do not quote results if true */
  char *zLog;                    /* Buffer holding sqlite3_log output */
  int nLog;                      /* Number of characters in zLog[] */
  int nLogAlloc;                 /* Space allocated for zLog[] */
  int nRetest;                   /* Number of retests of a single test case */
  int nOk;                       /* Number of successful tests so far */
  int nFail;                     /* Number of failed tests so far */
  th3prng sRand;                 /* Current PRNG state */
  th3vfsFSys fsysTest;           /* The test VFS */
  th3vfsFSys fsysSS;             /* Snapshot of test VFS */
  char zVfsName[16];             /* Name of the test VFS */
  sqlite3_vfs testVfs;           /* The test VFS for this thread */
  sqlite3_vfs *pVfs;             /* VFS used by all database connections */
  char *zTemp;                   /* Space for a temporary string */
  sqlite3_file *apFile[TH3_MAX_FILE];  /* Files opened by th3fileOpen() */
  th3db aDb[TH3_MAX_DB+1];       /* DB connections for th3db framework */
  th3mem *pMem;                  /* Outstanding memory */
  int nMem;                      /* Total bytes of outstanding memory */
  int mxMem;                     /* Outstanding memory highwater */
  int nAlloc;                    /* Total outstanding allocation count */
  int mxAlloc;                   /* Allocation count highwater */
  unsigned nStep;                /* Fullscan steps in most recent th3dbEval() */
  unsigned nSort;                /* Fullscan sorts in most recent th3dbEval() */
  FILE *out;                     /* Send log messages here */
  th3var aVar[TH3_N_BVS];        /* Space to hold variables */
  void (*xBindFree)(void*);      /* SQLITE_STATIC, SQLITE_TRANSIENT, free() */
  md5Context md5;                /* MD5 checksum context */
  char zMd5[33];                 /* Finished MD5 hash */
  char zTestName[50];            /* Name of current test */
  void *pTestData;               /* Pointer to test-specific data */
  int nStmtCache;                /* Size of the statement cache */
  struct th3StmtCache {
    sqlite3_stmt *pStmt;            /* The cached statement */
    int nSql;                       /* Bytes of SQL text in statement */
    int iDb;                        /* aDb[] that owns.  -1 for none. */
    int iAge;                       /* For LRU replacement */
  } aStmtCache[TH3_N_STMTCACHE]; /* The statement cache */
  int iStmtAge;                  /* Counter to fill aStmtCache[].iAge */
  int nReserve;                  /* Reserve space for new db connections */
  int bUsePrepareV2;             /* use prepare_v2() instead of prepare() */
};

/************************************************************************
** Here begins the declaration of a virtual table that provides a
** table view of one of the in-memory VFS instances.  The implementation
** is separate.
*/

/* Each VFS-VTAB is an instance of the following structure.  This structure
** is a subclass of sqlite3_vtab
*/
typedef struct th3vfsvtab {
  sqlite3_vtab parent;      /* Parent class */
  th3vfsFSys *pFSys;        /* The file system this vtab wraps */
} th3vfsvtab;

/* A cursor used to walk through a VFS-VTAB is an instance of this
** object. This object is a subclass of sqlite3_vtab_cursor.
*/
typedef struct th3vfsvtabCursor {
  sqlite3_vtab_cursor parent;   /* Parent class */
  th3vfsFile *pFile;            /* Current file we are looking at */
} th3vfsvtabCursor;

/*
** These are the methods that implement the virtual table.  The
** implementation of the methods is defined further own in the file.
*/
static int th3vfsvtabConnect(
  sqlite3 *db,                /* The database connection */
  void *pAux,                 /* Pointer to the th3vfsFSys object */
  int argc,                   /* Number of arguments */
  const char *const*argv,     /* Text of the arguments */
  sqlite3_vtab **ppVTab,      /* Write the new vtab here */
  char **pzErr                /* Error message written here */
);
static int th3vfsvtabBestIndex(sqlite3_vtab *pVTab, sqlite3_index_info *pInfo);
static int th3vfsvtabDisconnect(sqlite3_vtab *pVTab);
static int th3vfsvtabOpen(sqlite3_vtab *pVTab, sqlite3_vtab_cursor **ppCursor);
static int th3vfsvtabClose(sqlite3_vtab_cursor *pCur);
static int th3vfsvtabFilter(
  sqlite3_vtab_cursor *pCur,   /* The cursor to rewind */
  int idxNum,                   /* Not used */
  const char *idxStr,           /* Not used */
  int argc,                     /* Not used */
  sqlite3_value **argv          /* Not used */
);
static int th3vfsvtabNext(sqlite3_vtab_cursor *pCur);
static int th3vfsvtabEof(sqlite3_vtab_cursor *pCur);
static int th3vfsvtabColumn(
  sqlite3_vtab_cursor *pCur,
  sqlite3_context *context,
  int N
);
static int th3vfsvtabRowid(sqlite3_vtab_cursor *pCur, sqlite3_int64 *pRowid);
static int th3vfsvtabRename(sqlite3_vtab *pVtab, const char *zNew);


/* This is the sqlite3_module definition for the the virtual table that
** scans a VFS.
*/
static const sqlite3_module th3vfsvtabModule = {
  /* iVersion      */  1,
  /* xCreate       */  th3vfsvtabConnect,
  /* xConnect      */  th3vfsvtabConnect,
  /* xBestIndex    */  th3vfsvtabBestIndex,
  /* xDisconnect   */  th3vfsvtabDisconnect,
  /* xDestroy      */  th3vfsvtabDisconnect,
  /* xOpen         */  th3vfsvtabOpen,
  /* xClose        */  th3vfsvtabClose,
  /* xFilter       */  th3vfsvtabFilter,
  /* xNext         */  th3vfsvtabNext,
  /* xEof          */  th3vfsvtabEof,
  /* xColumn       */  th3vfsvtabColumn,
  /* xRowid        */  th3vfsvtabRowid,
  /* xUpdate       */  0, 
  /* xBegin        */  0, 
  /* xSync         */  0,
  /* xCommit       */  0, 
  /* xRollback     */  0,
  /* xFindFunction */  0,
  /* xRename       */  th3vfsvtabRename
};

/*
** End the declaration of the TEST_VFS virtual table.
******************************************************************************/
/************************************************************************
** Here begins the declaration of a virtual table that provides a
** table view of th3state bind variable store (BVS).  The implementation
** is separate.
*/

/* Each bind-variable-store virtual table is an instance of the
** following structure.  This structure is a subclass of sqlite3_vtab
*/
typedef struct th3bvsvtab {
  sqlite3_vtab parent;   /* Parent class */
  th3state *p;           /* The test thread holding the bind variables */
} th3bvsvtab;

/* A cursor used to walk through a bind-variable-store is an instance of this
** object. This object is a subclass of sqlite3_vtab_cursor.
*/
typedef struct th3bvsvtabCursor {
  sqlite3_vtab_cursor parent;   /* Parent class */
  int i;                        /* Index into th3state.aVar[] of an entry */
} th3bvsvtabCursor;

/*
** These are the methods that implement the virtual table.  The
** implementation of the methods is defined further own in the file.
*/
static int th3bvsvtabConnect(
  sqlite3 *db,                /* The database connection */
  void *pAux,                 /* Pointer to the th3vfsFSys object */
  int argc,                   /* Number of arguments */
  const char *const*argv,     /* Text of the arguments */
  sqlite3_vtab **ppVTab,      /* Write the new vtab here */
  char **pzErr                /* Error message written here */
);
static int th3bvsvtabBestIndex(sqlite3_vtab *pVTab, sqlite3_index_info *pInfo);
static int th3bvsvtabDisconnect(sqlite3_vtab *pVTab);
static int th3bvsvtabOpen(sqlite3_vtab *pVTab, sqlite3_vtab_cursor **ppCursor);
static int th3bvsvtabClose(sqlite3_vtab_cursor *pCur);
static int th3bvsvtabFilter(
  sqlite3_vtab_cursor *pCur,   /* The cursor to rewind */
  int idxNum,                   /* Not used */
  const char *idxStr,           /* Not used */
  int argc,                     /* Not used */
  sqlite3_value **argv          /* Not used */
);
static int th3bvsvtabNext(sqlite3_vtab_cursor *pCur);
static int th3bvsvtabEof(sqlite3_vtab_cursor *pCur);
static int th3bvsvtabColumn(
  sqlite3_vtab_cursor *pCur,
  sqlite3_context *context,
  int N
);
static int th3bvsvtabRowid(sqlite3_vtab_cursor *pCur, sqlite3_int64 *pRowid);
static int th3bvsvtabUpdate(
  sqlite3_vtab *pVtab,
  int argc,
  sqlite3_value **argv,
  sqlite_int64 *pNewRowid
);
static int th3bvsvtabRename(sqlite3_vtab *pVtab, const char *zNew);


/* This is the sqlite3_module definition for the the virtual table that
** scans a bind variable store.
*/
static const sqlite3_module th3bvsvtabModule = {
  /* iVersion      */  2,
  /* xCreate       */  th3bvsvtabConnect,
  /* xConnect      */  th3bvsvtabConnect,
  /* xBestIndex    */  th3bvsvtabBestIndex,
  /* xDisconnect   */  th3bvsvtabDisconnect,
  /* xDestroy      */  th3bvsvtabDisconnect,
  /* xOpen         */  th3bvsvtabOpen,
  /* xClose        */  th3bvsvtabClose,
  /* xFilter       */  th3bvsvtabFilter,
  /* xNext         */  th3bvsvtabNext,
  /* xEof          */  th3bvsvtabEof,
  /* xColumn       */  th3bvsvtabColumn,
  /* xRowid        */  th3bvsvtabRowid,
  /* xUpdate       */  th3bvsvtabUpdate, 
  /* xBegin        */  0, 
  /* xSync         */  0,
  /* xCommit       */  0, 
  /* xRollback     */  0,
  /* xFindFunction */  0,
  /* xRename       */  th3bvsvtabRename,
  /* xSavepoint    */  0,
  /* xRelease      */  0,
  /* xRollbackTo   */  0
};

/*
** End the declaration of the bind-variable-store virtual table.
******************************************************************************/

/*
** Macro to check a condition and fail the entire test module if false.
*/
#define th3assert(X)  if(!(X)) return 1;


/**************************************************************************
** The low-level interface to the underlying operating system is captured
** by the following code.  When TH3 is run on platforms that have unusual
** interface requirements, this is the section that needs to change.
**
** For convenience, an alternative implementation of these routines
** can be put in an include file "th3_alt_os.h" and then this file can
** be compiled with -DTH3_ALT_OS and the code in th3_alt_os.h will
** be used in place of the implementation provided by default.
*/

#ifdef TH3_ALT_OS
# include "th3_alt_os.h"
#else
/*
** Open or close a logfile.  A NULL pointer causes output to go to
** standard output.  The primary test thread uses standard output.
** other threads use files.  If only a single test thread is to be
** run, the open routine can be modified to always return NULL and
** the close routine can be modified to be a no-op and everything
** will work out fine.
*/
FILE *th3openLogFile(const char *zFilename, int appendFlag){
  return fopen(zFilename, appendFlag ? "a" : "w");
}
void th3closeLogFile(FILE *out){
  if( out ) fclose(out);
}

/*
** Send output to the log file specified by p->out.  If p->out==NULL
** then the output goes to standard output.  Output also goes to standard
** error if compiled with the TH3_TEE compile-time option.
**
*/
void th3Nprint(th3state *p, const char *z, int n){
#ifdef TH3_TEE
  fwrite(z, 1, n, p->out ? stdout : stderr);
#endif
  fwrite(z, 1, n, p->out ? p->out : stdout);
}
void th3print(th3state *p, const char *z){
#ifdef TH3_TEE
  fputs(z, p->out ? stdout : stderr);
#endif
  fputs(z, p->out ? p->out : stdout);
}
void th3flush(th3state *p){
#ifdef TH3_TEE
  fflush(p->out ? stdout : stderr);
#endif
  fflush(p->out ? p->out : stdout);
}

/*
** Panic and die.  This should never happen.
*/
void th3panic(const char *zMsg){
  fprintf(stderr, "PANIC: %s\n", zMsg);
  exit(1);
}

/*
** Low-level memory allocation not associated with a particular
** test stream.  If an implementation needs to implement a custom
** malloc implementation, this is the place to do it.
*/
void *th3mallocRaw(int nByte){
  void *x = malloc(nByte);
  if( x==0 ){
    th3panic("out of memory");
  }
  return x;
}
void th3freeRaw(void *p){
  free(p);
}

/*
** Character class routines
*/
int th3isspace(int c){
  return c==' ' || c=='\n' || c=='\r' || c=='\t';
}
int th3isalpha(int c){
  return (c>='a' && c<='z') || (c>='A' && c<='Z');
}
int th3isalnum(int c){
  return (c>='a' && c<='z') || (c>='A' && c<='Z') || (c>='0' && c<='9');
}
int th3isdigit(int c){
  return c>='0' && c<='9';
}

/* String formatter
*/
int th3vsnprintf(char *str, size_t size, const char *format, va_list ap){
#ifdef WITHOUT_VSNPRINTF
  return vsprintf(str, format, ap);
#else
  return vsnprintf(str, size, format, ap);
#endif
}

/* BLOB and string comparison and copy operators.
*/
void *th3memcpy(void *dest, const void *src, size_t n){
  return memcpy(dest, src, n);
}
void *th3memset(void *s, int c, size_t n){
  return memset(s, c, n);
}
int th3strcmp(const char *s1, const char *s2){
  return strcmp(s1, s2);
}
int th3strncmp(const char *s1, const char *s2, size_t n){
  return strncmp(s1, s2, n);
}
char *th3strcpy(char *dest, const char *src){
  return strcpy(dest, src);
}
char *th3strcat(char *dest, const char *src){
  return strcat(dest, src);
}
#endif /* !defined(TH3_ALT_OS) */
/*
** End of the low-level operating system interface
*****************************************************************************/

/*
** Wrapper for snprintf()
*/
int th3snprintf(char *str, size_t size, const char *format, ...){
  va_list ap;
  int rc;
  va_start(ap, format);
  rc = th3vsnprintf(str, size, format, ap);
  va_end(ap);
  return rc;
}

/*
** Allocate memory for use by a particular test steam.
*/
void *th3malloc(th3state *p, int nByte){
  th3mem *x;
  if( nByte<=0 ) return 0;
  x = th3mallocRaw( nByte + sizeof(*x) );
  p->nMem += nByte;
  if( p->nMem>p->mxMem ){
    if( p->nMem/10000000 > p->mxMem/10000000 ){
      char zMsg[80];
      sqlite3_snprintf(sizeof(zMsg), zMsg, "Peak TH3 memory to %d\n", p->nMem);
      th3print(p, zMsg);
    }
    p->mxMem = p->nMem;
  }
  p->nAlloc++;
  if( p->nAlloc>p->mxAlloc ) p->mxAlloc = p->nAlloc;
  x->nByte = nByte;
  x->pPrev = 0;
  x->pNext = p->pMem;
  if( x->pNext ) x->pNext->pPrev = x;
  p->pMem = x;
  return (void*)&x[1];
}

/*
** Free memory used by the test stream.
*/
void th3free(th3state *p, void *pOld){
  th3mem *x;
  if( pOld==0 ) return;
  x = (th3mem*)pOld;
  x--;
  p->nMem -= x->nByte;
  p->nAlloc--;
  if( x->pPrev ){
    x->pPrev->pNext = x->pNext;
  }else{
    p->pMem = x->pNext;
  }
  if( x->pNext ){
    x->pNext->pPrev = x->pPrev;
  }
  th3freeRaw(x);
}

/*
** Free all memory for a test module.
*/
void th3freeAll(th3state *p){
  while( p->pMem ){
    th3free(p, &p->pMem[1]);
  }
  assert( p->nMem==0 );
  p->zTemp = 0;
  p->zResult = 0;
  p->nResult = 0;
  p->nResultAlloc = 0;
  p->zLog = 0;
  p->nLog = 0;
  p->nLogAlloc = 0;
}

/*
** Resize an allocation used by the test harness
*/
void *th3realloc(th3state *p, void *pOld, int nByte){
  if( pOld==0 ){
    return th3malloc(p, nByte);
  }else if( nByte<=0 ){
    th3free(p, pOld);
    return 0;
  }else{
    th3mem *x = (th3mem*)pOld;
    void *pNew;
    x--;
    pNew = th3malloc(p, nByte);
    if( pNew ){
      int n = x->nByte;
      if( n>nByte ) n = nByte;
      th3memcpy(pNew, pOld, n);
      th3free(p, pOld);
    }
    return pNew;
  } 
}
/*
** Return non-zero if string z matches glob pattern zGlob and zero if the
** pattern does not match.
**
** Globbing rules:
**
**      '*'       Matches any sequence of zero or more characters.
**
**      '?'       Matches exactly one character.
**
**     [...]      Matches one character from the enclosed list of
**                characters.
**
**     [^...]     Matches one character not in the enclosed list.
**
**      '#'       Matches any sequence of one or more digits with an
**                optional + or - sign in front
*/
int th3strnotglob(const char *zGlob, const char *z){
  int c, c2;
  int invert;
  int seen;

  while( (c = (*(zGlob++)))!=0 ){
    if( c=='*' ){
      while( (c=(*(zGlob++))) == '*' || c=='?' ){
        if( c=='?' && (*(z++))==0 ) return 0;
      }
      if( c==0 ){
        return 1;
      }else if( c=='[' ){
        while( *z && th3strnotglob(zGlob-1,z)==0 ){
          z++;
        }
        return (*z)!=0;
      }
      while( (c2 = (*(z++)))!=0 ){
        while( c2!=c ){
          c2 = *(z++);
          if( c2==0 ) return 0;
        }
        if( th3strnotglob(zGlob,z) ) return 1;
      }
      return 0;
    }else if( c=='?' ){
      if( (*(z++))==0 ) return 0;
    }else if( c=='[' ){
      int prior_c = 0;
      seen = 0;
      invert = 0;
      c = *(z++);
      if( c==0 ) return 0;
      c2 = *(zGlob++);
      if( c2=='^' ){
        invert = 1;
        c2 = *(zGlob++);
      }
      if( c2==']' ){
        if( c==']' ) seen = 1;
        c2 = *(zGlob++);
      }
      while( c2 && c2!=']' ){
        if( c2=='-' && zGlob[0]!=']' && zGlob[0]!=0 && prior_c>0 ){
          c2 = *(zGlob++);
          if( c>=prior_c && c<=c2 ) seen = 1;
          prior_c = 0;
        }else{
          if( c==c2 ){
            seen = 1;
          }
          prior_c = c2;
        }
        c2 = *(zGlob++);
      }
      if( c2==0 || (seen ^ invert)==0 ) return 0;
    }else if( c=='#' ){
      if( (z[0]=='-' || z[0]=='+') && th3isdigit(z[1]) ) z++;
      if( !th3isdigit(z[0]) ) return 0;
      z++;
      while( th3isdigit(z[0]) ){ z++; }
    }else{
      if( c!=(*(z++)) ) return 0;
    }
  }
  return *z==0;
}

/* Invert the results of th3strnotglob() */
int th3strglob(const char *zGlob, const char *z){
  return !th3strnotglob(zGlob,z);
}

/* zGlobList is a |-separate list of glob patterns.  Return TRUE if
** zName matches any of the glob patterns.  Return false if zGlobList
** is NULL or an empty string. */
int th3strglobAny(const char *zGlobList, const char *z){
  int i;
  char zOneGlob[50];
  if( zGlobList==0 ) return 0;
  while( zGlobList[0] ){
    for(i=1; zGlobList[i] && zGlobList[i]!='|'; i++){}
    sqlite3_snprintf(sizeof(zOneGlob),zOneGlob,"%.*s", i, zGlobList);
    if( th3strnotglob(zOneGlob, z) ) return 1;
    zGlobList += i;
    while( zGlobList[0]=='|' ) zGlobList++;
  }
  return 0;
}

/*
** Convert a string into a 64-bit signed integer.
*/
static sqlite3_int64 th3atoi64(const char *z){
  sqlite3_int64 i = 0;
  int isNeg = 0;
  if( z[0]=='-' ){
    isNeg = 1;
    z++;
  }else if( z[0]=='+' ){
    z++;
  }
  while( th3isdigit(z[0]) ){
    i = i*10 + z[0] - '0';
    z++;
  }
  if( isNeg ) i = -i;
  return i;
}

/*
** Format a string into p->zTemp.  Allocate memory for p->zTemp if it has
** not already been allocated.
*/
char *th3vformat(th3state *p, const char *zFormat, va_list ap){
  if( p->zTemp==0 ){
    p->zTemp = th3malloc(p, p->module.maxFormat+1);
    if( p->zTemp==0 ) return 0;
  }
  th3vsnprintf(p->zTemp, p->module.maxFormat, zFormat, ap);
  assert( strlen(p->zTemp)<=p->module.maxFormat );
  return p->zTemp;
}
char *th3format(th3state *p, const char *zFormat, ...){
  va_list ap;
  va_start(ap, zFormat);
  th3vformat(p, zFormat, ap);
  va_end(ap);
  return p->zTemp;
}

/*
** Duplicate a string into memory obtained from th3malloc()
*/
char *th3strndup(th3state *p, const char *zIn, int nIn){
  char *zOut;
  if( nIn<0 ) nIn = strlen(zIn);
  zOut = th3malloc(p, nIn+1);
  th3memcpy(zOut, zIn, nIn);
  zOut[nIn] = 0;
  return zOut;
}

/*
** Reseed the PRNG
*/
void th3randomReseed(th3state *p, int a){
  p->sRand.x = a | 1;
  p->sRand.y = a;
}

/*
** Compute a random non-negative integer
*/
int th3randomInt(th3state *p){
  p->sRand.x = (p->sRand.x>>1) ^ (-(p->sRand.x&1) & 0xd0000001);
  p->sRand.y = p->sRand.y*1103515245 + 12345;
  return (p->sRand.x ^ p->sRand.y)&0x7fffffff;
}

/*
** Compute a single pseudo-random byte.
*/
unsigned char th3randomByte(th3state *p){
  return th3randomInt(p) & 0xff;
}

/*
** Compute multiple bytes of pseudo-randomness
*/
void th3randomBlob(th3state *p, char *pBuf, int nByte){
  while( nByte-- > 0 ){
    *(pBuf++) = th3randomInt(p) & 0xff;
  }
}

/* Forward declaration */
void th3append(
  th3state *p,             /* State variable */
  char **pz,               /* Pointer to space to hold the string */
  int *pLen,               /* Current string length */
  int *pnAlloc,            /* Space allocated so far */
  const char *zToAppend    /* Text to append */
);

/*
** Print the title of a test.
*/
static void th3testPrintTitle(th3state *p, const char *zSuffix){
  th3print(p, p->config.zConfigName);
  th3print(p, ".");
  th3print(p, p->module.zModuleName);
  th3print(p, ".");
  th3print(p, p->zTestName);
  if( p->nRetest ){
    char zCnt[30];
    th3snprintf(zCnt, sizeof(zCnt), "+%d", p->nRetest);
    th3print(p, zCnt);
  }
  th3print(p, zSuffix);
  th3flush(p);
}

/*
** Begin a test
*/
void th3testBegin(th3state *p, const char *zTestName){
  sqlite3_snprintf(sizeof(p->zTestName), p->zTestName, "%s", zTestName);
  p->nRetest = 0;
#ifdef TH3_VERBOSE
  th3testPrintTitle(p, "... ");
#endif
  if( p->zResult==0 ){
    th3append(p, &p->zResult, &p->nResult, &p->nResultAlloc, "x");
  }
  p->nResult = 0;
  p->zResult[0] = 0;
  p->nLog = 0;
}

/*
** Indicate that a test has failed.  If zReason is non-zero then it is a
** string that indicates the reason for the failure.
*/
void th3testFailed(th3state *p, const char *zReason){
#ifndef TH3_VERBOSE
  th3testPrintTitle(p, "... ");
#else
  if( p->nRetest>0 ) th3testPrintTitle(p, "... ");
#endif
  if( zReason && zReason[0] ){
    th3print(p, "FAILED (");
    th3print(p, zReason);
    th3print(p, ") ");
  }else{
    th3print(p, "FAILED ");
  }
  th3print(p, "\n");
  th3flush(p);
  p->nFail++;
  p->nRetest++;
}

/*
** Indicate that a test has succeeded
*/
void th3testOk(th3state *p){
#ifdef TH3_VERBOSE
  if( p->nRetest ) th3testPrintTitle(p, "... ");
  th3print(p, "Ok ");
  th3print(p, "\n");
  th3flush(p);
#endif
  p->nOk++;
  p->nRetest++;
}

/*
** Append text to the end of a string.
*/
void th3append(
  th3state *p,             /* State variable */
  char **pz,               /* Pointer to space to hold the string */
  int *pLen,               /* Current string length */
  int *pnAlloc,            /* Space allocated so far */
  const char *zToAppend    /* Text to append */
){
  int n = strlen(zToAppend);
  if( *pLen+n >= *pnAlloc ){
    int x = (*pLen)*2 + n + 100;
    char *zNew;
    zNew = th3realloc(p, *pz, x);
    if( zNew==0 ) return;
    *pz = zNew;
    *pnAlloc = x;
  }
  th3memcpy(&(*pz)[*pLen], zToAppend, n+1);
  *pLen += n;
}

/*
** Append text as a term on the end of a string.
*/
void th3appendTerm(
  th3state *p,            /* State variable */
  char **pz,              /* Pointer to space to hold the string */
  int *pLen,              /* Current string length */
  int *pnAlloc,           /* Space allocated so far */
  const char *zToAppend   /* Text to append */
){
  int n;
  int hasSpace = 0;
  int hasCurly = 0;
  int nDblQuote = 0;
  int nBackSlash = 0;
  int nEsc = 0;
  int i, c;
  char *z;

  if( p->bRawResult ){
    th3append(p, pz, pLen, pnAlloc, zToAppend ? zToAppend : "");
    return;
  }
  if( zToAppend==0 ) zToAppend = "nil";
  for(i=0; (c = (unsigned char)zToAppend[i])!=0; i++){
    if( c=='}' || c=='{' ) hasCurly = 1;
    else if( c=='\\' ) nBackSlash++;
    else if( c=='"' ) nDblQuote++;
    else if( c<=' ' ){
      if( c==' ' ) hasSpace = 1;
      else nEsc++;
    }
  }
  if( *pLen ){
    th3append(p, pz, pLen, pnAlloc, " ");
  }
  if( !hasSpace && !hasCurly && nDblQuote==0 && nEsc==0 && zToAppend[0]!=0 ){
    th3append(p, pz, pLen, pnAlloc, zToAppend);
    return;
  }
  if( hasCurly==0 && nEsc==0 ){
    th3append(p, pz, pLen, pnAlloc, "{");
    th3append(p, pz, pLen, pnAlloc, zToAppend);
    th3append(p, pz, pLen, pnAlloc, "}");
    return;
  }
  n = i+nDblQuote+nBackSlash+nEsc*3+2;
  if( *pLen+n >= *pnAlloc ){
    int x = (*pLen)*2 + n + 100;
    char *zNew;
    zNew = th3realloc(p, *pz, x);
    if( zNew==0 ) return;
    *pz = zNew;
    *pnAlloc = x;
  }
  z = &(*pz)[*pLen];
  *z++ = '"';
  for(i=0; (c = (unsigned char)zToAppend[i])!=0; i++){
    if( c=='"' || c=='\\' ){
      *z++ = '\\';
      *z++ = c;
    }else if( c<' ' ){
      *z++ = '\\';
      *z++ = '0' + ((c>>6)&3);
      *z++ = '0' + ((c>>3)&7);
      *z++ = '0' + (c&7);
    }else{
      *z++ = c;
    }
  }
  *z++ = '"';
  *z = 0;
  *pLen += n;
}

/*
** Append to the result string.
*/
void th3testAppendResult(th3state *p, const char *zToAppend){
  th3append(p, &p->zResult, &p->nResult, &p->nResultAlloc, zToAppend);
}

/*
** Append to the result string term
*/
void th3testAppendResultTerm(th3state *p, const char *zToAppend){
  th3appendTerm(p, &p->zResult, &p->nResult, &p->nResultAlloc, zToAppend);
}

/*
** Reset the truth or result strings back to zero.
*/
void th3testResetResult(th3state *p){
  p->nResult = 0;
  if( p->zResult ) p->zResult[0] = 0;
}
void th3testResetLog(th3state *p){
  p->nLog= 0;
  if( p->zLog ) p->zLog[0] = 0;
}

/* Forward references */
const char *th3errorCodeName(int);
static void th3oomInternalDisable(int);

/*
** Append error log terms.
*/
void th3logger(void *pArg, int iErrCode, const char *zMsg){
  th3state *p = (th3state*)pArg;
  const char *zECode;
  char zErrCode[30];
  zECode = th3errorCodeName(iErrCode);
  if( zECode[0]=='U' ){
    sqlite3_snprintf(sizeof(zErrCode), zErrCode, "%d", iErrCode);
    zECode = zErrCode;
  }
  th3appendTerm(p, &p->zLog, &p->nLog, &p->nLogAlloc, zECode);
  th3appendTerm(p, &p->zLog, &p->nLog, &p->nLogAlloc, zMsg);
}

/*
** Print expected and actual results.
*/
void th3testShowResults(
  th3state *p,
  const char *zTruth,
  const char *zResult
){
  th3print(p, " ==== ");
  p->nRetest--;
  th3testPrintTitle(p, " ====\n Expected: [");
  p->nRetest++;
  th3print(p, zTruth);
  th3print(p, "]\n      Got: [");
  th3print(p, zResult);
  th3print(p, "]\n");
  th3flush(p);
}

/*
** Compare zTruth with the result.
*/
void th3testCheckCmp(
  th3state *p,
  const char *zTruth,
  int (*xCmp)(const char*,const char*)
){
  if( (*xCmp)(zTruth, p->zResult)!=0 ){
    th3testFailed(p, 0);
    th3testShowResults(p, zTruth, p->zResult);
  }else{
    th3testOk(p);
  }
}
void th3testCheck(th3state *p, const char *zTruth){
  th3testCheckCmp(p, zTruth, th3strcmp);
}
void th3testCheckGlob(th3state *p, const char *zTruth){
  th3testCheckCmp(p, zTruth, th3strglob);
}
void th3testCheckNotGlob(th3state *p, const char *zTruth){
  th3testCheckCmp(p, zTruth, th3strnotglob);
}

/*
** Test to see if iTruth equal iActual and issue an error if not.
*/
void th3testCheckInt(th3state *p, int iTruth, int iActual){
  if( iTruth!=iActual ){
    char zTruth[40];
    char zActual[40];
    th3testFailed(p, 0);
    sqlite3_snprintf(sizeof(zTruth), zTruth, "%d", iTruth);
    sqlite3_snprintf(sizeof(zActual), zActual, "%d", iActual);
    th3testShowResults(p, zTruth, zActual);
  }else{
    th3testOk(p);
  }
}

/*
** Test to see if zTruth equal zActual and issue an error if not.
*/
void th3testCheckString(th3state *p, const char *zTruth, const char *zActual){
  if( th3strcmp(zTruth, zActual)!=0 ){
    th3testFailed(p, 0);
    th3testShowResults(p, zTruth, zActual);
  }else{
    th3testOk(p);
  }
}

/*
** Test to see if iTruth is true.  Report an error if not.
*/
void th3testCheckTrue(th3state *p, int iTruth){
  if( iTruth==0 ){
    th3testFailed(p, 0);
    th3testShowResults(p, "TRUE", "FALSE");
  }else{
    th3testOk(p);
  }
}

/*
** Test to see if the log message matches the given pattern.  Or, if LOG
** is disabled, this routine is a no-op.
**
** This is called after th3testCheck or th3testCheckInt and applies to
** the previous test.
**
** The '#' character in the pattern matches any sequence of digits in the
** actual log.  "[SOURCEID]" will match the first 10 characters of the
** SHA1 checksum.
*/
void th3testCheckLog(th3state *p, const char *zPattern, int nPattern){
  if( p->config.maskProp & TH3_LOG ){
    int i, j, c;
    const char *zLog = p->zLog;

    if( nPattern<0 ) nPattern = strlen(zPattern);
    th3testBegin(p, th3format(p, "%s-log", p->zTestName));
    if( zLog==0 ) zLog = "";
    for(i=j=0; i<nPattern; i++){
      if( zPattern[i]==zLog[j] ){
        j++;
      }else if( zPattern[i]=='#' && th3isdigit(zLog[j]) ){
        do{ j++; }while( th3isdigit(zLog[j]) );
      }else if( i>0 && zPattern[i-1]=='['
                && memcmp(&zPattern[i-1],"[SOURCEID]",10)==0
                && memcmp(&zLog[j], SQLITE_SOURCE_ID+20, 10)==0
                && zLog[j+10]==']' ){
        i += 8;
        j += 11;
      }else{
        break;
      }
    }
    c = zLog[j];
    if( c==0 || ((c=='"' || c==0x7d) && zLog[j+1]==0) ){
      th3testOk(p);
    }else{
      char *z;
      th3testFailed(p, 0);
      z = sqlite3_mprintf("%.*s", nPattern, zPattern);
      th3testShowResults(p, z, zLog);
      sqlite3_free(z);
    }
  }
}

/************************************************************************
** Here begins the declaration of a th3require() and th3coverage() routines
** used to verify that all critical paths through the test code are run.
** 
** Calls to th3require() identify the names of critical paths.  Calls
** to th3coverage() run when the path is followed.  Errors are raised if
** a path is identified by th3require() but never by th3coverage(), or
** if path identified by th3coverage() does not have a prior th3require().
*/

static struct {
  int nReq;            /* Number of requirements not yet covered */
  int nAlloc;          /* Space allocated for azReq */
  const char **az;     /* Names of requirements not yet covered */
} th3reqInfo = { 0, 0, 0 };

#define th3require(P,X)    {static const char *zReq=X; th3reqImp((P),&zReq);}
#define th3coverage(P,X)   {static const char *zReq=X; th3covImp((P),&zReq);}

/* If p is thread 0 and *pzReqname!=0, then record the fact that
** a test path named *pzReqname needs to be run at least once.
*/
void th3reqImp(th3state *p, const char **pzReqname){
  if( p->tid!=0 || (*pzReqname)==0 ) return;
  if( th3reqInfo.nReq<=th3reqInfo.nAlloc ){
    const char **az;
    th3reqInfo.nAlloc = th3reqInfo.nAlloc*2 + 10;
    az = th3mallocRaw( th3reqInfo.nAlloc * sizeof(az[0]) );
    if( az==0 ) th3panic("out of memory");
    if( th3reqInfo.az ){
      memcpy(az, th3reqInfo.az, th3reqInfo.nReq*sizeof(az[0]));
      th3freeRaw(th3reqInfo.az);
    }
    th3reqInfo.az = az;
  }
  th3reqInfo.az[th3reqInfo.nReq++] = *pzReqname;
  *pzReqname = 0;
}

/* If p is thread 0 and *pzReqname!=0, then record the fact that
** the test path named *pzReqname is now being run.  Raise an error
** if th3reqImp() has not previously been called for this test path.
*/
void th3covImp(th3state *p, const char **pzReqname){
  const char *zName;
  int i;
  if( p->tid!=0 || (*pzReqname)==0 ) return;
  zName = *pzReqname;
  *pzReqname = 0;
  for(i=0; i<th3reqInfo.nReq; i++){
    if( th3strcmp(zName, th3reqInfo.az[i])==0 ){
      th3reqInfo.az[i] = th3reqInfo.az[--th3reqInfo.nReq];
      return;
    }
  }
  th3print(p, " FAILED: th3coverage() without a prior th3require(): ");
  th3print(p, zName);
  th3print(p, "\n");
  p->nFail++;
}

/* Check to see if there are any test paths identified by th3reqImp()
** that have not been checked off by th3covImp().  Raise errors for
** each such unsatisified path.
*/
int th3verifyAllPathsCovered(th3state *p){
  int i;
  for(i=0; i<th3reqInfo.nReq; i++){
    th3print(p, " COVERAGE FAILED: never hit th3coverage(\"");
    th3print(p, th3reqInfo.az[i]);
    th3print(p, "\").\n");
  }
  return th3reqInfo.nReq;
}


/*****************************************************************************
** Generic authorizer functions
*/
/*
** This table maps authorizer action codes for the sqlite3_set_authorizer()
** interface into symbolic names for those action codes.
*/
static const struct {
  int authCode;
  const char *zName;
} th3authCode[] = {
  { SQLITE_CREATE_INDEX,           "SQLITE_CREATE_INDEX"          },
  { SQLITE_CREATE_TABLE,           "SQLITE_CREATE_TABLE"          },
  { SQLITE_CREATE_TEMP_INDEX,      "SQLITE_CREATE_TEMP_INDEX"     },
  { SQLITE_CREATE_TEMP_TABLE,      "SQLITE_CREATE_TEMP_TABLE"     },
  { SQLITE_CREATE_TEMP_TRIGGER,    "SQLITE_CREATE_TEMP_TRIGGER"   },
  { SQLITE_CREATE_TEMP_VIEW,       "SQLITE_CREATE_TEMP_VIEW"      },
  { SQLITE_CREATE_TRIGGER,         "SQLITE_CREATE_TRIGGER"        },
  { SQLITE_CREATE_VIEW,            "SQLITE_CREATE_VIEW"           },
  { SQLITE_DELETE,                 "SQLITE_DELETE"                },
  { SQLITE_DROP_INDEX,             "SQLITE_DROP_INDEX"            },
  { SQLITE_DROP_TABLE,             "SQLITE_DROP_TABLE"            },
  { SQLITE_DROP_TEMP_INDEX,        "SQLITE_DROP_TEMP_INDEX"       },
  { SQLITE_DROP_TEMP_TABLE,        "SQLITE_DROP_TEMP_TABLE"       },
  { SQLITE_DROP_TEMP_TRIGGER,      "SQLITE_DROP_TEMP_TRIGGER"     },
  { SQLITE_DROP_TEMP_VIEW,         "SQLITE_DROP_TEMP_VIEW"        },
  { SQLITE_DROP_TRIGGER,           "SQLITE_DROP_TRIGGER"          },
  { SQLITE_DROP_VIEW,              "SQLITE_DROP_VIEW"             },
  { SQLITE_INSERT,                 "SQLITE_INSERT"                },
  { SQLITE_PRAGMA,                 "SQLITE_PRAGMA"                },
  { SQLITE_READ,                   "SQLITE_READ"                  },
  { SQLITE_SELECT,                 "SQLITE_SELECT"                },
  { SQLITE_TRANSACTION,            "SQLITE_TRANSACTION"           },
  { SQLITE_UPDATE,                 "SQLITE_UPDATE"                },
  { SQLITE_ATTACH,                 "SQLITE_ATTACH"                },
  { SQLITE_DETACH,                 "SQLITE_DETACH"                },
  { SQLITE_ALTER_TABLE,            "SQLITE_ALTER_TABLE"           },
  { SQLITE_REINDEX,                "SQLITE_REINDEX"               },
  { SQLITE_ANALYZE,                "SQLITE_ANALYZE"               },
  { SQLITE_CREATE_VTABLE,          "SQLITE_CREATE_VTABLE"         },
  { SQLITE_DROP_VTABLE,            "SQLITE_DROP_VTABLE"           },
  { SQLITE_FUNCTION,               "SQLITE_FUNCTION"              },
  { SQLITE_SAVEPOINT,              "SQLITE_SAVEPOINT"             },
  { SQLITE_COPY,                   "SQLITE_COPY"                  },
};

/* This authorizer function allows everything.  But it also records
** each authorization request in a separate database in a table with
** the following schema:
**
**      CREATE TABLE authlog(authCode, zArg1, zArg2, zArg3, zArg4);
**
** Errors in writing to the authlog table are silently ignored.
*/
static int th3_auth_log(
  void *pArg,            /* Really, the database into which to log requests */
  int authCode,          /* The action code */
  const char *zArg1,     /* 1st argument */
  const char *zArg2,     /* 2nd argument */
  const char *zArg3,     /* 3rd argument */
  const char *zArg4      /* 4th argument */
){
  th3db *pDb = (th3db*)pArg;
  sqlite3_stmt *pStmt;
  int rc;
  int i;
  for(i=0; i<COUNT(th3authCode); i++){
    if( th3authCode[i].authCode==authCode ) break;
  }
  /* EVIDENCE-OF: R-56518-44310 The second parameter to the callback is an
  ** integer action code that specifies the particular action to be
  ** authorized. */
  assert( i<COUNT(th3authCode) );
  th3oomInternalDisable(1);
  rc = sqlite3_prepare_v2(pDb->db, "INSERT INTO authlog VALUES(?1,?2,?3,?4,?5)",
                          -1, &pStmt, 0);
  if( rc==SQLITE_OK ){
    sqlite3_bind_text(pStmt, 1, th3authCode[i].zName, -1, SQLITE_STATIC);
    sqlite3_bind_text(pStmt, 2, zArg1, -1, SQLITE_STATIC);
    sqlite3_bind_text(pStmt, 3, zArg2, -1, SQLITE_STATIC);
    sqlite3_bind_text(pStmt, 4, zArg3, -1, SQLITE_STATIC);
    sqlite3_bind_text(pStmt, 5, zArg4, -1, SQLITE_STATIC);
    sqlite3_step(pStmt);
  }else{
    th3testAppendResultTerm(pDb->p, "auth-log:");
    th3testAppendResult(pDb->p, th3errorCodeName(rc));
    th3testAppendResultTerm(pDb->p, sqlite3_errmsg(pDb->db));
    sqlite3_set_authorizer(pDb->db, 0, 0);
  }
  sqlite3_finalize(pStmt);
  th3oomInternalDisable(0);
  return SQLITE_OK;
}

/* This authorizer function checks a table in a separate database to
** see whether or not the operation is allowed.  The separate database
** should have a table of this form:
**
**     CREATE TABLE authcheck(res, authCode, zArg1, zArg2, zArg3, zArg4);
**
** All elements of the authcheck table should be strings.  authcheck.res is the
** return code and should be 'SQLITE_OK', 'SQLITE_DENY', or 'SQLITE_IGNORE'.
** The string is automatically translated into an appropriate integer.
** Any other string is translated into SQLITE_ERROR.
**
** authcheck.authCode is a string which must exactly match the symbolic
** name of the integer authCode parameter.
**
** authcheck.zArgN (for N in 1 through 4) must match the corresponding
** authorizer parameter.  NULL matches NULL.  But if authcheck.zArgN is
** the string '*' then it will match anything, including a NULL.
**
** The res of the first matching entry is returned.  If there are no
** matches then SQLITE_OK is returned.
**
** Any error in constructing or running the query causes SQLITE_ERROR
** to be returned.
*/
static int th3_auth_check(
  void *pArg,            /* Really, the database into which to log requests */
  int authCode,          /* The action code */
  const char *zArg1,     /* 1st argument */
  const char *zArg2,     /* 2nd argument */
  const char *zArg3,     /* 3rd argument */
  const char *zArg4      /* 4th argument */
){
  th3db *pDb = (th3db*)pArg;
  sqlite3_stmt *pStmt;
  int rc;
  int res;
  int i;
  
  for(i=0; i<COUNT(th3authCode); i++){
    if( th3authCode[i].authCode==authCode ) break;
  }
  if( i>=COUNT(th3authCode) ){
    return SQLITE_INTERNAL;
  }
  th3oomInternalDisable(1);
  rc = sqlite3_prepare_v2(pDb->db, 
     "SELECT res FROM authcheck"
     " WHERE authCode=?1"
     "   AND (zArg1==0 OR nullif(?2,zArg1) IS NULL)"
     "   AND (zArg2==0 OR nullif(?3,zArg2) IS NULL)"
     "   AND (zArg3==0 OR nullif(?4,zArg3) IS NULL)"
     "   AND (zArg4==0 OR nullif(?5,zArg4) IS NULL)",
     -1, &pStmt, 0
  );
  if( rc ){
    const char *th3errorCodeName(int);
    th3testAppendResultTerm(pDb->p, "auth-check:");
    th3testAppendResult(pDb->p, th3errorCodeName(rc));
    th3testAppendResultTerm(pDb->p, sqlite3_errmsg(pDb->db));
    sqlite3_set_authorizer(pDb->db, 0, 0);
    sqlite3_finalize(pStmt);
    th3oomInternalDisable(0);
    return SQLITE_ERROR;
  }
  sqlite3_bind_text(pStmt, 1, th3authCode[i].zName, -1, SQLITE_STATIC);
  sqlite3_bind_text(pStmt, 2, zArg1, -1, SQLITE_STATIC);
  sqlite3_bind_text(pStmt, 3, zArg2, -1, SQLITE_STATIC);
  sqlite3_bind_text(pStmt, 4, zArg3, -1, SQLITE_STATIC);
  sqlite3_bind_text(pStmt, 5, zArg4, -1, SQLITE_STATIC);
  rc = sqlite3_step(pStmt);
  res = SQLITE_OK;
  if( rc==SQLITE_ROW ){
    const char *zRes = (char*)sqlite3_column_text(pStmt, 0);
    if( zRes==0 ){
      res = -1;
    }else if( th3strcmp(zRes, "SQLITE_OK")==0 ){
      res = SQLITE_OK;
    }else if( th3strcmp(zRes, "SQLITE_DENY")==0 ){
      res = SQLITE_DENY;
    }else if( th3strcmp(zRes, "SQLITE_IGNORE")==0 ){
      res = SQLITE_IGNORE;
    }else{
      res = -1;
    }
  }
  sqlite3_finalize(pStmt);
  th3oomInternalDisable(0);
  return res;
}

/****************************************************************************
** Storing and clearing varibles that are automatically bound.  This is
** the BVS store.
*/

/*
** Release memory associated with a single th3var object.
*/
static void th3varRelease(th3state *p, th3var *pVar){
  if( pVar->zName ){
    switch( pVar->eType ){
      case TH3_BIND_BLOB:
      case TH3_BIND_TEXT:
      case TH3_BIND_TEXT16: {
        th3free(p, pVar->u.b.z);
        pVar->u.b.z = 0;
        break;
      }
    }
    th3free(p, pVar->zName);
    pVar->zName = 0;
    pVar->eType = TH3_BIND_NULL;
  }
}

/*
** Clear all binding variables from a th3state object.
*/
void th3bindReset(th3state *p){
  int i;
  for(i=0; i<TH3_N_BVS; i++){
    th3varRelease(p, &p->aVar[i]);
  }
}

/*
** Set the name of a particular variable slot.
*/
static void th3varSetName(th3state *p, th3var *pVar, const char *zName){
  int n;
  assert( pVar->zName==0 );
  n = strlen(zName);
  pVar->zName = th3malloc(p, n+1 );
  th3memcpy(pVar->zName, zName, n+1);
  pVar->eType = TH3_BIND_NULL;
}

/*
** Find a free slot in which to write a new binding value.  Clear the
** value of this slot so that it is ready to accept a new value.
**
** If all slots are already filled, panic.
*/
static th3var *th3varFindSlot(th3state *p, const char *zName){
  int i;
  int j = -1;
  th3var *pVar;
  for(i=0; i<TH3_N_BVS; i++){
    if( p->aVar[i].zName ){
      if( th3strcmp(p->aVar[i].zName,zName)==0 ) break;
    }else if( j<0 ){
      j = i;
    }
  }
  if( i>=TH3_N_BVS && j>=0 ){
    i = j;
  }
  pVar = &p->aVar[i];
  if( i==TH3_N_BVS ){
    th3panic("too many bind variables");
  }else{
    th3varRelease(p, pVar);
  }
  th3varSetName(p, pVar, zName);
  return pVar;
}

/*
** Return the value of a variable as a string.  If the variable does
** not exist or is not a UTF8 string, return the default.
*/
const char *th3valueText(th3state *p, const char *zName, const char *zDefault){
  int i;
  th3var *pVar;
  for(i=0; i<TH3_N_BVS; i++){
    pVar = &p->aVar[i];
    if( pVar->zName && th3strcmp(pVar->zName,zName)==0 ){
      if( pVar->eType==TH3_BIND_TEXT ) return pVar->u.b.z;
      break;
    }
  }
  return zDefault;
}

/*
** Return the value of a variable as an integer.  If the variable is
** a string, convert it.  If it is not a string or integer or if it
** does not exist, return the default.
*/
sqlite3_int64 th3valueInt64(
  th3state *p,           /* The testing context */
  const char *zName,     /* Name of the variable */
  sqlite3_int64 iDflt    /* Default value */
){
  int i;
  th3var *pVar;
  for(i=0; i<TH3_N_BVS; i++){
    pVar = &p->aVar[i];
    if( pVar->zName && th3strcmp(pVar->zName,zName)==0 ){
      if( pVar->eType==TH3_BIND_INT || pVar->eType==TH3_BIND_INT64 ){
        return pVar->u.i;
      }else if( pVar->eType==TH3_BIND_TEXT ){
        return th3atoi64(pVar->u.b.z);
      }
      break;
    }
  }
  return iDflt;
}


/*
** Add a string or text binding variable.
*/
static int th3varAddBlob(
  th3state *p,           /* Add the binding to this th3state object */
  const char *zName,     /* Name of the binding */
  int eType,             /* The specific binding type */
  const char *pVal,      /* The content */
  int nVal               /* Number of bytes of content */
){
  th3var *pVar = th3varFindSlot(p, zName);
  pVar->eType = eType;
  pVar->u.b.z = th3malloc(p, nVal);
  th3memcpy(pVar->u.b.z, pVal, nVal);
  pVar->u.b.n = nVal;
  return pVar - p->aVar;
}

/*
** Return the length, in bytes, of a zero-terminated UTF16 string.
** The length does not include the 0x0000 terminator.
*/
int th3strlen16(const char *z){
  int n = 0;
  while( z[0] || z[1] ){ z += 2; n += 2; }
  return n;
}

/*
** Here are the interfaces that test modules use to bind parameters:
*/
int th3bindBlob(th3state *p, const char *zName, const char *zVal, int nByte){
  int rowid;
  if( zVal ){
    rowid = th3varAddBlob(p, zName, TH3_BIND_BLOB, zVal, nByte);
  }else{
    rowid = th3varFindSlot(p, zName) - p->aVar;
  }
  return rowid;
}
int th3bindDouble(th3state *p, const char *zName, double val){
  th3var *pVar = th3varFindSlot(p, zName);
  pVar->eType = TH3_BIND_DOUBLE;
  pVar->u.r = val;
  return pVar - p->aVar;
}
int th3bindInt(th3state *p, const char *zName, int val){
  th3var *pVar = th3varFindSlot(p, zName);
  pVar->eType = TH3_BIND_INT;
  pVar->u.i = val;
  return pVar - p->aVar;
}
int th3bindInt64(th3state *p, const char *zName, sqlite3_int64 val){
  th3var *pVar = th3varFindSlot(p, zName);
  pVar->eType = TH3_BIND_INT64;
  pVar->u.i = val;
  return pVar - p->aVar;
}
int th3bindNull(th3state *p, const char *zName){
  return th3varFindSlot(p, zName) - p->aVar;
}
int th3bindText(th3state *p, const char *zName, const char *zVal){
  int rowid;
  if( zVal ){
    rowid = th3varAddBlob(p, zName, TH3_BIND_TEXT, zVal, strlen(zVal)+1);
  }else{
    rowid = th3varFindSlot(p, zName) - p->aVar;
  }
  return rowid;
}
int th3bindText16(th3state *p, const char *zName, const char *zVal){
  int rowid;
  if( zVal ){
    rowid = th3varAddBlob(p, zName, TH3_BIND_TEXT16, zVal, th3strlen16(zVal)+2);
  }else{
    rowid = th3varFindSlot(p, zName) - p->aVar;
  }
  return rowid;
}
int th3bindZeroblob(th3state *p, const char *zName, int nByte){
  th3var *pVar = th3varFindSlot(p, zName);
  pVar->eType = TH3_BIND_ZEROBLOB;
  pVar->u.b.n = nByte;
  return pVar - p->aVar;
}
int th3bindValue(th3state *p, const char *zName, sqlite3_value *pValue){
  int rowid = 0;
  switch( sqlite3_value_type(pValue) ){
    case SQLITE_NULL: {
      rowid = th3bindNull(p, zName);
      break;
    }
    case SQLITE_INTEGER: {
      sqlite3_int64 i64 = sqlite3_value_int64(pValue);
      int i = (int)i64;
      if( i64==(sqlite3_int64)i ){
        rowid = th3bindInt(p, zName, i);
      }else{
        rowid = th3bindInt64(p, zName, i64);
      }
      break;
    }
    case SQLITE_FLOAT: {
      rowid = th3bindDouble(p, zName, sqlite3_value_double(pValue));
      break;
    }
    case SQLITE_TEXT: {
      rowid = th3bindText(p, zName, (char*)sqlite3_value_text(pValue));
      break;
    }
    case SQLITE_BLOB: {
      int i;
      int nBlob = sqlite3_value_bytes(pValue);
      char *pBlob = (char*)sqlite3_value_blob(pValue);
      for(i=0; i<nBlob || pBlob[i]!=0; i++){}
      if( i<nBlob ){
        rowid = th3bindBlob(p, zName, pBlob, nBlob);
      }else{
        rowid = th3bindZeroblob(p, zName, nBlob);
      }
      break;
    }
  }
  return rowid;
}

/*****************************************************************************
** Here are the implementations of the methods of the bind-variable-store (BVS)
** virtual table.  The declarations for all these methods, and the definition of
** the sqlite3_module object that defines the virtual table are all given
** above.
*/

/*
** Connect to a th3state bind variable store.
**
** If the CREATE VIRTUAL TABLE supplied one or more arguments to the
** end of the module name, then append all arguments in argv[] (including
** the first three default arguments) to the output of the th3state.
*/
static int th3bvsvtabConnect(
  sqlite3 *db,                /* The database connection */
  void *pAux,                 /* Pointer to the th3state object */
  int argc,                   /* Number of arguments */
  const char *const*argv,     /* Text of the arguments */
  sqlite3_vtab **ppVTab,      /* Write the new vtab here */
  char **pzErr                /* Error message written here */
){
  th3state *p = (th3state*)pAux;
  th3bvsvtab *pVtab;
  int rc;
  int i;
  static const char zDefaultSchema[] = 
    "CREATE TABLE x(name TEXT, value, eType HIDDEN, iExtra HIDDEN)";

  pVtab = sqlite3_malloc( sizeof(*pVtab) );
  if( pVtab==0 ){
    *pzErr = sqlite3_mprintf("out of memory");
    return SQLITE_NOMEM;
  }
  th3memset(pVtab, 0, sizeof(*pVtab));
  pVtab->p = p;
  rc = sqlite3_declare_vtab(db, zDefaultSchema);
  if( rc ){
    sqlite3_free(pVtab);
  }else{
    *ppVTab = &pVtab->parent;
  }
  if( argc>3 ){
    for(i=0; i<argc; i++){
      th3testAppendResultTerm(p, argv[i]);
    }
  }
  return rc;
}

/* Find the best index to use for doing a query against the BVS.
** In this very simple implementation, we only do a full table scan.
**
** For testing purposes estimate cost with an equalty constraint at 1.
** Otherwise the cost is 1000.  In reality, both are the same cost.  But
** we want the query optimizer to think that equality constraints are
** good.
*/
static int th3bvsvtabBestIndex(sqlite3_vtab *pVTab, sqlite3_index_info *pInfo){
  int i;
  int n = 0;
  pInfo->estimatedCost = (double)100;
  for(i=0; i<pInfo->nConstraint; i++){
    if( pInfo->aConstraint[i].usable
      && pInfo->aConstraint[i].op==SQLITE_INDEX_CONSTRAINT_EQ ){
      pInfo->estimatedCost = (double)1;
      pInfo->aConstraintUsage[i].argvIndex = ++n;
    }
  }
  return SQLITE_OK;
}

/* Disconnect from the BVS.
*/
static int th3bvsvtabDisconnect(sqlite3_vtab *pVTab){
  sqlite3_free(pVTab);
  return SQLITE_OK;
}

/* Open a cursor for scanning the BVS.
*/
static int th3bvsvtabOpen(sqlite3_vtab *pVTab, sqlite3_vtab_cursor **ppCursor){
  th3bvsvtabCursor *pCur;
  pCur = sqlite3_malloc( sizeof(*pCur) );
  if( pCur==0 ){
    pVTab->zErrMsg = sqlite3_mprintf("out of memory");
    return SQLITE_NOMEM;
  }
  *ppCursor = &pCur->parent;
  pCur->i = -1;
  return SQLITE_OK;
}

/* Close a cursor
*/
static int th3bvsvtabClose(sqlite3_vtab_cursor *pCur){
  th3bvsvtabCursor *pBvsCur = (th3bvsvtabCursor*)pCur;
  sqlite3_free(pBvsCur);
  return SQLITE_OK;
}

/* Advance the cursor to the next entry in the BVS.
*/

/* The following function using pointer assignments
** that appear to confuse the MSVC compiler when 
** optimizations are enabled, so we disable them
** for now.
** http://msdn.microsoft.com/en-us/library/aa984741%28VS.71%29.aspx
*/
#pragma optimize( "", off )

static int th3bvsvtabNext(sqlite3_vtab_cursor *pCur){
  th3bvsvtabCursor *pBvsCur = (th3bvsvtabCursor*)pCur;
  th3state *p = ((th3bvsvtab*)pCur->pVtab)->p;
  while( pBvsCur->i<TH3_N_BVS ){
    pBvsCur->i++;
    if( p->aVar[pBvsCur->i].zName ) break;
  }
  return SQLITE_OK;
}

#pragma optimize( "", on )

/* Rewind a cursor back to the beginning of the BVS.
*/
static int th3bvsvtabFilter(
  sqlite3_vtab_cursor *pCur,   /* The cursor to rewind */
  int idxNum,                   /* Not used */
  const char *idxStr,           /* Not used */
  int argc,                     /* Not used */
  sqlite3_value **argv          /* Not used */
){
  th3bvsvtabCursor *pBvsCur = (th3bvsvtabCursor*)pCur;
  pBvsCur->i = -1;
  th3bvsvtabNext(pCur);
  return SQLITE_OK;
}

/* Return TRUE if we are at the end of the BVS and there are
** no more entries.
*/
static int th3bvsvtabEof(sqlite3_vtab_cursor *pCur){
  th3bvsvtabCursor *pBvsCur = (th3bvsvtabCursor*)pCur;
  return pBvsCur->i<0 || pBvsCur->i>=TH3_N_BVS;
}

/* Return the Nth column of the current row.
*/
static int th3bvsvtabColumn(
  sqlite3_vtab_cursor *pCur,
  sqlite3_context *context,
  int N
){
  th3bvsvtabCursor *pBvsCur = (th3bvsvtabCursor*)pCur;
  th3state *p = ((th3bvsvtab*)pCur->pVtab)->p;
  th3var *pVar;
  if( pBvsCur->i < 0 || pBvsCur->i>=TH3_N_BVS || p->aVar[pBvsCur->i].zName==0 ){
    return SQLITE_OK;
  }
  pVar = &p->aVar[pBvsCur->i];
  if( N==0 ){
    sqlite3_result_text(context, pVar->zName, -1, SQLITE_TRANSIENT);
  }else if( N==1 ){
    switch( pVar->eType ){
      case TH3_BIND_BLOB: {
        sqlite3_result_blob(context, pVar->u.b.z, pVar->u.b.n,SQLITE_TRANSIENT);
        break;
      }
      case TH3_BIND_DOUBLE: {
        sqlite3_result_double(context, pVar->u.r);
        break;
      }
      case TH3_BIND_INT: {
        sqlite3_result_int(context, (int)pVar->u.i);
        break;
      }
      case TH3_BIND_INT64: {
        sqlite3_result_int64(context, pVar->u.i);
        break;
      }
      case TH3_BIND_NULL: {
        sqlite3_result_null(context);
        break;
      }
      case TH3_BIND_TEXT: {
        /* Assume that the BVS value will not change while the string is
        ** being used by SQLite.  This helps to exercise code paths associated
        ** with STATIC text.
        */
        sqlite3_result_text(context, pVar->u.b.z, -1, SQLITE_STATIC);
        break;
      }
      case TH3_BIND_TEXT16: {
        sqlite3_result_text16(context, pVar->u.b.z, -1, SQLITE_TRANSIENT);
        break;
      }
      case TH3_BIND_ZEROBLOB: {
        sqlite3_result_zeroblob(context, pVar->u.b.n);
        break;
      }
    }
  }else if( N==2 ){
    sqlite3_result_int(context, pVar->eType);
  }else if( N==3 ){
    sqlite3_result_int(context, pVar->iExtra);
  }
  return SQLITE_OK;
}

/* Return the rowid of the current row
*/
static int th3bvsvtabRowid(sqlite3_vtab_cursor *pCur, sqlite3_int64 *pRowid){
  th3bvsvtabCursor *pBvsCur = (th3bvsvtabCursor*)pCur;
  *pRowid = pBvsCur->i;
  return SQLITE_OK;
}

/*
** Process UPDATE, DELETE, and INSERT statements.
*/
static int th3bvsvtabUpdate(
  sqlite3_vtab *pVtab,
  int argc,
  sqlite3_value **argv,
  sqlite_int64 *pNewRowid
){
  th3state *p = ((th3bvsvtab*)pVtab)->p;
  int i, j;
  const char *zName;

  assert( argc==1 || argc==6 );

  /* Case 1:  DELETE a single row with rowid=argv[0]. */
  if( argc==1 ){
    i = sqlite3_value_int(argv[0]);
    if( i>=0 && i<TH3_N_BVS ){
      th3varRelease(p, &p->aVar[i]);
    }
    return SQLITE_OK;
  }

  /* Case 2: INSERT a row.  There is a UNIQUE constraint on name, so if
  ** the new row has the same name as a prior row, replace the content.
  */
  if( argc>1 && sqlite3_value_type(argv[0])==SQLITE_NULL ){
    zName = (char*)sqlite3_value_text(argv[2]);
    if( zName==0 || zName[0]==0 ){
      pVtab->zErrMsg = sqlite3_mprintf("name must be a non-empty string");
      return SQLITE_ERROR;
    }
    if( sqlite3_value_type(argv[1])!=SQLITE_NULL ){
      i = sqlite3_value_int(argv[1]);
      if( i<0 || i>=TH3_N_BVS ){
        pVtab->zErrMsg = sqlite3_mprintf("rowid out of range");
        return SQLITE_CONSTRAINT;
      }
      th3varRelease(p, &p->aVar[i]);
      th3varSetName(p, &p->aVar[i], zName);
    }else{
      j = -1;
      for(i=0; i<TH3_N_BVS; i++){
        if( p->aVar[i].zName ){
          if( th3strcmp(p->aVar[i].zName,zName)==0 ) break;
        }else if( j<0 ){
          j = i;
        }
      }
      if( i>=TH3_N_BVS && j>=0 ){
        i = j;
        if( i>=TH3_N_BVS ){
          return SQLITE_FULL;
        }
      }
      th3varRelease(p, &p->aVar[i]);
    }
    *pNewRowid = i = th3bindValue(p, zName, argv[3]);
    p->aVar[i].iExtra = sqlite3_value_int(argv[5]);
    return SQLITE_OK;
  }

  /* Case 3: UPDATE a specific row given by its rowid. */
  if( argc>1 && sqlite3_value_type(argv[0])!=SQLITE_NULL
      && sqlite3_value_type(argv[1])!=SQLITE_NULL ){
    if( sqlite3_value_int64(argv[0])!=sqlite3_value_int64(argv[1]) ){
      pVtab->zErrMsg = sqlite3_mprintf("cannot change the rowid");
      return SQLITE_ERROR;
    }
    i = sqlite3_value_int(argv[1]);
    if( i<0 || i>=TH3_N_BVS || p->aVar[i].zName==0 ){
      return SQLITE_OK;
    }
    zName = (char*)sqlite3_value_text(argv[2]);
    if( zName==0 || zName[0]==0 ){
      pVtab->zErrMsg = sqlite3_mprintf("name must be a non-empty string");
      return SQLITE_ERROR;
    }
    th3varRelease(p, &p->aVar[i]);
    th3varSetName(p, &p->aVar[i], zName);
    th3bindValue(p, zName, argv[3]);
    p->aVar[i].iExtra = sqlite3_value_int(argv[5]);
    return SQLITE_OK;
  }

  return SQLITE_INTERNAL;
}


/* Notify the BVS of a virtual table name change */
static int th3bvsvtabRename(sqlite3_vtab *pVtab, const char *zNew){
  return SQLITE_OK;  /* This implementation does not care. */
}

/*
** End of the th3state bind-variable-store (BVS) virtual table implementation
*****************************************************************************/

/* Forward references */
static void th3filesystemReset(th3vfsFSys *p);
static int th3filesystemCopy(th3vfsFSys *pTo, th3vfsFSys *pFrom);
static int th3oomStep(int);

/****************************************************************************
** Here begins a mutex implementation used for testing.  No actual
** mutual exclusion is provided, so this mutex implementation cannot
** be used in a multi-threaded test.
*/

/*
** The mutex object.
**
** The first integer field of the mutex structure is always set to the
** magic number defined below. This allows mutex methods to assert() that
** the opaque handle they are being passed really is a pointer to a
** valid th3mutex object.
*/
#define TH3_MUTEX_MAGIC 0x02d8ada0
typedef struct th3mutex th3mutex;
struct th3mutex {
  int magic;  /* Always set to TH3_MUTEX_MAGIC */
  int id;     /* The mutex type */
  int cnt;    /* Number of entries without a matching leave */
};

/*
** Global variables used to alter the behavior of the test mutex
** subsystem.
*/
static struct {
  int mutexInitReturn;     /* Return code from xMutexInit() */
  int callInitialize;      /* Have mutexInit invoke sqlite3_initialize() once */
  int enableMutexTry;      /* True to enable xMutexTry() */
} th3mutexGlobal = {
  SQLITE_OK,    /* mutexInitReturn */
  0,            /* callInitialize */
  1,            /* enableMutexTry */
};

/*
** The sqlite3_mutex_held() and sqlite3_mutex_notheld() routine are
** intended for use inside assert() statements.
*/
static int th3mutexHeld(sqlite3_mutex *pMutex){
  th3mutex *p = (th3mutex*)pMutex;
  return p==0 || p->cnt>0;
}
static int th3mutexNotheld(sqlite3_mutex *pMutex){
  th3mutex *p = (th3mutex*)pMutex;
  return p==0 || p->cnt==0;
}

/*
** Initialize and deinitialize the mutex subsystem.
*/
static int th3mutexInit(void){
  if( th3mutexGlobal.callInitialize){
    th3mutexGlobal.callInitialize = 0;
    sqlite3_initialize();
  }
  return th3mutexGlobal.mutexInitReturn;
}

/*
** The sqlite3_mutex_alloc() routine allocates a new
** mutex and returns a pointer to it.  If it returns NULL
** that means that a mutex could not be allocated. 
*/
static sqlite3_mutex *th3mutexAlloc(int id){
  static th3mutex aStatic[6];
  th3mutex *pNew = 0;
  switch( id ){
    case SQLITE_MUTEX_FAST:
    case SQLITE_MUTEX_RECURSIVE: {
      if( th3oomStep(2) ){
        pNew = 0;
        break;
      }
      pNew = th3mallocRaw(sizeof(*pNew));
      if( pNew ){
        pNew->id = id;
        pNew->cnt = 0;
      }
      break;
    }
    default: {
      assert( id-2 >= 0 );
      assert( id-2 < (int)COUNT(aStatic) );
      pNew = &aStatic[id-2];
      pNew->id = id;
      break;
    }
  }
  if( pNew ){
    pNew->magic = TH3_MUTEX_MAGIC;
  }
  return (sqlite3_mutex*)pNew;
}

/*
** This routine deallocates a previously allocated mutex.
*/
static void th3mutexFree(sqlite3_mutex *pMutex){
  th3mutex *p = (th3mutex*)pMutex;
  assert( p->magic==TH3_MUTEX_MAGIC );
  assert( p->cnt==0 );
  assert( p->id==SQLITE_MUTEX_FAST || p->id==SQLITE_MUTEX_RECURSIVE );
  th3freeRaw(p);
}

/*
** The sqlite3_mutex_enter() and sqlite3_mutex_try() routines attempt
** to enter a mutex.  If another thread is already within the mutex,
** sqlite3_mutex_enter() will block and sqlite3_mutex_try() will return
** SQLITE_BUSY.  The sqlite3_mutex_try() interface returns SQLITE_OK
** upon successful entry.  Mutexes created using SQLITE_MUTEX_RECURSIVE can
** be entered multiple times by the same thread.  In such cases the,
** mutex must be exited an equal number of times before another thread
** can enter.  If the same thread tries to enter any other kind of mutex
** more than once, the behavior is undefined.
*/
static void th3mutexEnter(sqlite3_mutex *pMutex){
  th3mutex *p = (th3mutex*)pMutex;
  assert( p->magic==TH3_MUTEX_MAGIC );
  assert( p->id==SQLITE_MUTEX_RECURSIVE || th3mutexNotheld(pMutex) );
  p->cnt++;
}
static int th3mutexTry(sqlite3_mutex *pMutex){
  th3mutex *p = (th3mutex*)pMutex;
  int rc;
  assert( p->magic==TH3_MUTEX_MAGIC );
  assert( p->id==SQLITE_MUTEX_RECURSIVE || th3mutexNotheld(pMutex) );
  if( th3mutexGlobal.enableMutexTry ){
    p->cnt++;
    rc = SQLITE_OK;
  }else{
    rc = SQLITE_BUSY;
  }
  return rc;
}

/*
** The sqlite3_mutex_leave() routine exits a mutex that was
** previously entered by the same thread.  The behavior
** is undefined if the mutex is not currently entered or
** is not currently allocated.  SQLite will never do either.
*/
static void th3mutexLeave(sqlite3_mutex *pMutex){
  th3mutex *p = (th3mutex*)pMutex;
  assert( th3mutexHeld(pMutex) );
  assert( p->magic==TH3_MUTEX_MAGIC );
  p->cnt--;
  assert( p->id==SQLITE_MUTEX_RECURSIVE || th3mutexNotheld(pMutex) );
}

/*
** The complete test mutex implementation is described by the
** following structure.  To enable the test mutex implementation
** use:
**
**     sqlite3_config(SQLITE_CONFIG_MUTEX, &th3mutexTestMethods)
*/
static const sqlite3_mutex_methods th3mutexTestMethods = {
  th3mutexInit,
  0,
  th3mutexAlloc,
  th3mutexFree,
  th3mutexEnter,
  th3mutexTry,
  th3mutexLeave,
  th3mutexHeld,
  th3mutexNotheld
};

/*
** This is a null mutex implemenation to set the mutex implementation
** back to the default, use:
**
**     sqlite3_config(SQLITE_CONFIG_MUTEX, &th3mutexNullMethods);
*/
static const sqlite3_mutex_methods th3mutexNullMethods = {
  0, 0, 0, 0, 0, 0, 0, 0, 0
};


/****************************************************************************/
/*
 * This code implements the MD5 message-digest algorithm.
 * The algorithm is due to Ron Rivest.  This code was
 * written by Colin Plumb in 1993, no copyright is claimed.
 * This code is in the public domain; do with it what you wish.
 *
 * Equivalent code is available from RSA Data Security, Inc.
 * This code has been tested against that, and is equivalent,
 * except that you don't need to include two pages of legalese
 * with every copy.
 *
 * To compute the message digest of a chunk of bytes, declare an
 * MD5Context structure, pass it to MD5Init, call MD5Update as
 * needed on buffers full of bytes, and then call MD5Final, which
 * will fill a supplied 16-byte array with the digest.
 */

/*
 * Note: this code is harmless on little-endian machines.
 */
static void byteReverse (unsigned char *buf, unsigned longs){
        u32 t;
        do {
                t = (u32)((unsigned)buf[3]<<8 | buf[2]) << 16 |
                            ((unsigned)buf[1]<<8 | buf[0]);
                *(u32 *)buf = t;
                buf += 4;
        } while (--longs);
}
/* The four core functions - F1 is optimized somewhat */

/* #define F1(x, y, z) (x & y | ~x & z) */
#define F1(x, y, z) (z ^ (x & (y ^ z)))
#define F2(x, y, z) F1(z, x, y)
#define F3(x, y, z) (x ^ y ^ z)
#define F4(x, y, z) (y ^ (x | ~z))

/* This is the central step in the MD5 algorithm. */
#define MD5STEP(f, w, x, y, z, data, s) ( w += f(x, y, z) + data,  w = w<<s | w>>(32-s),  w += x )

/*
 * The core of the MD5 algorithm, this alters an existing MD5 hash to
 * reflect the addition of 16 longwords of new data.  MD5Update blocks
 * the data and converts bytes into longwords for this routine.
 */
static void md5Transform(u32 buf[4], const u32 in[16]){
        register u32 a, b, c, d;

        a = buf[0];
        b = buf[1];
        c = buf[2];
        d = buf[3];

        MD5STEP(F1, a, b, c, d, in[ 0]+0xd76aa478,  7);
        MD5STEP(F1, d, a, b, c, in[ 1]+0xe8c7b756, 12);
        MD5STEP(F1, c, d, a, b, in[ 2]+0x242070db, 17);
        MD5STEP(F1, b, c, d, a, in[ 3]+0xc1bdceee, 22);
        MD5STEP(F1, a, b, c, d, in[ 4]+0xf57c0faf,  7);
        MD5STEP(F1, d, a, b, c, in[ 5]+0x4787c62a, 12);
        MD5STEP(F1, c, d, a, b, in[ 6]+0xa8304613, 17);
        MD5STEP(F1, b, c, d, a, in[ 7]+0xfd469501, 22);
        MD5STEP(F1, a, b, c, d, in[ 8]+0x698098d8,  7);
        MD5STEP(F1, d, a, b, c, in[ 9]+0x8b44f7af, 12);
        MD5STEP(F1, c, d, a, b, in[10]+0xffff5bb1, 17);
        MD5STEP(F1, b, c, d, a, in[11]+0x895cd7be, 22);
        MD5STEP(F1, a, b, c, d, in[12]+0x6b901122,  7);
        MD5STEP(F1, d, a, b, c, in[13]+0xfd987193, 12);
        MD5STEP(F1, c, d, a, b, in[14]+0xa679438e, 17);
        MD5STEP(F1, b, c, d, a, in[15]+0x49b40821, 22);

        MD5STEP(F2, a, b, c, d, in[ 1]+0xf61e2562,  5);
        MD5STEP(F2, d, a, b, c, in[ 6]+0xc040b340,  9);
        MD5STEP(F2, c, d, a, b, in[11]+0x265e5a51, 14);
        MD5STEP(F2, b, c, d, a, in[ 0]+0xe9b6c7aa, 20);
        MD5STEP(F2, a, b, c, d, in[ 5]+0xd62f105d,  5);
        MD5STEP(F2, d, a, b, c, in[10]+0x02441453,  9);
        MD5STEP(F2, c, d, a, b, in[15]+0xd8a1e681, 14);
        MD5STEP(F2, b, c, d, a, in[ 4]+0xe7d3fbc8, 20);
        MD5STEP(F2, a, b, c, d, in[ 9]+0x21e1cde6,  5);
        MD5STEP(F2, d, a, b, c, in[14]+0xc33707d6,  9);
        MD5STEP(F2, c, d, a, b, in[ 3]+0xf4d50d87, 14);
        MD5STEP(F2, b, c, d, a, in[ 8]+0x455a14ed, 20);
        MD5STEP(F2, a, b, c, d, in[13]+0xa9e3e905,  5);
        MD5STEP(F2, d, a, b, c, in[ 2]+0xfcefa3f8,  9);
        MD5STEP(F2, c, d, a, b, in[ 7]+0x676f02d9, 14);
        MD5STEP(F2, b, c, d, a, in[12]+0x8d2a4c8a, 20);

        MD5STEP(F3, a, b, c, d, in[ 5]+0xfffa3942,  4);
        MD5STEP(F3, d, a, b, c, in[ 8]+0x8771f681, 11);
        MD5STEP(F3, c, d, a, b, in[11]+0x6d9d6122, 16);
        MD5STEP(F3, b, c, d, a, in[14]+0xfde5380c, 23);
        MD5STEP(F3, a, b, c, d, in[ 1]+0xa4beea44,  4);
        MD5STEP(F3, d, a, b, c, in[ 4]+0x4bdecfa9, 11);
        MD5STEP(F3, c, d, a, b, in[ 7]+0xf6bb4b60, 16);
        MD5STEP(F3, b, c, d, a, in[10]+0xbebfbc70, 23);
        MD5STEP(F3, a, b, c, d, in[13]+0x289b7ec6,  4);
        MD5STEP(F3, d, a, b, c, in[ 0]+0xeaa127fa, 11);
        MD5STEP(F3, c, d, a, b, in[ 3]+0xd4ef3085, 16);
        MD5STEP(F3, b, c, d, a, in[ 6]+0x04881d05, 23);
        MD5STEP(F3, a, b, c, d, in[ 9]+0xd9d4d039,  4);
        MD5STEP(F3, d, a, b, c, in[12]+0xe6db99e5, 11);
        MD5STEP(F3, c, d, a, b, in[15]+0x1fa27cf8, 16);
        MD5STEP(F3, b, c, d, a, in[ 2]+0xc4ac5665, 23);

        MD5STEP(F4, a, b, c, d, in[ 0]+0xf4292244,  6);
        MD5STEP(F4, d, a, b, c, in[ 7]+0x432aff97, 10);
        MD5STEP(F4, c, d, a, b, in[14]+0xab9423a7, 15);
        MD5STEP(F4, b, c, d, a, in[ 5]+0xfc93a039, 21);
        MD5STEP(F4, a, b, c, d, in[12]+0x655b59c3,  6);
        MD5STEP(F4, d, a, b, c, in[ 3]+0x8f0ccc92, 10);
        MD5STEP(F4, c, d, a, b, in[10]+0xffeff47d, 15);
        MD5STEP(F4, b, c, d, a, in[ 1]+0x85845dd1, 21);
        MD5STEP(F4, a, b, c, d, in[ 8]+0x6fa87e4f,  6);
        MD5STEP(F4, d, a, b, c, in[15]+0xfe2ce6e0, 10);
        MD5STEP(F4, c, d, a, b, in[ 6]+0xa3014314, 15);
        MD5STEP(F4, b, c, d, a, in[13]+0x4e0811a1, 21);
        MD5STEP(F4, a, b, c, d, in[ 4]+0xf7537e82,  6);
        MD5STEP(F4, d, a, b, c, in[11]+0xbd3af235, 10);
        MD5STEP(F4, c, d, a, b, in[ 2]+0x2ad7d2bb, 15);
        MD5STEP(F4, b, c, d, a, in[ 9]+0xeb86d391, 21);

        buf[0] += a;
        buf[1] += b;
        buf[2] += c;
        buf[3] += d;
}

/*
 * Start MD5 accumulation.  Set bit count to 0 and buffer to mysterious
 * initialization constants.
 */
static void md5Init(md5Context *ctx){
        ctx->isInit = 1;
        ctx->buf[0] = 0x67452301;
        ctx->buf[1] = 0xefcdab89;
        ctx->buf[2] = 0x98badcfe;
        ctx->buf[3] = 0x10325476;
        ctx->bits[0] = 0;
        ctx->bits[1] = 0;
}

/*
 * Update context to reflect the concatenation of another buffer full
 * of bytes.
 */
static 
void md5Update(md5Context *ctx, const unsigned char *buf, unsigned int len){
        u32 t;

        /* Update bitcount */

        t = ctx->bits[0];
        if ((ctx->bits[0] = t + ((u32)len << 3)) < t)
                ctx->bits[1]++; /* Carry from low to high */
        ctx->bits[1] += len >> 29;

        t = (t >> 3) & 0x3f;    /* Bytes already in shsInfo->data */

        /* Handle any leading odd-sized chunks */

        if ( t ) {
                unsigned char *p = (unsigned char *)ctx->in + t;

                t = 64-t;
                if (len < t) {
                        th3memcpy(p, buf, len);
                        return;
                }
                th3memcpy(p, buf, t);
                byteReverse(ctx->in, 16);
                md5Transform(ctx->buf, (u32 *)ctx->in);
                buf += t;
                len -= t;
        }

        /* Process data in 64-byte chunks */

        while (len >= 64) {
                th3memcpy(ctx->in, buf, 64);
                byteReverse(ctx->in, 16);
                md5Transform(ctx->buf, (u32 *)ctx->in);
                buf += 64;
                len -= 64;
        }

        /* Handle any remaining bytes of data. */

        th3memcpy(ctx->in, buf, len);
}

/*
 * Final wrapup - pad to 64-byte boundary with the bit pattern 
 * 1 0* (64-bit count of bits processed, MSB-first)
 */
static void md5Final(unsigned char digest[16], md5Context *ctx){
        unsigned count;
        unsigned char *p;

        /* Compute number of bytes mod 64 */
        count = (ctx->bits[0] >> 3) & 0x3F;

        /* Set the first char of padding to 0x80.  This is safe since there is
           always at least one byte free */
        p = ctx->in + count;
        *p++ = 0x80;

        /* Bytes of padding needed to make 64 bytes */
        count = 64 - 1 - count;

        /* Pad out to 56 mod 64 */
        if (count < 8) {
                /* Two lots of padding:  Pad the first block to 64 bytes */
                th3memset(p, 0, count);
                byteReverse(ctx->in, 16);
                md5Transform(ctx->buf, (u32 *)ctx->in);

                /* Now fill the next block with 56 bytes */
                th3memset(ctx->in, 0, 56);
        } else {
                /* Pad block to 56 bytes */
                th3memset(p, 0, count-8);
        }
        byteReverse(ctx->in, 14);

        /* Append length in bits and transform */
        ((u32 *)ctx->in)[ 14 ] = ctx->bits[0];
        ((u32 *)ctx->in)[ 15 ] = ctx->bits[1];

        md5Transform(ctx->buf, (u32 *)ctx->in);
        byteReverse((unsigned char *)ctx->buf, 4);
        th3memcpy(digest, ctx->buf, 16);
        th3memset(ctx, 0, sizeof(ctx[0]));    /* In case it is sensitive */
}

/*
** Convert a digest into base-16.  digest should be declared as
** "unsigned char digest[16]" in the calling function.  The MD5
** digest is stored in the first 16 bytes.  zBuf should
** be "char zBuf[33]".
*/
static void md5DigestToBase16(unsigned char *digest, char *zBuf){
  static char const zEncode[] = "0123456789abcdef";
  int i, j;

  for(j=i=0; i<16; i++){
    int a = digest[i];
    zBuf[j++] = zEncode[(a>>4)&0xf];
    zBuf[j++] = zEncode[a & 0xf];
  }
  zBuf[j] = 0;
}

/*
** During testing, the special md5sum() aggregate function is available.
** inside SQLite.  The following routines implement that function.
*/
static void md5step(sqlite3_context *context, int argc, sqlite3_value **argv){
  md5Context *p;
  int i;
  if( argc<1 ) return;
  p = sqlite3_aggregate_context(context, sizeof(*p));
  if( p==0 ) return;
  if( !p->isInit ){
    md5Init(p);
  }
  for(i=0; i<argc; i++){
    const char *zData = (char*)sqlite3_value_text(argv[i]);
    if( zData ){
      md5Update(p, (unsigned char*)zData, strlen(zData));
    }
  }
}
static void md5finalize(sqlite3_context *context){
  md5Context *p;
  unsigned char digest[16];
  char zBuf[33];
  p = sqlite3_aggregate_context(context, sizeof(*p));
  if( p ){
    md5Final(digest,p);
    md5DigestToBase16(digest, zBuf);
    sqlite3_result_text(context, zBuf, -1, SQLITE_TRANSIENT);
  }
}
int Md5_Register(sqlite3 *db){
  int rc = sqlite3_create_function(db, "md5sum", -1, SQLITE_UTF8, 0, 0, 
                                 md5step, md5finalize);
  return rc;
}

/*
** Each test state has a single MD5 checksum generator.  Uses the
** following routines to initialize the generator, add test, and
** extract a lower-case hexadecimal rendering.
*/
void th3md5Init(th3state *p){
   md5Init(&p->md5);
}
void th3md5Step(th3state *p, const unsigned char *pBuf, int nBuf){
   md5Update(&p->md5, pBuf, nBuf);
}
char *th3md5Finish(th3state *p){
  if( p->md5.isInit ){
    unsigned char digest[16];
    md5Final(digest, &p->md5);
    md5DigestToBase16(digest, p->zMd5);
  }
  return p->zMd5; 
}
/****************************************************************************/
/*
** Simulated extensions.
*/

/*
** A function to translate a string into HEX.  The user-data determines
** if the string is interpreted as UTF8, UTF16LE, or UTF16bBE.  This
** implements utf8_to_hex(), utf16le_to_hex(), and utf16be_to_hex().
*/
static void th3_utf_to_hex(
  sqlite3_context *context,
  int argc,
  sqlite3_value **argv
){
  const char *zType = (char*)sqlite3_user_data(context);
  const char *zData;
  int nData;
  int i;
  char *zOut;

  if( zType[0]=='8' ){
    nData = sqlite3_value_bytes(argv[0]);
    zData = (const char*)sqlite3_value_text(argv[0]);
  }else if( zType[0]=='l' ){
    nData = sqlite3_value_bytes16(argv[0]);
    zData = (const char*)sqlite3_value_text16le(argv[0]);
  }else{
    nData = sqlite3_value_bytes16(argv[0]);
    zData = (const char*)sqlite3_value_text16be(argv[0]);
  }
  zOut = sqlite3_malloc( nData*2 + 1 );
  if( zOut==0 ){
    sqlite3_result_error_nomem(context);
    return;
  }
  for(i=0; i<nData; i++){
    zOut[i*2] = "0123456789abcdef"[(zData[i]>>4)&0xf];
    zOut[i*2+1] = "0123456789abcdef"[zData[i]&0xf];
  }
  zOut[i*2] = 0;
  sqlite3_result_text(context, zOut, i*2, sqlite3_free);
}

/*
** Extract a single byte of hex (two hex digits) from string *pz which
** is *pn bytes in length.   Update *pz and *pn to point to the character
** beyond the byte extracted.
**
** Return TRUE if a full byte was extracted and FALSE if not.
*/
static int th3getHexByte(const char **pz, int *pn, char *pByte){
  int iByte = 0;
  int j = 0;
  while( j<2 && (*pn)>0 ){
    char c = **pz;
    (*pz)++;
    (*pn)--;
    if( c>='0' && c<='9' ){
      c -= '0';
    }else if( c>='a' && c<='f' ){
      c -= 'a' - 10;
    }else if( c>='A' && c<='F' ){
      c -= 'A' - 10;
    }else{
      continue;
    }
    iByte = (iByte<<4) | c;
    j++;
  }
  *pByte = iByte & 0xff;
  return j==2;
}


/*
** A function to translate a HEX into a string.  Spaces in
** the hex input are ignored.  This implements hex_to_utf8(),
** hex_to_utf16le(), and hex_to_utf16be().
*/
static void th3_hex_to_utf(
  sqlite3_context *context,
  int argc,
  sqlite3_value **argv
){
  const char *zType = (char*)sqlite3_user_data(context);
  const char *zData;
  int nData;
  int j;
  char *zOut;
  static int one = 1;

  zData = (const char*)sqlite3_value_text(argv[0]);
  nData = sqlite3_value_bytes(argv[0]);
  zOut = sqlite3_malloc( nData/2 + 1 );
  if( zOut==0 ){
    sqlite3_result_error_nomem(context);
    return;
  }
  j = 0;
  while( th3getHexByte(&zData, &nData, &zOut[j]) ){ j++; }
  zOut[j] = 0;
  if( zType[0]=='8' ){
    sqlite3_result_text(context, zOut, j, sqlite3_free);
  }else if( zType[0]=='l' ){
    if( ((char*)&one)[0]==1 && (zOut[0]&1)==0 ){
      /* Use the native byte-order interface half the time if the native
      ** byte order of the host machine is little endian */
      sqlite3_result_text16(context, zOut, j, sqlite3_free);
    }else{
      /* Use the LE byte-order interface at least half the time, and all the
      ** time if the host machine is big endian */
      sqlite3_result_text16le(context, zOut, j, sqlite3_free);
    }
  }else{
    if( ((char*)&one)[0]==0 && (zOut[0]&1)==0 ){
      /* Use the native byte-order interface half the time if the native
      ** byte order of the host machine is big endian */
      sqlite3_result_text16(context, zOut, j, sqlite3_free);
    }else{
      /* Use the BE byte-order interface at least half the time, and all the
      ** time if the host machine is list endian */
      sqlite3_result_text16be(context, zOut, j, sqlite3_free);
    }
  }
}

/*
** Convert an ASCII string into UTF16 in the native byte order.
*/
static void th3_ascii_to_utf16(const char *zAscii, unsigned short *a16){
  while( (*a16 = *zAscii)!=0 ){ a16++; zAscii++; }
}

/*
** Implementation of
**
**         th3_sqlite3_limit(ID, VALUE)
**
** This SQL function invokes the sqlite3_limit() interface.  The
** first parameter is the symbolic name of the parameter to set.
** The second is the value to set.
*/
static void th3_sqlite3_limit(
  sqlite3_context *context,
  int argc,
  sqlite3_value **argv
){
  sqlite3 *db = sqlite3_context_db_handle(context);
  int rc;
  static const struct {
     char *zName;
     int id;
  } aId[] = {
    { "SQLITE_LIMIT_LENGTH",              SQLITE_LIMIT_LENGTH               },
    { "SQLITE_LIMIT_SQL_LENGTH",          SQLITE_LIMIT_SQL_LENGTH           },
    { "SQLITE_LIMIT_COLUMN",              SQLITE_LIMIT_COLUMN               },
    { "SQLITE_LIMIT_EXPR_DEPTH",          SQLITE_LIMIT_EXPR_DEPTH           },
    { "SQLITE_LIMIT_COMPOUND_SELECT",     SQLITE_LIMIT_COMPOUND_SELECT      },
    { "SQLITE_LIMIT_VDBE_OP",             SQLITE_LIMIT_VDBE_OP              },
    { "SQLITE_LIMIT_FUNCTION_ARG",        SQLITE_LIMIT_FUNCTION_ARG         },
    { "SQLITE_LIMIT_ATTACHED",            SQLITE_LIMIT_ATTACHED             },
    { "SQLITE_LIMIT_LIKE_PATTERN_LENGTH", SQLITE_LIMIT_LIKE_PATTERN_LENGTH  },
    { "SQLITE_LIMIT_VARIABLE_NUMBER",     SQLITE_LIMIT_VARIABLE_NUMBER      },
    { "SQLITE_LIMIT_TRIGGER_DEPTH",       SQLITE_LIMIT_TRIGGER_DEPTH        },
    
    /* Out of range test cases */
    { "SQLITE_LIMIT_TOOSMALL",            -1,                               },
    { "SQLITE_LIMIT_TOOBIG",              SQLITE_LIMIT_TRIGGER_DEPTH+1      },
  };
  int i, id;
  int val;
  const char *zId;

  assert( argc==2 );
  zId = (const char*)sqlite3_value_text(argv[0]);
  val = sqlite3_value_int(argv[1]);
  for(i=0; i<COUNT(aId); i++){
    if( th3strcmp(zId, aId[i].zName)==0 ){
      id = aId[i].id;
      break;
    }
  }
  if( i>=COUNT(aId) ){
    /* Return the error as UTF-16, just to exercise the
    ** sqlite3_result_error16() interface. */
    static const char zErrMsg[] = "unknown limit type";
    unsigned short int aErrMsg16[sizeof(zErrMsg)];
    th3_ascii_to_utf16(zErrMsg, aErrMsg16);
    sqlite3_result_error16(context, aErrMsg16, -1);
    return;
  }
  rc = sqlite3_limit(db, id, val);
  if( val<0 ){
    sqlite3_result_int(context, rc);
  }
  return;
}


/* This typedef is normally found in sqlite3ext.h.  But we are
** not sourcing that file */
typedef struct sqlite3_api_routines sqlite3_api_routines;

/*
** Simulate a broken extension loader.
*/
static int th3_broken_ext_init(
  sqlite3 *db, 
  char **pzErrMsg, 
  const sqlite3_api_routines *pApi
){
  *pzErrMsg= sqlite3_mprintf("broken!");
  return SQLITE_ERROR;
}

/*
** A degenerate collating sequence in which all strings are equal to
** one another.
*/
static int th3_allequal_collseq(
  void *pArg,
  int nKey1, const void *pKey1,
  int nKey2, const void *pKey2
){
  return 0;
}

/*
** The collating sequence is the same as BINARY.
*/
static int th3_binary_collseq(
  void *pArg,
  int nKey1, const void *pKey1,
  int nKey2, const void *pKey2
){
  int rc, n;
  n = nKey1<nKey2 ? nKey1 : nKey2;
  rc = memcmp(pKey1, pKey2, n);
  return rc;
}


/*
** Load the UTF coder/decoder extensions.  This is the default extension
** loader.
**
** Note that sqlite3_create_function16() is used for some functions instead
** of the more natural sqlite3_create_function().  This is merely to
** exercise the UTF-16 function creation mechanism.
*/
static int th3_normal_ext_init(
  sqlite3 *db, 
  char **pzErrMsg, 
  const sqlite3_api_routines *pApi
){
  int rc;
  unsigned short a16[30];
  th3_ascii_to_utf16("utf8_to_hex", a16);
  rc = sqlite3_create_function16(db, a16, 1, SQLITE_UTF8, (void*)"8",
                                 th3_utf_to_hex, 0, 0);
  if( rc ) return rc;
  rc = sqlite3_create_function(db, "utf16le_to_hex", 1, SQLITE_UTF16LE,
                               (void*)"l", th3_utf_to_hex, 0, 0);
  if( rc ) return rc;
  rc = sqlite3_create_function(db, "utf16be_to_hex", 1, SQLITE_UTF16BE,
                              (void*)"b", th3_utf_to_hex, 0, 0);
  if( rc ) return rc;
  th3_ascii_to_utf16("hex_to_utf8", a16);
  rc = sqlite3_create_function16(db, a16, 1, SQLITE_UTF8, (void*)"8",
                                 th3_hex_to_utf, 0, 0);
  if( rc ) return rc;
  rc = sqlite3_create_function(db, "hex_to_utf16le", 1, SQLITE_UTF8, (void*)"l",
                               th3_hex_to_utf, 0, 0);
  if( rc ) return rc;
  rc = sqlite3_create_function(db, "hex_to_utf16be", 1, SQLITE_UTF8, (void*)"b",
                               th3_hex_to_utf, 0, 0);
  if( rc ) return rc;
  rc = sqlite3_create_function(db, "th3_sqlite3_limit", 2, SQLITE_UTF8, 0,
                               th3_sqlite3_limit, 0, 0);
  if( rc ) return rc;
  rc = sqlite3_create_collation(db, "th3_alleq", SQLITE_UTF8, 0,
                                th3_allequal_collseq);
  if( rc ) return rc;
  rc = sqlite3_create_collation(db, "th3_binary16le", SQLITE_UTF16LE, 0,
                                th3_binary_collseq);
  if( rc ) return rc;
  rc = sqlite3_create_collation(db, "th3_binary16be", SQLITE_UTF16BE, 0,
                                th3_binary_collseq);
  return rc;
}


/*
** Load the UTF coder/decoder extensions.  This is the auxiliary extension
** loader
*/
static int th3_aux_ext_init(
  sqlite3 *db, 
  char **pzErrMsg, 
  const sqlite3_api_routines *pApi
){
  int rc;
  rc = sqlite3_create_function(db, "u8_hex", 1, SQLITE_UTF8, (void*)"8",
                               th3_utf_to_hex, 0, 0);
  if( rc ) return rc;
  rc = sqlite3_create_function(db, "u16le_hex", 1, SQLITE_UTF16LE, (void*)"l",
                               th3_utf_to_hex, 0, 0);
  if( rc ) return rc;
  rc = sqlite3_create_function(db, "u16be_hex", 1, SQLITE_UTF16BE, (void*)"b",
                               th3_utf_to_hex, 0, 0);
  if( rc ) return rc;
  rc = sqlite3_create_function(db, "hex_u8", 1, SQLITE_UTF8, (void*)"8",
                               th3_hex_to_utf, 0, 0);
  if( rc ) return rc;
  rc = sqlite3_create_function(db, "hex_u16le", 1, SQLITE_UTF8, (void*)"l",
                               th3_hex_to_utf, 0, 0);
  if( rc ) return rc;
  rc = sqlite3_create_function(db, "hex_u16be", 1, SQLITE_UTF8, (void*)"b",
                               th3_hex_to_utf, 0, 0);
  return rc;
}

/************************************************************************
** Here begins the implementation of a virtual table that provides a
** a range of whole numbers. Example:
**
**    CREATE VIRTUAL TABLE nums USING wholenumber;
**    CREATE TABLE ex(a);
**    INSERT INTO ex SELECT value FROM nums WHERE value BETWEEN 1000 AND 2000;
**
** The wholenumber virtual table is a convenient way to generate test
** data for a table.
*/
/* A wholenumber cursor object */
typedef struct wholenumber_cursor wholenumber_cursor;
struct wholenumber_cursor {
  sqlite3_vtab_cursor base;  /* Base class - must be first */
  unsigned iValue;           /* Current value */
  unsigned mxValue;          /* Maximum value */
};

/* Methods for the wholenumber module */
static int wholenumberConnect(
  sqlite3 *db,
  void *pAux,
  int argc, const char *const*argv,
  sqlite3_vtab **ppVtab,
  char **pzErr
){
  sqlite3_vtab *pNew;
  pNew = *ppVtab = sqlite3_malloc( sizeof(*pNew) );
  if( pNew==0 ) return SQLITE_NOMEM;
  sqlite3_declare_vtab(db, "CREATE TABLE x(value)");
  memset(pNew, 0, sizeof(*pNew));
  return SQLITE_OK;
}
/* Note that for this virtual table, the xCreate and xConnect
** methods are identical. */

static int wholenumberDisconnect(sqlite3_vtab *pVtab){
  sqlite3_free(pVtab);
  return SQLITE_OK;
}
/* The xDisconnect and xDestroy methods are also the same */


/*
** Open a new wholenumber cursor.
*/
static int wholenumberOpen(sqlite3_vtab *p, sqlite3_vtab_cursor **ppCursor){
  wholenumber_cursor *pCur;
  pCur = sqlite3_malloc( sizeof(*pCur) );
  if( pCur==0 ) return SQLITE_NOMEM;
  memset(pCur, 0, sizeof(*pCur));
  *ppCursor = &pCur->base;
  return SQLITE_OK;
}

/*
** Close a wholenumber cursor.
*/
static int wholenumberClose(sqlite3_vtab_cursor *cur){
  sqlite3_free(cur);
  return SQLITE_OK;
}


/*
** Advance a cursor to its next row of output
*/
static int wholenumberNext(sqlite3_vtab_cursor *cur){
  wholenumber_cursor *pCur = (wholenumber_cursor*)cur;
  pCur->iValue++;
  return SQLITE_OK;
}

/*
** Return the value associated with a wholenumber.
*/
static int wholenumberColumn(
  sqlite3_vtab_cursor *cur,
  sqlite3_context *ctx,
  int i
){
  wholenumber_cursor *pCur = (wholenumber_cursor*)cur;
  sqlite3_result_int64(ctx, pCur->iValue);
  return SQLITE_OK;
}

/*
** The rowid.
*/
static int wholenumberRowid(sqlite3_vtab_cursor *cur, sqlite_int64 *pRowid){
  wholenumber_cursor *pCur = (wholenumber_cursor*)cur;
  *pRowid = pCur->iValue;
  return SQLITE_OK;
}

/*
** When the wholenumber_cursor.rLimit value is 0 or less, that is a signal
** that the cursor has nothing more to output.
*/
static int wholenumberEof(sqlite3_vtab_cursor *cur){
  wholenumber_cursor *pCur = (wholenumber_cursor*)cur;
  return pCur->iValue>pCur->mxValue || pCur->iValue==0;
}

/*
** Called to "rewind" a cursor back to the beginning so that
** it starts its output over again.  Always called at least once
** prior to any wholenumberColumn, wholenumberRowid, or wholenumberEof call.
**
**    idxNum   Constraints
**    ------   ---------------------
**      0      (none)
**      1      value > $argv0
**      2      value >= $argv0
**      4      value < $argv0
**      8      value <= $argv0
**
**      5      value > $argv0 AND value < $argv1
**      6      value >= $argv0 AND value < $argv1
**      9      value > $argv0 AND value <= $argv1
**     10      value >= $argv0 AND value <= $argv1
*/
static int wholenumberFilter(
  sqlite3_vtab_cursor *pVtabCursor, 
  int idxNum, const char *idxStr,
  int argc, sqlite3_value **argv
){
  wholenumber_cursor *pCur = (wholenumber_cursor *)pVtabCursor;
  sqlite3_int64 v;
  int i = 0;
  pCur->iValue = 1;
  pCur->mxValue = 0xffffffff;  /* 4294967295 */
  if( idxNum & 3 ){
    v = sqlite3_value_int64(argv[0]) + (idxNum&1);
    if( v>pCur->iValue && v<=pCur->mxValue ) pCur->iValue = v;
    i++;
  }
  if( idxNum & 12 ){
    v = sqlite3_value_int64(argv[i]) - ((idxNum>>2)&1);
    if( v>=pCur->iValue && v<pCur->mxValue ) pCur->mxValue = v;
  }
  return SQLITE_OK;
}

/*
** Search for terms of these forms:
**
**  (1)  value > $value
**  (2)  value >= $value
**  (4)  value < $value
**  (8)  value <= $value
**
** idxNum is an ORed combination of 1 or 2 with 4 or 8.
*/
static int wholenumberBestIndex(
  sqlite3_vtab *tab,
  sqlite3_index_info *pIdxInfo
){
  int i;
  int idxNum = 0;
  int argvIdx = 1;
  int ltIdx = -1;
  int gtIdx = -1;
  const struct sqlite3_index_constraint *pConstraint;
  pConstraint = pIdxInfo->aConstraint;
  for(i=0; i<pIdxInfo->nConstraint; i++, pConstraint++){
    if( pConstraint->usable==0 ) continue;
    if( (idxNum & 3)==0 && pConstraint->op==SQLITE_INDEX_CONSTRAINT_GT ){
      idxNum |= 1;
      ltIdx = i;
    }
    if( (idxNum & 3)==0 && pConstraint->op==SQLITE_INDEX_CONSTRAINT_GE ){
      idxNum |= 2;
      ltIdx = i;
    }
    if( (idxNum & 12)==0 && pConstraint->op==SQLITE_INDEX_CONSTRAINT_LT ){
      idxNum |= 4;
      gtIdx = i;
    }
    if( (idxNum & 12)==0 && pConstraint->op==SQLITE_INDEX_CONSTRAINT_LE ){
      idxNum |= 8;
      gtIdx = i;
    }
  }
  pIdxInfo->idxNum = idxNum;
  if( ltIdx>=0 ){
    pIdxInfo->aConstraintUsage[ltIdx].argvIndex = argvIdx++;
    pIdxInfo->aConstraintUsage[ltIdx].omit = 1;
  }
  if( gtIdx>=0 ){
    pIdxInfo->aConstraintUsage[gtIdx].argvIndex = argvIdx;
    pIdxInfo->aConstraintUsage[gtIdx].omit = 1;
  }
  if( pIdxInfo->nOrderBy==1
   && pIdxInfo->aOrderBy[0].desc==0
  ){
    pIdxInfo->orderByConsumed = 1;
  }
  pIdxInfo->estimatedCost = (double)1;
  return SQLITE_OK;
}

/*
** A virtual table module that provides read-only access to a
** Tcl global variable namespace.
*/
static sqlite3_module wholenumberModule = {
  0,                         /* iVersion */
  wholenumberConnect,
  wholenumberConnect,
  wholenumberBestIndex,
  wholenumberDisconnect, 
  wholenumberDisconnect,
  wholenumberOpen,           /* xOpen - open a cursor */
  wholenumberClose,          /* xClose - close a cursor */
  wholenumberFilter,         /* xFilter - configure scan constraints */
  wholenumberNext,           /* xNext - advance a cursor */
  wholenumberEof,            /* xEof - check for end of scan */
  wholenumberColumn,         /* xColumn - read data */
  wholenumberRowid,          /* xRowid - read data */
  0,                         /* xUpdate */
  0,                         /* xBegin */
  0,                         /* xSync */
  0,                         /* xCommit */
  0,                         /* xRollback */
  0,                         /* xFindMethod */
  0,                         /* xRename */
};
/*
** End of the wholenumber virtual table implementation
*****************************************************************************/

/****************************************************************************/
/* The following code checks a file to see if it is an SQLite database
** file.  If it is an SQLite database file, this code validates properties
** of the header.
*/

/* Convert a big-endian 4-byte integer into a native integer */
static int th3getInt32(const unsigned char *a){
  return (a[0]<<24) + (a[1]<<16) + (a[2]<<8) + a[3];
}

/* Report a database validity fault. */
static void th3vfsValidityFault(
  th3state *p,               /* The test context */
  th3vfsFile *pFile,         /* The file on which the fault occurred */
  const char *zErr, ...      /* Description of the fault */
){
  va_list ap;
  char zBuf[100];
  th3print(p, "FAILED validity check on \"");
  th3print(p, pFile->zFilename);
  th3print(p, "\": ");
  va_start(ap, zErr);
  sqlite3_vsnprintf(sizeof(zBuf), zBuf, zErr, ap);
  va_end(ap);
  th3print(p, zBuf);
  th3print(p, "\n");
}

/* Test pFile for database validity.  pFile might not be a database
** file at all, but if it is, check its header to make sure certain
** attributes of the header are consistent.
**
** This routine is called whenever SQLite does an xSync() because
** we know that SQLite only does an xSync() on a database if it thinks
** that database is well-formed.
*/
static void th3vfsValidDatabase(th3state *p, th3vfsFile *pFile){
  unsigned char *a;
  u32 i;
  sqlite3_int64 sz;

  /* Omit this test for any of the database-corruption modules */
  if( memcmp(p->module.zModuleName, "corrupt", 7)==0 ) return;

  /* Make sure the file is at least 100 bytes in size.  Ignore it if not. */
  if( pFile->sz<100 ) return;

  /* The file must have a valid magic string as the first 16-bytes of the
  ** header.  Otherwise it is not a database and can be ignored. */
  a = (unsigned char*)pFile->apSector[0]->a;
  if( memcmp(a, "SQLite format 3", 16)!=0 ) return;

  /* If we get this far, it is a database.  Verify that the correct
  ** version number is set. */
  i = th3getInt32(&a[96]);
  if( i!=SQLITE_VERSION_NUMBER ){
    th3vfsValidityFault(p, pFile, "version number is %d instead of %d",
                        i, SQLITE_VERSION_NUMBER);
    p->nFail++;
  }

  /* Verify that the change counter at 24 agrees with the change counter
  ** at 92 and that both are non-zero. */
  if( memcmp(&a[24], &a[92],4)!=0 ){
    th3vfsValidityFault(p, pFile, "change counters at 24 and 92 do not agree");
    p->nFail++;
  }
  i = th3getInt32(&a[24]);
  if( i==0 ){
    th3vfsValidityFault(p, pFile, "change counter is zero");
    p->nFail++;
  }

  /* Verify that the database size field is not greater than the actual
  ** file size */
  sz = (a[16]<<8) + a[17];
  if( sz==1 ) sz = 65536;
  sz *= th3getInt32(&a[28]);
  if( sz > pFile->sz ){
    th3vfsValidityFault(p, pFile, "true size is %lld but header says %lld",
                        pFile->sz, sz);
    p->nFail++;
  }
}

/****************************************************************************/

/*
** Forward reference to all of the VFS methods
*/
static int th3vfsOpen(sqlite3_vfs*, const char*, sqlite3_file*,int,int*);
static int th3vfsDelete(sqlite3_vfs*, const char*, int);
static int th3vfsAccess(sqlite3_vfs*, const char*, int, int*);
static int th3vfsFullPathname(sqlite3_vfs*, const char *, int nOut, char *zOut);
static void *th3vfsDlOpen(sqlite3_vfs*, const char *zFilename);
static void th3vfsDlError(sqlite3_vfs*, int nByte, char *zErrMsg);
static void (*th3vfsDlSym(sqlite3_vfs*,void*, const char *zSymbol))(void);
static void th3vfsDlClose(sqlite3_vfs*, void*);
static int th3vfsRandomness(sqlite3_vfs*, int nByte, char *zOut);
static int th3vfsSleep(sqlite3_vfs*, int microseconds);
static int th3vfsCurrentTime(sqlite3_vfs*, double*);
static int th3vfsGetLastError(sqlite3_vfs*, int, char*);
static int th3vfsCurrentTimeInt64(sqlite3_vfs*, sqlite3_int64*);

static int th3vfsClose(sqlite3_file*);
static int th3vfsRead(sqlite3_file*, void*, int iAmt, sqlite3_int64 iOfst);
static int th3vfsWrite(sqlite3_file*, const void*, int iAmt, sqlite3_int64);
static int th3vfsTruncate(sqlite3_file*, sqlite3_int64 size);
static int th3vfsSync(sqlite3_file*, int flags);
static int th3vfsFileSize(sqlite3_file*, sqlite3_int64 *pSize);
static int th3vfsLock(sqlite3_file*, int);
static int th3vfsUnlock(sqlite3_file*, int);
static int th3vfsCheckReservedLock(sqlite3_file*, int*);
static int th3vfsFileControl(sqlite3_file*, int op, void *pArg);
static int th3vfsSectorSize(sqlite3_file*);
static int th3vfsDeviceCharacteristics(sqlite3_file*);
static int th3vfsShmMap(sqlite3_file*, int, int, int, void volatile**);
static int th3vfsShmLock(sqlite3_file*, int ofst, int n, int flags);
static void th3vfsShmBarrier(sqlite3_file*);
static int th3vfsShmUnmap(sqlite3_file*, int deleteFlag);


/*
** Maximum length of an th3vfs filename
*/
#define TH3VFS_MAX_FILENAME  (40+12)

/*
** The VFS structure used by SQLite.
*/
static const sqlite3_vfs th3vfsObjTemplate = {
  2,
  sizeof(th3vfsFd),
  TH3VFS_MAX_FILENAME,
  0,
  0,
  0,
  th3vfsOpen,
  th3vfsDelete,
  th3vfsAccess,
  th3vfsFullPathname,
  th3vfsDlOpen,
  th3vfsDlError,
  th3vfsDlSym,
  th3vfsDlClose,
  th3vfsRandomness,
  th3vfsSleep,
  th3vfsCurrentTime,
  th3vfsGetLastError,
  th3vfsCurrentTimeInt64   /* xCurrentTimeInt64 */
};

/*
** The file descriptor methods.
*/
static const sqlite3_io_methods th3vfsIo = {
  2,
  th3vfsClose,
  th3vfsRead,
  th3vfsWrite,
  th3vfsTruncate,
  th3vfsSync,
  th3vfsFileSize,
  th3vfsLock,
  th3vfsUnlock,
  th3vfsCheckReservedLock,
  th3vfsFileControl,
  th3vfsSectorSize,
  th3vfsDeviceCharacteristics,
  th3vfsShmMap,            /* xShmMap */
  th3vfsShmLock,           /* xShmLock */
  th3vfsShmBarrier,        /* xShmBarrier */
  th3vfsShmUnmap           /* xShmUnmap */
};

/*
** Print tracing information
*/
static void fsTrace(th3vfsFSys *p, const char *zFormat, ...){
  va_list ap;
  char *z;
  if( p->trace==0 || p->p==0 ) return;
  z = th3malloc(p->p, 1000);
  va_start(ap, zFormat);
  th3vsnprintf(z, 1000, zFormat, ap);
  va_end(ap);
  th3print(p->p, z);
  th3free(p->p, z);
}

/*
** Decrement the snapshot counter, th3vfsFSys.ss.  If it reaches zero,
** make a snapshot of the filesystem.
*/
static void decrSnapshotCnt(th3vfsFSys *p, int mask){
  if( (mask & (p->ssOmitMask ^ TH3VFS_IOERR_PREDELETE))==0 && p->ssCntdown ){
    p->ssCntdown--;
    if( p->ssCntdown==0 ){
      th3filesystemReset(p->pFsysSS);
      th3filesystemCopy(p->pFsysSS, p);
      fsTrace(p, "SNAPSHOT\n");
    }
  }
}

/*
** Check to see if the input filename was generated by
** th3testvfsFullPathname() with an optional suffix.  Such a
** filename will begin with "[testvfsNNN]" where NNN is the
** length of the original filename without the prefix.  Hence,
** the character at index NNN+12 into the input string must be
** either zero or the first character of a valid suffix.  A
** valid suffix must begin with "-" and consist of no more than
** 10 alphanumeric and "-" characters.
**
** Return true the length of the valid prefix.  Return 0 if
** the input filename is not an xFullPathname() generated string
** with a valid suffix.
**
** This routine is an important part of the proof for:
**
** EVIDENCE-OF: R-36859-05333 SQLite guarantees that the zFilename
** parameter to xOpen is either a NULL pointer or string obtained from
** xFullPathname() with an optional suffix added.
*/
static int th3vfsNameIsFullPathnameWithSuffix(const char *z){
  int i, n;
  if( memcmp(z, "[testvfs",8)!=0 ) return 0;
  if( !th3isdigit(z[8]) ) return 0;
  if( !th3isdigit(z[9]) ) return 0;
  if( !th3isdigit(z[10]) ) return 0;
  if( z[11]!=']' ) return 0;
  assert( z[12]!='[' );
  n = (z[8]-'0')*100 + (z[9] - '0')*10 + z[10] - '0';
  if( n==999 ) return 12;  /* Special case for 8+3 names */
  if( strlen(&z[12])<n ) return 0;
  n += 12;
  if( z[n]==0 ) return 12;

  /* If the filename contains a suffix, verify that the suffix is
  ** well-formed.
  **
  ** EVIDENCE-OF: R-15560-37774 If a suffix is added to the zFilename
  ** parameter, it will consist of a single "-" character followed by no
  ** more than 10 alphanumeric and/or "-" characters.
  */
  if( z[n]!='-' ) return 0;
  for(i=1; i<=10 && z[i+n]; i++){
    if( !th3isalnum(z[i+n]) && z[i+n]!='-' ) return 0;
  }
  if( z[i+n]!=0 ) return 0;
  return 12;
}

/*
** Locate a file with the given name.  Return a pointer to the file if
** it exists.  If the file does not exists and createFlag is true, then
** create the file.  New files are initially empty.
*/
static th3vfsFile *findFile(th3vfsFSys *p, const char *zName, int createFlag){
  th3vfsFile *pFile;
  int nName;
  zName += th3vfsNameIsFullPathnameWithSuffix(zName);
  nName = strlen(zName);
  if( th3strncmp(zName, "/nil/", 5)==0 ) return 0;
  for(pFile=p->pFile; pFile; pFile=pFile->pNext){
    if( th3strcmp(pFile->zFilename, zName)==0 ){
      return pFile;
    }
  }
  if( nName>1 && zName[nName-1]=='*' ){
    for(pFile=p->pFile; pFile; pFile=pFile->pNext){
      if( th3strncmp(pFile->zFilename, zName, nName-1)==0 ){
        return pFile;
      }
    }
  }
  if( createFlag && p->nSector<p->mxSector ){
    pFile = th3malloc(p->p, sizeof(*pFile) + strlen(zName) );
    if( pFile ){
      th3memset(pFile, 0, sizeof(*pFile));
      th3strcpy(pFile->zFilename, zName);
      if( p->pFile ){
        p->pFile->pPrev = pFile;
      }
      pFile->notSynced = 1;
      p->nNotSynced++;
      pFile->pNext = p->pFile;
      p->pFile = pFile;
      p->nSector++;
      pFile->rowid = p->nxRowid++;
      decrSnapshotCnt(p, TH3VFS_IOERR_OPEN);
    }
  }
  return pFile;
}

/*
** Delete a single page.
*/
static void destroyPage(th3vfsFSys *p, th3vfsSector *pSector){
  if( pSector->pPrev ){
    pSector->pPrev->pNext = pSector->pNext;
  }else{
    assert( p->pSector==pSector );
    p->pSector = pSector->pNext;
  }
  if( pSector->pNext ){
    pSector->pNext->pPrev = pSector->pPrev;
  }
  if( pSector->notSynced ){
    p->nNotSynced--;
    assert( p->nNotSynced>=0 );
  }
  th3free(p->p, pSector);
  p->nSector--;
}

/*
** Adjust a sector offset for the zerogap.
**
**   1.  If there is no zerogap, return the offset unchanged.
**   2.  If the offset is before the start of the gap, return it unchanged.
**   3.  If the offset falls within the zerogap, return -1
**   4.  If the offset is beyond the zerogap, subtract the size of the gap.
*/
static int adjustForZerogap(th3vfsFile *pFile, int iOfst){
  if( pFile->zerogapCount && iOfst>=pFile->zerogapStart ){
    if( iOfst<pFile->zerogapStart+pFile->zerogapCount ){
      iOfst = -1;
    }else{
      iOfst -= pFile->zerogapCount;
    }
  }
  return iOfst;
}

/* Forward declaration */
static int increaseFileSize(th3vfsFSys*, th3vfsFile*, int, int);

/*
** Append a gap of zeros onto the end of a file.  The gap cannot be
** removed except by deleting the file.
**
** This routine only works with the VFS. Do not try to use it with the
** native filesystem.  If you do, it will segfault.
**
** This interface is used to create massive files (multiple gigabytes)
** without consuming much memory, in order to test the operation of
** SQLite on large files.
*/
static void extendFile(
  th3vfsFSys *pFsys,        /* The filesystem containing the file */
  th3vfsFile *pFile,        /* The file to be extended */
  sqlite3_int64 newSize     /* The new size of the file after extending */
){
  if( pFile->zerogapStart==0 && pFile->zerogapCount==0 ){
    pFile->sz = (pFile->sz + pFsys->szSector - 1) & ~(pFsys->szSector-1);
    pFile->zerogapStart = pFile->sz/pFsys->szSector + 1;
    pFile->zerogapCount = (newSize - pFile->sz)/pFsys->szSector - 1;
    pFile->sz += pFile->zerogapCount*(sqlite3_int64)pFsys->szSector;
    if( pFile->sz<newSize ){
      int nSector = pFile->sz/pFsys->szSector;
      increaseFileSize(pFsys, pFile, nSector, nSector+1);
      pFile->sz = newSize;
    }
  }
}

/*
** Truncate a file back to sz bytes in size.
*/
static void truncateFile(th3vfsFSys *p, th3vfsFile *pFile, sqlite3_int64 szNew){
  int i;
  int oldPageCnt;
  int newPageCnt;

  oldPageCnt = (pFile->sz + p->szSector - 1)/p->szSector;
  oldPageCnt = adjustForZerogap(pFile, oldPageCnt);
  assert( oldPageCnt>=0 );
  newPageCnt = (szNew + p->szSector - 1)/p->szSector;
  newPageCnt = adjustForZerogap(pFile, newPageCnt);
  if( newPageCnt<0 ){
    newPageCnt = pFile->zerogapStart;
  }
  for(i=oldPageCnt-1; i>=newPageCnt; i--){
    th3vfsSector *pSector = pFile->apSector[i];
    assert( pSector->pFile==pFile );
    assert( pSector->idx==i );
    destroyPage(p, pSector);
  }
  pFile->apSector = th3realloc(p->p, pFile->apSector,
                                  newPageCnt*sizeof(th3vfsSector*) );
  assert( newPageCnt==0 || pFile->apSector!=0 );
  if( oldPageCnt<newPageCnt ){
    increaseFileSize(p, pFile, oldPageCnt, newPageCnt);
  }
  pFile->sz = (sqlite3_int64)(newPageCnt + pFile->zerogapCount) * p->szSector;
  if( pFile->sz>szNew ){
    pFile->zerogapCount -= (pFile->sz - szNew)/p->szSector;
    if( pFile->zerogapCount<=0 ){
      pFile->zerogapCount = 0;
      pFile->zerogapStart = 0;
    }
    pFile->sz = szNew;
  }
}


/*
** Delete a file.  Reclaim all memory.
*/
static void destroyFile(th3vfsFSys *p, th3vfsFile *pFile){
  assert( pFile->nRef==0 );
  if( pFile->pPrev ){
    pFile->pPrev->pNext = pFile->pNext;
  }else{
    assert( p->pFile==pFile );
    p->pFile = pFile->pNext;
  }
  if( pFile->pNext ){
    pFile->pNext->pPrev = pFile->pPrev;
  }
  truncateFile(p, pFile, 0);
  if( pFile->notSynced ){
    p->nNotSynced--;
  }
  assert( p->nNotSynced>=0 );
  assert( p->pFile || p->nNotSynced==0 );
  th3free(p->p, pFile);
  p->nSector--;
  p->nDelete++;
}


/*
** Delete all content from the memory vfs.
*/
static void th3filesystemReset(th3vfsFSys *p){
  th3vfsFile **ppFile;
  fsTrace(p, "FS-RESET\n");
  ppFile = &p->pFile;
  while( *ppFile ){
    if( (*ppFile)->nRef==0 ){
      destroyFile(p, *ppFile);
    }else{
      (*ppFile)->deleteOnClose = 1;
      ppFile = &(*ppFile)->pNext;
    }
  }
  p->zReadonly[0] = 0;
}

/*
** Forward declaration.
*/
static int th3ioerrSimulate(th3vfsFSys *p, int mask);

/*
** The SQLite VFS xOpen method for th3vfs
*/
static int th3vfsOpen(
  sqlite3_vfs *pVfs,        /* The VFS */
  const char *zFilename,    /* Name of file to open */
  sqlite3_file *pSFile,     /* Fill in this file descriptor */
  int flags,                /* Mode flags */
  int *pOutFlags            /* Return flags set by this method */
){
  th3vfsFSys *p = (th3vfsFSys*)pVfs->pAppData;
  th3vfsFile *pFile;
  th3vfsFd *pFd = (th3vfsFd*)pSFile;
  int outflags;
  int createFlag;
  int x;
  const char *zOrigFilename = zFilename;
  char zTemp[100];

  p->nSyscall++;

  /* EVIDENCE-OF: R-36859-05333 SQLite guarantees that the zFilename
  ** parameter to xOpen is either a NULL pointer or string obtained from
  ** xFullPathname() with an optional suffix added.
  */
  if( zFilename ){
    int n = th3vfsNameIsFullPathnameWithSuffix(zFilename);
    assert( n>0 );
    zFilename += n;
    zOrigFilename += n;
  }

  /* EVIDENCE-OF: R-32633-52682 At least szOsFile bytes of memory are
  ** allocated by SQLite to hold the sqlite3_file structure passed as the
  ** third argument to xOpen.
  **
  ** By overwriting the first szOsFile bytes of of the sqlite3_file object,
  ** we guaranatee that memory allocation debuggers (memsys2, valgrind) would
  ** find a problem if the allocate where less than szOsFile bytes. */
  memset(pSFile, 0, pVfs->szOsFile);

  /* EVIDENCE-OF: R-29901-08836 The SQLITE_OPEN_EXCLUSIVE flag is always
  ** used in conjunction with the SQLITE_OPEN_CREATE flag, which are both
  ** directly analogous to the O_EXCL and O_CREAT flags of the POSIX open()
  ** API. */
  assert( (flags & SQLITE_OPEN_EXCLUSIVE)==0
            || (flags & SQLITE_OPEN_CREATE)!=0 );

  /* EVIDENCE-OF: R-62406-19374 The SQLITE_OPEN_DELETEONCLOSE will be set
  ** for TEMP databases and their journals, transient databases, and
  ** subjournals. */
  assert( (flags & SQLITE_OPEN_DELETEONCLOSE)==0
           || 0!=(flags & (SQLITE_OPEN_TEMP_DB |
                           SQLITE_OPEN_TEMP_JOURNAL |
                           SQLITE_OPEN_TRANSIENT_DB |
                           SQLITE_OPEN_SUBJOURNAL)) );

  /* EVIDENCE-OF: R-40416-50415 SQLite will also add one of the following
  ** flags to the xOpen() call, depending on the object being opened:
  ** SQLITE_OPEN_MAIN_DB SQLITE_OPEN_MAIN_JOURNAL SQLITE_OPEN_TEMP_DB
  ** SQLITE_OPEN_TEMP_JOURNAL SQLITE_OPEN_TRANSIENT_DB
  ** SQLITE_OPEN_SUBJOURNAL SQLITE_OPEN_MASTER_JOURNAL SQLITE_OPEN_WAL */
  x = flags & (SQLITE_OPEN_MAIN_DB | SQLITE_OPEN_MAIN_JOURNAL |
               SQLITE_OPEN_TEMP_DB | SQLITE_OPEN_TEMP_JOURNAL |
               SQLITE_OPEN_TRANSIENT_DB | SQLITE_OPEN_SUBJOURNAL |
               SQLITE_OPEN_MASTER_JOURNAL | SQLITE_OPEN_WAL);
  assert( (x & (x-1))==0 && x!=0 );

  /* EVIDENCE-OF: R-16263-09274 Whenever the xFilename parameter is NULL it
  ** will also be the case that the flags parameter will include
  ** SQLITE_OPEN_DELETEONCLOSE. */
  assert( zFilename!=0 || (flags & SQLITE_OPEN_DELETEONCLOSE)!=0 );


  pSFile->pMethods = 0;
  if( zFilename==0 ){
    sqlite3_snprintf(sizeof(zTemp), zTemp, "temp-file-%d", p->nTemp++);
    zFilename = zTemp;
  }
  fsTrace(p, "OPEN %s\n", zFilename);
  if( th3ioerrSimulate(p, TH3VFS_IOERR_OPEN) ){
    return SQLITE_IOERR;
  }
  if( (flags & SQLITE_OPEN_CREATE)!=0
   && (p->ioerr.mask & TH3VFS_IOERR_FULL)!=0
   && findFile(p, zFilename, 0)==0
   && th3ioerrSimulate(p, TH3VFS_IOERR_FULL)
  ){
    return SQLITE_FULL;
  }
  if( (flags & SQLITE_OPEN_CREATE)==0 ){
    createFlag = 0;  /* Do not create because OPEN_CREATE is missing */
  }else if( th3strglobAny(p->zReadonly, zFilename) ){
    createFlag = 0;  /* Do not create read-only files */
  }else{
    createFlag = 1;  /* Otherwise, it is ok to create the file */
  }
  pFile = findFile(p, zFilename, createFlag);
  if( pFile==0 ){
    return SQLITE_CANTOPEN;
  }
  if( pFile->isExclusive && pFile->nRef>0 ){
    return SQLITE_CANTOPEN;
  }
  p->nOpen++;
  if( flags &
      (SQLITE_OPEN_MAIN_DB | SQLITE_OPEN_TEMP_DB | SQLITE_OPEN_TRANSIENT_DB)
  ){
    p->nOpenDb++;
  }
  pFile->nRef++;
  if( pFile->nRef==1 ){
    pFile->isExclusive = (flags & SQLITE_OPEN_EXCLUSIVE)!=0;
  }
  if( flags & SQLITE_OPEN_DELETEONCLOSE ){
    pFile->deleteOnClose = 1;
  }
  pFd->zOpenName = zOrigFilename;
  pFd->pFile = pFile;
  pFd->openFlags = flags;
  assert( zOrigFilename==0 || th3strcmp(zOrigFilename, pFile->zFilename)==0 );
  pFd->pFsys = p;
  if( (pFile->readOnly&1)!=0
   || (flags&SQLITE_OPEN_READONLY)!=0
   || th3strglobAny(p->zReadonly,zFilename)
  ){
    pFd->readOnly = 1;
  }else{
    pFd->readOnly = 0;
  }
  pFd->fileLock = SQLITE_LOCK_NONE;
  pFd->base.pMethods = p->pMethods ? p->pMethods : &th3vfsIo;
  outflags = flags;
  if( pFd->readOnly ){
    outflags |= SQLITE_OPEN_READONLY;
  }
  pFd->pNext = p->pOpen;
  if( p->pOpen ){
    p->pOpen->pPrev = pFd;
  }
  p->pOpen = pFd;
  pFd->pPrev = 0;
  pFd->iVfsFdMagic = TH3VFS_MAGIC_FDOPEN;
  pFd->ignoreWrite = 0;
  if( pOutFlags ) *pOutFlags = outflags;
  return SQLITE_OK;
}

/*
** The SQLite VFS xDelete method for th3vfs
*/
static int th3vfsDelete(
  sqlite3_vfs *pVfs,       /* The VFS */
  const char *zFilename,   /* Name of file to delete */
  int syncDir              /* True to synchronize the directory */
){
  th3vfsFSys *p = (th3vfsFSys*)pVfs->pAppData;
  th3vfsFile *pFile;

  decrSnapshotCnt(p, TH3VFS_IOERR_PREDELETE);
  fsTrace(p, "DELETE %s\n", zFilename);
  if( th3ioerrSimulate(p, TH3VFS_IOERR_DELETE) ){
    return SQLITE_IOERR_DELETE;
  }

  /* Do not delete if read-only */
  if( th3strglobAny(p->zReadonly, zFilename) ){
    return SQLITE_IOERR_DELETE;
  }

  pFile = findFile(p, zFilename, 0);
  if( pFile ){
    if( pFile->nRef==0 ){
      destroyFile(p, pFile);
      decrSnapshotCnt(p, TH3VFS_IOERR_DELETE);
    }else if( p->undeletableWhenOpen || (pFile->readOnly&1)!=0 ){
      return SQLITE_IOERR_DELETE;
    }else{
      pFile->deleteOnClose = 1;
      pFile->zFilename[0] = 0;
    }
  }
  return SQLITE_OK;
}

/*
** The SQLite VFS xAccess method for th3vfs
*/
static int th3vfsAccess(
  sqlite3_vfs *pVfs,      /* The VFS */
  const char *zFilename,  /* Name of the file to test */
  int flags,              /* Type of test to perform */
  int *pOut               /* Return true or false here */
){
  th3vfsFSys *p = (th3vfsFSys*)pVfs->pAppData;
  th3vfsFile *pFile;

  p->nSyscall++;

  /* EVIDENCE-OF: R-53478-59161 The flags argument to xAccess() may be
  ** SQLITE_ACCESS_EXISTS to test for the existence of a file, or
  ** SQLITE_ACCESS_READWRITE to test whether a file is readable and
  ** writable, or SQLITE_ACCESS_READ to test whether a file is at least
  ** readable.
  **
  ** The SQLITE_ACCESS_READ method is currently unused
  */
  assert( flags==SQLITE_ACCESS_EXISTS || flags==SQLITE_ACCESS_READWRITE );

  fsTrace(p, "ACCESS %s\n", zFilename);
  if( th3ioerrSimulate(p, TH3VFS_IOERR_ACCESS) ){
    return SQLITE_IOERR_ACCESS;
  }

  if( flags==SQLITE_ACCESS_READWRITE ){
    /* For testing the temp_store_directory pragma (which is the only
    ** place where SQLITE_ACCESS_READWRITE is used), return true if 
    ** the directory name begins with "/temp/" and false otherwise.
    */
    *pOut = (th3strncmp(zFilename,"/temp/",6)==0);
  }else{
    pFile = findFile(p, zFilename, 0);
    if( pFile==0 ){
      *pOut = 0;
    }else{
      *pOut = (p->zerosizeFilesExist) || (pFile->sz>0);
    }
  }
  return SQLITE_OK;
}

/*
** The SQLite VFS xFullPathname method for th3vfs
*/
static int th3vfsFullPathname(
  sqlite3_vfs *pVfs,     /* The VFS */
  const char *zFilename, /* The filename to expand */
  int nOut,              /* Size of the output buffer */
  char *zOut             /* Write the results here */
){
  th3vfsFSys *p = (th3vfsFSys*)pVfs->pAppData;

  /* EVIDENCE-OF: R-61209-06413 SQLite will always allocate at least
  ** mxPathname+1 bytes for the output buffer xFullPathname.
  */
  assert( nOut>=(TH3VFS_MAX_FILENAME+1) );
  assert( pVfs->mxPathname==TH3VFS_MAX_FILENAME );

  fsTrace(p, "FULLPATH %s\n", zFilename);
  if( th3ioerrSimulate(p, TH3VFS_IOERR_FULLPATHNAME) ){
    return SQLITE_ERROR;
  }
  if( memcmp(zFilename, "[testvfs", 8)==0 ){
    /* Calling xFullPathname multiple times is harmless.  So do not add
    ** multiple prefixes. */
    sqlite3_snprintf(nOut, zOut, "%s", zFilename);
  }else if( sqlite3_uri_parameter(zFilename, "8_3_names")!=0 ){
    sqlite3_snprintf(nOut, zOut, "[testvfs999]%s", zFilename);
  }else{
    sqlite3_snprintf(nOut, zOut, "[testvfs%03d]%s",strlen(zFilename),zFilename);
  }
  return SQLITE_OK;
}

/*
** The SQLite VFS xDlOpen method for th3vfs
*/
static void *th3vfsDlOpen(
  sqlite3_vfs *pVfs,     /* The VFS */
  const char *zFilename  /* The filename to open */
){
  if( th3strcmp(zFilename,"vfs_shared_library")==0 ){
    return (void*)pVfs;
  }
  return 0;
}

/*
** The SQLite VFS xDlError method for th3vfs
*/
static void th3vfsDlError(
  sqlite3_vfs *pVfs,     /* The VFS */
  int nByte,             /* Size of the output buffer */
  char *zErrMsg          /* Write error message here */
){
  sqlite3_snprintf(nByte, zErrMsg, "no such file");
}

/*
** The SQLite VFS xDlSym method for th3vfs
*/
static void (*th3vfsDlSym(
  sqlite3_vfs *pVfs,     /* The VFS */
  void *pHandle,         /* Handle returned by xDlOpen() */
  const char *zSymbol    /* Symbol we are searching for */
))(void){
  assert( pHandle==(void*)pVfs );
  assert( zSymbol!=0 );
  if( th3strcmp(zSymbol, "th3_broken_init")==0 ){
    return (void(*)(void))th3_broken_ext_init;
  }else if( th3strcmp(zSymbol, "sqlite3_extension_init")==0 ){
    return (void(*)(void))th3_normal_ext_init;
  }else if( th3strcmp(zSymbol, "th3_extension_init")==0 ){
    return (void(*)(void))th3_aux_ext_init;
  }
  return (void(*)(void))0;
}

/*
** The SQLite VFS xDlClose method for th3vfs
*/
static void th3vfsDlClose(
  sqlite3_vfs *pVfs,     /* The VFS */
  void *pHandle          /* The handle to close */
){
  assert( pHandle==0 || pHandle==(void*)pVfs );
  return;
}

/*
** The SQLite VFS xRandomness method for th3vfs
*/
int th3_randomness_issued = 0;
static int th3vfsRandomness(
  sqlite3_vfs *pVfs,     /* The VFS */
  int nByte,             /* Number of bytes of randomness desired */
  char *zOut             /* Write the randomness here */
){
  th3_randomness_issued += nByte;
  th3memset(zOut, 0, nByte);
  return SQLITE_OK;
}

/*
** Statistics and controls on calls to th3vfsSleep().
**
** These are not threadsafe and should only be used by tests when
** THREADS are disabled.
*/
static int th3sleepCount = 0;     /* Number of calls to th3vfsSleep() */
static int th3sleepMicrosec = 0;  /* Argument to the most recent call */
static int th3sleepReturn = 0;    /* Value to return from th3vfsSleep() */

/*
** The SQLite VFS xSleep method for th3vfs
*/
static int th3vfsSleep(
  sqlite3_vfs *pVfs,     /* The VFS */
  int microseconds       /* Desired sleep time */
){
  th3sleepCount++;
  th3sleepMicrosec = microseconds;
  return th3sleepReturn;
}

/*
** The SQLite VFS xCurrentTime method for th3vfs
**
** EVIDENCE-OF: R-65415-14215 The xCurrentTimeInt64() method returns, as
** an integer, the Julian Day Number multiplied by 86400000 (the number
** of milliseconds in a 24-hour day).
*/
static int th3vfsCurrentTimeInt64(
  sqlite3_vfs *pVfs,     /* The VFS */
  sqlite3_int64 *piTime  /* Write Julian Day number times 86400000 here */
){
  th3vfsFSys *p = (th3vfsFSys*)pVfs->pAppData;
  *piTime = p->iNow;
  p->nSyscall++;
  return SQLITE_OK;
}
/*
** The SQLite VFS xCurrentTime method for th3vfs
**
** EVIDENCE-OF: R-61562-13487 The xCurrentTime() method returns a Julian
** Day Number for the current date and time as a floating point value.
*/
static int th3vfsCurrentTime(
  sqlite3_vfs *pVfs,     /* The VFS */
  double *prTime         /* Write Julian Day number here */
){
  th3vfsFSys *p = (th3vfsFSys*)pVfs->pAppData;
  *prTime = p->iNow/86400000.0;
  p->nSyscall++;
  return SQLITE_OK;
}

/*
** The SQLite VFS xGetLastError method for th3vfs
*/
static int th3vfsGetLastError(
  sqlite3_vfs *pVfs,     /* The VFS */
  int nByte,             /* Size of output buffer */
  char *zOut             /* Write error message here */
){
  sqlite3_snprintf(nByte, zOut, "unknown error");
  return SQLITE_OK;
}


/*
** Decrement the reference count on a file.  If the reference count
** reaches zero and the file is marked as delete-on-close, then delete
** the file.
*/
static void th3vfsUnrefFile(th3vfsFSys *p, th3vfsFile *pFile){
  pFile->nRef--;
  if( pFile->deleteOnClose && pFile->nRef==0 ){
    destroyFile(p, pFile);
  }
}

/*
** Lock bitmasks for shared-memory.
*/
#define TH3_SHM_WRLCK    0x0001
#define TH3_SHM_CKPTLCK  0x0002
#define TH3_SHM_RCVRLCK  0x0004
#define TH3_SHM_RDLCK    0xfff8

/*
** There used to be a separate xShmOpen method for the VFS, but the
** VFS design was later revised to automatically open shared memory
** when it is first mapped.  
**
** This routine is the original xShmOpen method, which is now called
** as needed from xShmMap.
*/
static int th3vfsShmOpen(
  sqlite3_file *fd       /* Open connection to database file */
){
  th3vfsFd *pDbFd = (th3vfsFd*)fd;
  th3vfsFSys *p = pDbFd->pFsys;
  th3vfsFile *pFile;

  assert( pDbFd->shmOpen==0 );
  pFile = pDbFd->pFile;
  pFile->nShm++;
  p->nSyscall++;
  p->nShmop++;
  assert( pFile->nShmRegion==0 || pFile->nShm>1 );
  fsTrace(p, "SHM-OPEN %s\n", pFile->zFilename);
  if( pFile->readOnly & 2 ){
    const char *zRO = sqlite3_uri_parameter(pDbFd->zOpenName, "readonly_shm");
    if( zRO==0 || th3atoi64(zRO)==0 ) return SQLITE_CANTOPEN;
    pDbFd->readOnly |= 2;
  }
  pDbFd->shmReadLock = pDbFd->shmWriteLock = 0;
  pDbFd->shmOpen = 1;
  return (pDbFd->readOnly & 2) ? SQLITE_READONLY : SQLITE_OK;  
}

/*
** Map a region of shared memory.
*/
static int th3vfsShmMap(
  sqlite3_file *fd,            /* The file associated with shared-memory */
  int iRegion,                 /* Which region to map */
  int szRegion,                /* Size of each region.  (32K bytes) */
  int isWrite,                 /* True to extend size of shared memory */
  volatile void **pp           /* OUT: write mapped shared memory here */
){
  th3vfsFd *pDbFd = (th3vfsFd*)fd;
  th3vfsFSys *p = pDbFd->pFsys;
  th3vfsFile *pFile;
  int i;

  assert( szRegion==32768 );
  p->nSyscall++;
  p->nShmop++;
  if( th3ioerrSimulate(p, TH3VFS_IOERR_SHMMAP) ){
    return SQLITE_IOERR;
  }
  if( pDbFd->shmOpen==0 ){
    int rc = th3vfsShmOpen(fd);
    if( rc ) return rc;
  }
  assert( pDbFd->shmOpen );
  pFile = pDbFd->pFile;
  fsTrace(p, "SHM-MAP %s iRegion=%d isWrite=%d\n",
          pFile->zFilename, iRegion, isWrite);
  if( pFile->nShmRegion<=iRegion ){
    if( isWrite==0 ){
      *pp = 0;
      return SQLITE_OK;
    }
    if( pDbFd->readOnly & 2 ){
      *pp = 0;
      return SQLITE_READONLY;
    }
    pFile->apShm = th3realloc(p->p, pFile->apShm, 
                              (iRegion+1)*sizeof(pFile->apShm[0]));
    for(i=pFile->nShmRegion; i<=iRegion; i++){
      pFile->apShm[i] = th3malloc(p->p, szRegion);
      memset(pFile->apShm[i], 0, szRegion);
    }
    pFile->szShmRegion = szRegion;
    pFile->nShmRegion = iRegion+1;
  }
  *pp = pFile->apShm[iRegion];
  return SQLITE_OK;
}

/*
** Change the locking state
*/
static int th3vfsShmLock(
  sqlite3_file *fd,           /* Database associated with SHM */
  int ofst,                   /* Lock offset */
  int n,                      /* Number of bytes to lock */
  int flags                   /* Describe the locking operation */
){
  th3vfsFd *pDbFd = (th3vfsFd*)fd; /* The database file descriptor */
  th3vfsFSys *p = pDbFd->pFsys;    /* The file system */
  th3vfsFile *pFile = pDbFd->pFile;/* The database file */
  th3vfsFd *pX;                    /* For looping over open files */
  unsigned int lockMask = 0;       /* Mask of lock bits for this request */

  /* Constraints on the SQLite core: */
  assert( ofst>=0 && ofst+n<=SQLITE_SHM_NLOCK );
  assert( n>=1 );
  assert( flags==(SQLITE_SHM_LOCK | SQLITE_SHM_SHARED)
       || flags==(SQLITE_SHM_LOCK | SQLITE_SHM_EXCLUSIVE)
       || flags==(SQLITE_SHM_UNLOCK | SQLITE_SHM_SHARED)
       || flags==(SQLITE_SHM_UNLOCK | SQLITE_SHM_EXCLUSIVE) );
  assert( n==1 || (flags & SQLITE_SHM_EXCLUSIVE)!=0 );

  assert( pDbFd->shmOpen );

  p->nSyscall++;
  p->nShmop++;
  p->nLock++;
  if( (pDbFd->readOnly&2)!=0 && flags==(SQLITE_SHM_LOCK|SQLITE_SHM_EXCLUSIVE) ){
    return SQLITE_BUSY;
  }
  if( (flags & SQLITE_SHM_LOCK)!=0 ){
    /* Simulate a locking I/O error.  This is not really possible on most
    ** systems. */
    if( th3ioerrSimulate(p, TH3VFS_IOERR_SHMLOCK)!=0 ){
      return SQLITE_IOERR_SHMLOCK;
    }
    if( th3ioerrSimulate(p, TH3VFS_IOERR_SHMLOCK_BUSY)!=0 ){
      return SQLITE_BUSY;
    }

    /* Do a memory allocation in order to give an opporunity to have
    ** a simulated OOM error. */
    pX = sqlite3_malloc(sizeof(*pX));
    if( pX==0 ) return SQLITE_NOMEM;
    sqlite3_free(pX);
  }

  /* Mask of bits involved in this lock */
  lockMask = (1<<(ofst+n)) - (1<<ofst);

  /* The unlock case */
  if( flags & SQLITE_SHM_UNLOCK ){
    fsTrace(p, "SHM-UNLOCK %s %03x.  Was: %03x,%03x ",
            pFile->zFilename, lockMask,
            pDbFd->shmWriteLock, pDbFd->shmReadLock);
    pDbFd->shmWriteLock &= ~lockMask;
    pDbFd->shmReadLock &= ~lockMask;
    fsTrace(p, "Becomes: %03x,%03x\n",
            pDbFd->shmWriteLock, pDbFd->shmReadLock);
    return SQLITE_OK;
  }

  /* The shared-lock case */
  if( flags & SQLITE_SHM_SHARED ){
    /* Disallow if any sibling (including ourself) holds an exclusive lock */
    for(pX=p->pOpen; pX; pX=pX->pNext){
      if( pX->pFile!=pFile ) continue;
      if( pX->shmWriteLock & lockMask ){
        fsTrace(p, "SHM-LOCK-SHARED %s %03x blocked by an exclusive %03x\n",
                pFile->zFilename, lockMask, pX->shmWriteLock);
        return SQLITE_BUSY;
      }
    }
    fsTrace(p, "SHM-LOCK-SHARED %s %03x.  Changed %03x to %03x\n",
            pFile->zFilename, lockMask, pDbFd->shmReadLock,
            (pDbFd->shmReadLock|lockMask));
    pDbFd->shmReadLock |= lockMask;
    return SQLITE_OK;
  }

  /* The reset of this procedure is the exclusive lock case */
  assert( flags & SQLITE_SHM_EXCLUSIVE );

  /* Disallow an exclusive if any kind of lock is held by any other */
  for(pX=p->pOpen; pX; pX=pX->pNext){
    if( pX->pFile!=pFile ) continue;
    if( (pX->shmWriteLock & lockMask)!=0 ){
      fsTrace(p, "SHM-LOCK-EXCLUSIVE %s %03x blocked by an exclusive %03x\n",
              pFile->zFilename, lockMask, pX->shmWriteLock);
      return SQLITE_BUSY;
    }
    if( (pX->shmReadLock & lockMask)!=0 ){
      fsTrace(p, "SHM-LOCK-EXCLUSIVE %s %03x blocked by an shared %03x\n",
              pFile->zFilename, lockMask, pX->shmWriteLock);
      return SQLITE_BUSY;
    }
  }
  fsTrace(p, "SHM-LOCK-EXCLUSIVE %s %03x.  Changed %03x to %03x\n",
          pFile->zFilename, lockMask, pDbFd->shmWriteLock,
          (pDbFd->shmWriteLock|lockMask));
  pDbFd->shmWriteLock |= lockMask;
  return SQLITE_OK;
}

/*
** A memory barrier.
*/
static void th3vfsShmBarrier(sqlite3_file *fd){
  th3vfsFd *pDbFd = (th3vfsFd*)fd; /* The database file descriptor */
  pDbFd->pFsys->nShmop++;
  assert( pDbFd->shmOpen );
  return;
}

/*
** Unmap all previously mapped shared-memory segments.  If the
** deleteFlag is true, then also attempt to delete or deallocate
** the underlying shared memory.  If there is no shared-memory
** associated with the open file, then this routine is a harmless
** no-op.
*/
static int th3vfsShmUnmap(
  sqlite3_file *fd,           /* Database associated with the SHM */
  int deleteFlag              /* If true, delete memory after closing */
){
  th3vfsFd *pDbFd = (th3vfsFd*)fd; /* The database file descriptor */
  th3vfsFSys *p = pDbFd->pFsys;    /* The file system */
  th3vfsFile *pFile = pDbFd->pFile;/* The database file */

  /* assert( pDbFd->shmReadLock==0 && pDbFd->shmWriteLock==0 ); */
  p->nSyscall++;
  p->nShmop++;
  if( pDbFd->shmOpen ){
    assert( pFile->nShm>=1 );
    pFile->nShm--;
    if( pFile->nShm==0 ){
      int i;
      for(i=0; i<pFile->nShmRegion; i++){
        th3free(p->p, pFile->apShm[i]);
      }
      th3free(p->p, pFile->apShm);
      pFile->apShm = 0;
      pFile->nShmRegion = 0;
    }
    pDbFd->shmOpen = 0;
  }
  return SQLITE_OK;
}

/*
** The SQLite VFS xClose method for th3vfs
*/
static int th3vfsClose(
  sqlite3_file *pSFile   /* File to close */
){
  th3vfsFd *pFd = (th3vfsFd*)pSFile;
  th3vfsFile *pFile = pFd->pFile;
  th3vfsFSys *p = pFd->pFsys;
  int oldEnable;
  int oldTrace;
  assert( pFile );
  assert( pFd->iVfsFdMagic==TH3VFS_MAGIC_FDOPEN );
  p->nClose++;
  p->nSyscall++;

  /* EVIDENCE-OF: R-49080-64834 SQLite further guarantees that the string
  ** will be valid and unchanged until xClose() is called.
  **
  ** pFd->zOpenName points to the orginal filename string pointer passed
  ** into xOpen().  Make sure it still holds the correct filename.  If
  ** the original string has been freed, memsys2 will have zeroed the
  ** filename so validity is also checked by this comparison.
  */
  assert( pFd->zOpenName==0 || pFile->zFilename[0]==0
             || th3strcmp(pFile->zFilename, pFd->zOpenName)==0 );

  fsTrace(p, "CLOSE %s\n", pFile->zFilename);
  oldEnable = p->ioerr.enable;
  p->ioerr.enable = 0;
  oldTrace = p->trace;
  p->trace = 0;
  th3vfsUnlock(pSFile, 0);
  th3vfsUnrefFile(p, pFile);
  p->ioerr.enable = oldEnable;
  p->trace = oldTrace;
  if( pFd->pPrev ){
    assert( pFd->pPrev->iVfsFdMagic==TH3VFS_MAGIC_FDOPEN );
    pFd->pPrev->pNext = pFd->pNext;
  }else{
    assert( p->pOpen==pFd );
    p->pOpen = pFd->pNext;
  }
  if( pFd->pNext ){
    assert( pFd->pNext->iVfsFdMagic==TH3VFS_MAGIC_FDOPEN );
    pFd->pNext->pPrev = pFd->pPrev;
  }
  th3memset(pFd, 0, sizeof(*pFd));
  return SQLITE_OK;
}

/*
** A place to set a breakpoint for OOM faults in the VFS
*/
static void th3vfsOomFault(void){
  static int cnt = 0;
  cnt++;
}

/*
** The SQLite VFS xRead method for th3vfs
*/
static int th3vfsRead(
  sqlite3_file *pSFile,  /* The file to read from */
  void *pBuf,            /* Write content into this buffer */
  int iAmt,              /* Number of bytes to read */
  sqlite3_int64 iOfst    /* Begin reading at this offset */
){
  th3vfsFd *pFd = (th3vfsFd*)pSFile;
  th3vfsFile *pFile = pFd->pFile;
  th3vfsFSys *p = pFd->pFsys;
  char *zBuf = (char*)pBuf;

  p->nSyscall++;
  fsTrace(p, "READ amt %d ofst %lld file %s\n", iAmt, iOfst, pFile->zFilename);
  assert( pFd->iVfsFdMagic==TH3VFS_MAGIC_FDOPEN );
  if( th3ioerrSimulate(p, TH3VFS_IOERR_READ) ){
    return SQLITE_IOERR_READ;
  }
  if( th3oomStep(2) ){
    th3vfsOomFault();
    return SQLITE_IOERR_NOMEM;
  }
  assert( iOfst>=0 );
  th3memset(pBuf, 0, iAmt);  /* Short reads must zero the buffer */
  while( iAmt>0 ){
    char *zSrc;
    int i, n;
    sqlite3_int64 nxSector;
    i = iOfst/p->szSector;
    nxSector = (i+1)*(sqlite3_int64)p->szSector;
    n = iAmt;
    if( iOfst + n>nxSector ){
      n = nxSector - iOfst;
    }
    if( iOfst+n>pFile->sz ){
      return SQLITE_IOERR_SHORT_READ;
    }
    i = adjustForZerogap(pFile, i);
    /* fsTrace(p, "   ... reading sector %d\n", i); */
    if( i>=0 ){
      zSrc = pFile->apSector[i]->a;
      th3memcpy(zBuf, &zSrc[iOfst%p->szSector], n);
    }else{
      th3memset(zBuf, 0, n);
    }
    iOfst += n;
    iAmt -= n;
    zBuf += n;
    p->nRead += n;
  }
  return SQLITE_OK;
}

/*
** Increase the size of a file to be nSectorNew pages.  Return zero on
** success or nonzero if a malloc failure occurs.
*/
static int increaseFileSize(
  th3vfsFSys *p,          /* The filesystem */
  th3vfsFile *pFile,      /* The file whose size is to increase */
  int nSectorOld,         /* Old size of the file in pages */
  int nSectorNew          /* New size of the file in pages */
){
  th3vfsSector **apSector;
  int szPage, i;

  nSectorOld -= pFile->zerogapCount;
  nSectorNew -= pFile->zerogapCount;
  apSector = th3realloc(p->p, pFile->apSector, nSectorNew*sizeof(apSector[0]));
  if( apSector==0 ){
    return 1;
  }
  szPage = sizeof(th3vfsSector) + p->szSector;
  pFile->apSector = apSector;
  for(i=nSectorOld; i<nSectorNew; i++){
    th3vfsSector *pSector;
    apSector[i] = pSector = th3malloc(p->p, szPage);
    if( pSector==0 ){
      int j;
      for(j=nSectorOld; j<i; j++) th3free(p->p, apSector[j]);
      return 1;
    }
    pSector->pNext = p->pSector;
    if( p->pSector ){
      p->pSector->pPrev = pSector;
    }
    pSector->pPrev = 0;
    p->pSector = pSector;
    pSector->notSynced = 1;
    pSector->idx = i;
    pSector->pFile = pFile;
    p->nNotSynced++;
    th3memset(pSector->a, 0, p->szSector);
  }
  p->nSector += nSectorNew - nSectorOld;
  return 0;
}

/*
** The SQLite VFS xWrite method for th3vfs
*/
static int th3vfsWrite(
  sqlite3_file *pSFile,  /* Write to this file */
  const void *pBuf,      /* Use content from this buffer */
  int iAmt,              /* Number of bytes to write */
  sqlite3_int64 iOfst    /* Begin writing at this offset */
){
  th3vfsFd *pFd = (th3vfsFd*)pSFile;
  th3vfsFile *pFile = pFd->pFile;
  th3vfsFSys *p = pFd->pFsys;
  char *zBuf = (char*)pBuf;
  int safeAppend;

  p->nSyscall++;
  if( pFd->ignoreWrite ){
    fsTrace(p, "WRITE-IGNORED file %s\n", pFile->zFilename);
    return SQLITE_OK;
  }
  fsTrace(p, "WRITE amt %d ofst %lld file %s\n", iAmt, iOfst,pFile->zFilename);
  assert( pFd->iVfsFdMagic==TH3VFS_MAGIC_FDOPEN );

  /* Verify that writes to a database file are page-size and page-aligned */
  assert( (pFd->openFlags & (SQLITE_OPEN_MAIN_DB|
                             SQLITE_OPEN_TEMP_DB|
                             SQLITE_OPEN_TRANSIENT_DB))==0
         || (iAmt>=512 && (iAmt&(iAmt-1))==0 && (iOfst&(iAmt-1))==0) );

  if( pFd->readOnly & 1 ){
    return SQLITE_READONLY;
  }
  if( th3ioerrSimulate(p, TH3VFS_IOERR_WRITE) ){
    return SQLITE_IOERR_WRITE;
  }
  if( th3ioerrSimulate(p, TH3VFS_IOERR_FULL) ){
    return SQLITE_FULL;
  }
  if( th3oomStep(2) ){
    th3vfsOomFault();
    return SQLITE_IOERR_NOMEM;
  }
  assert( iOfst>=0 );
  if( iOfst+iAmt>pFile->sz ){
    int nSectorOld, nSectorNew;

    nSectorOld = (pFile->sz + p->szSector - 1)/p->szSector;
    nSectorNew = (iOfst + iAmt + p->szSector - 1)/p->szSector;
    if( nSectorNew>nSectorOld ){
      if( nSectorNew+p->nSector-nSectorOld > p->mxSector ){
        return SQLITE_FULL;
      }
      if( increaseFileSize(p, pFile, nSectorOld, nSectorNew) ){
        return SQLITE_IOERR_NOMEM;
      }
    }
    if( pFile->sz != iOfst+iAmt && pFile->notSynced==0 ){
      pFile->notSynced = 1;
      p->nNotSynced++;
    }
    pFile->sz = iOfst + iAmt;
  }
  safeAppend = p->isSafeAppend;
  while( iAmt>0 ){
    int iPage, iPgOfst, n;
    iPage = iOfst/p->szSector;
    iPgOfst = iOfst % p->szSector;
    n = iAmt;
    if( iPgOfst+n > p->szSector ){
      n = p->szSector - iPgOfst;
    }
    iPage = adjustForZerogap(pFile, iPage);
    if( iPage>=0 ){
      th3vfsSector *pSector = pFile->apSector[iPage];
      if( pSector->notSynced==0 && (!safeAppend || iOfst<pFile->szSync) ){
        pSector->notSynced = 1;
        p->nNotSynced++;
      }
      /* fsTrace(p, "  writing sector %d\n", iPage); */
      th3memcpy(&pSector->a[iPgOfst], zBuf, n);
    }
    iAmt -= n;
    zBuf += n;
    iOfst += n;
    p->nWrite += n;
  }
  decrSnapshotCnt(p, TH3VFS_IOERR_WRITE);
  return SQLITE_OK;
}

/*
** The SQLite VFS xTruncate method for th3vfs
*/
static int th3vfsTruncate(
  sqlite3_file *pSFile, /* File to be truncated */
  sqlite3_int64 size    /* New size */
){
  th3vfsFd *pFd = (th3vfsFd*)pSFile;
  th3vfsFile *pFile = pFd->pFile;
  th3vfsFSys *p = pFd->pFsys;

  p->nSyscall++;
  if( pFd->ignoreWrite ){
    fsTrace(p, "TRUNCATE-IGNORED file %s\n", pFile->zFilename);
    return SQLITE_OK;
  }
  fsTrace(p, "TRUNCATE %lld->%lld file %s\n", pFile->sz, size,pFile->zFilename);
  assert( pFd->iVfsFdMagic==TH3VFS_MAGIC_FDOPEN );
  if( size>pFile->sz || size<0 ){
    return SQLITE_IOERR_TRUNCATE;
  }
  if( size<pFile->sz && (p->noTruncate==0 || size==0) ){
    if( th3ioerrSimulate(p, TH3VFS_IOERR_TRUNCATE) ){
      return SQLITE_IOERR_TRUNCATE;
    }
    truncateFile(p, pFile, size);
    p->nTruncate++;
    decrSnapshotCnt(p, TH3VFS_IOERR_TRUNCATE);
  }
  return SQLITE_OK;
}
  

/*
** The SQLite VFS xSync method for th3vfs
*/
static int th3vfsSync(
  sqlite3_file *pSFile, /* File to by synchronized */
  int flags
){
  th3vfsFd *pFd = (th3vfsFd*)pSFile;
  th3vfsFile *pFile = pFd->pFile;
  th3vfsFSys *p = pFd->pFsys;
  int i;
  int nSector;

  fsTrace(p, "SYNC %s\n", pFile->zFilename);
  assert( pFd->iVfsFdMagic==TH3VFS_MAGIC_FDOPEN );
  if( pFd->readOnly & 1 ){
    return SQLITE_READONLY;
  }
  if( th3ioerrSimulate(p, TH3VFS_IOERR_SYNC) ){
    return SQLITE_IOERR_FSYNC;
  }
  if( th3ioerrSimulate(p, TH3VFS_IOERR_FULL) ){
    return SQLITE_FULL;
  }
  if( th3oomStep(2) ){
    th3vfsOomFault();
    return SQLITE_IOERR_NOMEM;
  }
  th3vfsValidDatabase(p->p, pFile);
  nSector = (pFile->sz + p->szSector - 1)/p->szSector;
  nSector = adjustForZerogap(pFile, nSector);
  for(i=0; i<nSector; i++){
    th3vfsSector *pSector = pFile->apSector[i];
    assert( pSector->pFile==pFile );
    assert( pSector->idx==i );
    if( pSector->notSynced ){
      pSector->notSynced = 0;
      p->nNotSynced--;
    }
  }
  if( pFile->notSynced ){
    pFile->notSynced = 0;
    p->nNotSynced--;
  }
  assert( p->nNotSynced>=0 );
  pFile->szSync = pFile->sz;
  p->nSync++;
  p->nSyscall++;
  if( (flags&0xf)==SQLITE_SYNC_FULL ) p->nFullSync++;
  if( flags & SQLITE_SYNC_DATAONLY ) p->nDataSync++;
  decrSnapshotCnt(p, TH3VFS_IOERR_SYNC);
  return SQLITE_OK;
}

/*
** The SQLite VFS xFileSize method for th3vfs
*/
static int th3vfsFileSize(
  sqlite3_file *pSFile, /* File to be sized */
  sqlite3_int64 *pSize  /* Write the size here */
){
  th3vfsFd *pFd = (th3vfsFd*)pSFile;
  th3vfsFile *pFile = pFd->pFile;
  th3vfsFSys *p = pFd->pFsys;

  p->nSyscall++;
  assert( pFd->iVfsFdMagic==TH3VFS_MAGIC_FDOPEN );
  fsTrace(p, "FILESIZE %s = %lld\n", pFile->zFilename, pFile->sz);
  if( th3ioerrSimulate(p, TH3VFS_IOERR_FILESIZE) ){
    return SQLITE_IOERR_FSTAT;
  }
  if( th3oomStep(2) ){
    th3vfsOomFault();
    return SQLITE_IOERR_NOMEM;
  }
  *pSize = pFile->sz;
  return SQLITE_OK;
}

/*
** The SQLite VFS xLock method for th3vfs
*/
static int th3vfsLock(
  sqlite3_file *pSFile, /* File to be locked */
  int newLock           /* Increase lock to this level */
){
  th3vfsFd *pFd = (th3vfsFd*)pSFile;
  th3vfsFile *pFile = pFd->pFile;
  int rc = SQLITE_OK;
  th3vfsFSys *p = pFd->pFsys;

  p->nSyscall++;
  p->nLock++;
  assert( pFd->iVfsFdMagic==TH3VFS_MAGIC_FDOPEN );
  fsTrace(p, "LOCK level %d was %d file %s\n",
              newLock, pFd->fileLock, pFile->zFilename);
  if( th3ioerrSimulate(p, TH3VFS_IOERR_LOCK) ){
    return SQLITE_IOERR;
  }
  if( th3oomStep(2) ){
    th3vfsOomFault();
    return SQLITE_IOERR_NOMEM;
  }
  if( newLock<=pFd->fileLock ){
    return SQLITE_OK;
  }
  assert( newLock==SQLITE_LOCK_SHARED 
          || newLock==SQLITE_LOCK_RESERVED
          || newLock==SQLITE_LOCK_EXCLUSIVE );
  if( pFile->mxLock>=SQLITE_LOCK_PENDING
   && pFd->fileLock<=SQLITE_LOCK_SHARED
  ){
    return SQLITE_BUSY;
  }else if( pFd->fileLock<SQLITE_LOCK_SHARED ){
    pFile->nReadLock++;
    pFd->fileLock = SQLITE_LOCK_SHARED;
    if( pFile->mxLock<SQLITE_LOCK_SHARED ){
      pFile->mxLock = SQLITE_LOCK_SHARED;
    }
  }
  if( newLock>=SQLITE_LOCK_RESERVED ){
    if( pFd->fileLock<=SQLITE_LOCK_SHARED
        && pFile->mxLock>=SQLITE_LOCK_RESERVED ){
      return SQLITE_BUSY;
    }
    if( newLock==SQLITE_LOCK_EXCLUSIVE && pFile->nReadLock>1 ){
      newLock = SQLITE_LOCK_PENDING;
      rc = SQLITE_BUSY;
    }
    pFd->fileLock = pFile->mxLock = newLock;
  }
  return rc;   
}

/*
** Change the schema cookie in the given file.  Used to stress the
** automatic reprepare mechanism.  See the TH3_FCNTL_SET_AUTOSCHEMA
** verb for th3vfsFileControl().
*/
static void th3vfsChangeSchemaCookie(th3vfsFile *pFile){
  if( pFile->sz>=48 ){
    pFile->apSector[0]->a[25]++;
    pFile->apSector[0]->a[41]++;
  }
}

/*
** The SQLite VFS xUnlock method for th3vfs
*/
static int th3vfsUnlock(
  sqlite3_file *pSFile, /* File to be unlocked */
  int newLock           /* Reduce lock to this level */
){
  th3vfsFd *pFd = (th3vfsFd*)pSFile;
  th3vfsFile *pFile = pFd->pFile;
  th3vfsFSys *p = pFd->pFsys;

  p->nSyscall++;
  p->nLock++;
  assert( pFd->iVfsFdMagic==TH3VFS_MAGIC_FDOPEN );
  assert( newLock==SQLITE_LOCK_NONE || newLock==SQLITE_LOCK_SHARED );
  fsTrace(p, "UNLOCK level %d was %d file %s\n",
             newLock, pFd->fileLock, pFile->zFilename);
  if( th3ioerrSimulate(p, TH3VFS_IOERR_UNLOCK) ){
    return SQLITE_IOERR_UNLOCK;
  }
  if( newLock>=pFd->fileLock ){
    return SQLITE_OK;
  }
  if( newLock==SQLITE_LOCK_NONE ){
    assert( pFile->nReadLock>0 );
    pFile->nReadLock--;
    if( pFile->nReadLock==0 && pFile->autoSchema && pFile->sz>48 ){
      pFile->autoSchema--;
      th3vfsChangeSchemaCookie(pFile);
    }
  }
  if( pFd->fileLock>SQLITE_LOCK_SHARED ){
    assert( pFd->fileLock==pFile->mxLock );
    pFile->mxLock = SQLITE_LOCK_SHARED;
  }
  pFd->fileLock = newLock;
  if( pFile->nReadLock==0 ){
    pFile->mxLock = SQLITE_LOCK_NONE;
  }
  return SQLITE_OK;
}

/*
** The SQLite VFS xCheckReservedLock method for th3vfs
*/
static int th3vfsCheckReservedLock(
  sqlite3_file *pSFile,  /* Check the lock status if this file */
  int *pResOut           /* Write results here */
){
  th3vfsFd *pFd = (th3vfsFd*)pSFile;
  th3vfsFile *pFile = pFd->pFile;
  th3vfsFSys *p = pFd->pFsys;

  p->nSyscall++;
  assert( pFd->iVfsFdMagic==TH3VFS_MAGIC_FDOPEN );
  fsTrace(p, "CHECKRESERVEDLOCK %s = %d\n", pFile->zFilename,
              pFile->mxLock>=SQLITE_LOCK_RESERVED);
  if( th3ioerrSimulate(p, TH3VFS_IOERR_CHECKRESERVEDLOCK) ){
    return SQLITE_IOERR_CHECKRESERVEDLOCK;
  }
  if( th3oomStep(2) ){
    th3vfsOomFault();
    return SQLITE_IOERR_NOMEM;
  }
  *pResOut = pFile->mxLock>=SQLITE_LOCK_RESERVED;
  return SQLITE_OK;
}


/*
** Append a gap of zeros onto the end of a file.  The gap cannot be
** removed except by deleting the file.
**
** This routine only works with the VFS. Do not try to use it with the
** native filesystem.  If you do, it will segfault.
**
** This interface is used to create massive files (multiple gigabytes)
** without consuming much memory, in order to test the operation of
** SQLite on large files.
*/
void th3fileAppendZeros(th3state *p, int id, sqlite3_int64 newSize){
  th3vfsFile *pFile;
  th3vfsFd *pFd;
  th3vfsFSys *pFsys;

  assert( id>=0 && id<TH3_MAX_FILE );
  pFd = (th3vfsFd*)p->apFile[id];
  assert( pFd->iVfsFdMagic==TH3VFS_MAGIC_FDOPEN );
  pFile = pFd->pFile;
  pFsys = pFd->pFsys;
  assert( pFile->zerogapStart==0 && pFile->zerogapCount==0 );
  pFile->sz = (pFile->sz + pFsys->szSector - 1) & ~(pFsys->szSector-1);
  pFile->zerogapStart = pFile->sz/pFsys->szSector + 1;
  pFile->zerogapCount = (newSize - pFile->sz)/pFsys->szSector;
  pFile->sz += pFile->zerogapCount*(sqlite3_int64)pFsys->szSector;
  if( pFile->sz<newSize ){
    int nSector = pFile->sz/pFsys->szSector - pFile->zerogapCount;
    increaseFileSize(pFsys, pFile, nSector, nSector+1);
    pFile->sz = newSize;
  }
}

/*
** The SQLite VFS xFileControl method for th3vfs
*/
static int th3vfsFileControl(
  sqlite3_file *pSFile, /* Control this file */
  int op,               /* Opcode */
  void *pArg            /* Argument */
){
  th3vfsFd *pFd = (th3vfsFd*)pSFile;
  int rc = SQLITE_NOTFOUND;
  assert( pFd->iVfsFdMagic==TH3VFS_MAGIC_FDOPEN );
  switch( op ){
    case SQLITE_FCNTL_LOCKSTATE: {
       *(int*)pArg = pFd->fileLock;
       rc = SQLITE_OK;
       break;
    }

    case SQLITE_FCNTL_SYNC_OMITTED: {
       rc = SQLITE_OK;
       break;
    }

    /* The custom SET_READONLY action makes a file read-only for
    ** testing purposes.
    */
#define TH3_FCNTL_SET_READONLY 1000001
    case TH3_FCNTL_SET_READONLY: {
       pFd->pFile->readOnly = *(int*)pArg;
       rc = SQLITE_OK;
       break;
    }

    /* The SET_AUTOSCHEMA causes the filesystem to change the schema
    ** cookie whenever the file is unlocked.  This can be used to
    ** stress the automatic prepared statment recompile mechanism
    ** in SQLite. */
#define TH3_FCNTL_SET_AUTOSCHEMA 1000002
    case TH3_FCNTL_SET_AUTOSCHEMA: {
       pFd->pFile->autoSchema = *(int*)pArg;
       th3vfsChangeSchemaCookie(pFd->pFile);
       rc = SQLITE_OK;
       break;
    }

    /* The custom SET_IGNOREWRITE action makes a file ignore all writes
    ** for testing purposes.
    */
#define TH3_FCNTL_SET_IGNOREWRITE 1000003
    case TH3_FCNTL_SET_IGNOREWRITE: {
       pFd->ignoreWrite = 1;
       rc = SQLITE_OK;
       break;
    }

    /* The custom GET_TH3VFSFD action returns a pointer to the underlying
    ** th3vfsFd object for a database.
    */
#define TH3_FCNTL_GET_TH3VFSFD 1000004
    case TH3_FCNTL_GET_TH3VFSFD: {
       *(th3vfsFd**)pArg = pFd;
       rc = SQLITE_OK;
       break;
    }

  }
  return rc;
}

/*
** The SQLite VFS xSectorSize method for th3vfs
*/
static int th3vfsSectorSize(
  sqlite3_file *pSFile  /* Get sector size of volume hold this file */
){
  th3vfsFd *pFd = (th3vfsFd*)pSFile;
  th3vfsFSys *p = pFd->pFsys;
  assert( pFd->iVfsFdMagic==TH3VFS_MAGIC_FDOPEN );
  return p->szSector;
}

/*
** The SQLite VFS xDeviceCharacteristics method for th3vfs
*/
static int th3vfsDeviceCharacteristics(
  sqlite3_file *pSFile  /* Get characteristics of volume hold this file */
){
  th3vfsFd *pFd = (th3vfsFd*)pSFile;
  th3vfsFSys *p = pFd->pFsys;
  assert( pFd->iVfsFdMagic==TH3VFS_MAGIC_FDOPEN );
  return p->devChar;
}

/*
** Copy all content of filesystem pFrom over into pTo.  Return
** the number of errors.
*/
static int th3filesystemCopy(th3vfsFSys *pTo, th3vfsFSys *pFrom){
  th3vfsFile *pFile;
  th3vfsSector *pSector;
  int nNotSynced = 0;
  int trace = pTo->trace;

  assert( pTo->nSector==0 );
  th3memcpy(pTo, pFrom, sizeof(*pTo));
  pTo->trace = trace;
  pTo->pFile = 0;
  pTo->nSector = 0;
  pTo->pSector = 0;
  pTo->pOpen = 0;

  for(pFile=pFrom->pFile; pFile; pFile=pFile->pNext){
    th3vfsFile *pNewFile;
    int nNewPage, i;

    if( pFile->deleteOnClose ) continue;
    pNewFile = findFile(pTo, pFile->zFilename, 1);
    if( pNewFile==0 ){
      th3filesystemReset(pTo);
      return 1;
    }
    nNewPage = (pFile->sz + pTo->szSector - 1)/pTo->szSector
                - pFile->zerogapCount;
    increaseFileSize(pTo, pNewFile, 0, nNewPage);
    for(i=0; i<nNewPage; i++){
      th3vfsSector *pNew = pNewFile->apSector[i];
      th3vfsSector *pOld = pFile->apSector[i];
      pNew->notSynced = pOld->notSynced;
      th3memcpy(pNew->a, pOld->a, pTo->szSector);
    }
    pNewFile->sz = pFile->sz;
    pNewFile->zerogapStart = pFile->zerogapStart;
    pNewFile->zerogapCount = pFile->zerogapCount;
    pNewFile->szSync = pFile->szSync;
    pNewFile->notSynced = pFile->notSynced;
    pNewFile->deleteOnClose = 0;
    pNewFile->isExclusive = 0;
    pNewFile->readOnly = pFile->readOnly;
    pNewFile->nReadLock = 0;
    pNewFile->mxLock = 0;
    pNewFile->apShm = 0;
    pNewFile->nShmRegion = 0;
  }

  /* Count the number of unsynced sectors.
  */
  for(pSector=pTo->pSector; pSector; pSector=pSector->pNext){
    if( pSector->notSynced ) nNotSynced++;
  }
  for(pFile=pTo->pFile; pFile; pFile=pFile->pNext){
    if( pFile->notSynced ) nNotSynced++;
  }
  pTo->nNotSynced = nNotSynced;

  return 0;
}

/*
** Make a snapshot of the current state of the MEMVFS.
*/
int th3filesystemSnapshot(th3state *p){
  th3filesystemReset(&p->fsysSS);
  fsTrace(&p->fsysTest, "SNAPSHOT\n");
  return th3filesystemCopy(&p->fsysSS, &p->fsysTest);
}

/*
** Revert the state of the MEMVFS back to the snapshot.  There must
** be no open files in order for this to work.
**
** Return the number of errors.
*/
int th3filesystemRevert(th3state *p){
  int rc;
  int t1, t2;
  struct th3ioerrInfo ioerrInfo;

  if( p->fsysTest.pOpen!=0 ) return 1;
  th3filesystemReset(&p->fsysTest);
  fsTrace(&p->fsysTest, "REVERT\n");
  t1 = p->fsysTest.trace;
  p->fsysTest.trace = 0;
  t2 = p->fsysSS.trace;
  p->fsysSS.trace = 0;
  ioerrInfo = p->fsysTest.ioerr;
  rc = th3filesystemCopy(&p->fsysTest, &p->fsysSS);
  p->fsysTest.trace = t1;
  p->fsysSS.trace = t2;
  p->fsysTest.ioerr = ioerrInfo;
  return t1;
}

/*
** Read a single byte at a given offset from in a file.
*/
static int th3testvfsReadByte(
  th3vfsFSys *pFSys,       /* The file system */
  th3vfsFile *pFile,       /* The file to read from */
  sqlite3_int64 i          /* Offset of the byte to be read */
){
  int iPage, iOfst;
  if( i<0 || i>=pFile->sz ) return 0;
  iPage = i/pFSys->szSector;
  iOfst = i%pFSys->szSector;
  iPage = adjustForZerogap(pFile, iPage);
  return iPage>=0 ? pFile->apSector[iPage]->a[iOfst] & 0xff : 0;
}

/*
** Read a single 16-bit or 32-bit integer from the file.
*/
static int th3testvfsReadInt16(
  th3vfsFSys *pFSys,       /* The file system */
  th3vfsFile *pFile,       /* The file to read from */
  sqlite3_int64 i          /* Offset of the int16 to be read */
){
  int x;
  x = th3testvfsReadByte(pFSys, pFile, i);
  x <<= 8;
  x |= th3testvfsReadByte(pFSys, pFile, i+1);
  return x;
}
static int th3testvfsReadInt32(
  th3vfsFSys *pFSys,       /* The file system */
  th3vfsFile *pFile,       /* The file to read from */
  sqlite3_int64 i          /* Offset of the int32 to be read */
){
  int x;
  x = th3testvfsReadInt16(pFSys, pFile, i);
  x <<= 16;
  x |= th3testvfsReadInt16(pFSys, pFile, i+2);
  return x;
}

/*
** Read a portion of a file in the testVFS.
** Return the number of bytes read.
*/
int th3testvfsRead(
  th3state *p,               /* The test thread doing the reading */
  const char *zFilename,     /* Name of file from which to read */
  sqlite3_int64 iStart,      /* Begin reading at this offset into the file */
  int n,                     /* Read this many bytes */
  char *pBuf                 /* Store the bytes in this buffer */
){
  th3vfsFSys *pFSys = &p->fsysTest;
  th3vfsFile *pFile;
  sqlite3_int64 i;
  
  pFile = findFile(pFSys, zFilename, 0);
  if( pFile==0 ) return 0;
  if( pFile->sz <= iStart ) return 0;
  if( pFile->sz <= iStart + n ) n = pFile->sz - iStart;
  for(i=0; i<n; i++){
    pBuf[i] = th3testvfsReadByte(pFSys, pFile, iStart+i);
  }
  return i;
}

/*
** Search a test_vfs file for the given byte sequence.  Return the
** index into the file of that sequence.  Return -1 if not found.
*/
int th3testvfsSearch(
  th3state *p,               /* The test thread doing the reading */
  th3vfsFSys *pFSys,         /* The filesystem */
  th3vfsFile *pFile,         /* The file to search */
  int nByte,                 /* Size of the search pattern */
  char *pByte                /* Byte pattern to search for */
){
  int mx;
  int i, j;
  char c;
  
  if( nByte<=0 ){
    th3print(p, "**** bad call to th3testvfsSearch() ****\n");
    return -1;
  }
  c = pByte[0];
  mx = pFile->sz - nByte + 1;
  for(i=0; i<mx; i++){
    if( th3testvfsReadByte(pFSys, pFile, i)==c ){
      for(j=1; j<nByte; j++){
        if( th3testvfsReadByte(pFSys, pFile, i+j)!=pByte[j] ) break;
      }
      if( j==nByte ) return i;
    }
  }
  return -1;
}


/*
** Write a single byte into a file.
*/
static void th3testvfsWriteByte(
  th3vfsFSys *pFSys,      /* Filesystem */
  th3vfsFile *pFile,      /* The file */
  sqlite3_int64 i,        /* Offset of the byte to write */
  char c                  /* The byte to be written */
){
  int iPage, iOfst;
  if( i>=0 && i<pFile->sz ){
    iPage = i/pFSys->szSector;
    iOfst = i%pFSys->szSector;
    iPage = adjustForZerogap(pFile, iPage);
    if( iPage>=0 ) pFile->apSector[iPage]->a[iOfst] = c;
  }
}

/*
** Write a single 16-bit or 32-bit integer into a file.
*/
static void th3testvfsWriteInt16(
  th3vfsFSys *pFSys,      /* Filesystem */
  th3vfsFile *pFile,      /* The file */
  sqlite3_int64 i,        /* Offset of the byte to write */
  int v                   /* The int16 to be written */
){
  th3testvfsWriteByte(pFSys, pFile, i, (v>>8)&0xff);
  th3testvfsWriteByte(pFSys, pFile, i+1, v&0xff);
}
static void th3testvfsWriteInt32(
  th3vfsFSys *pFSys,      /* Filesystem */
  th3vfsFile *pFile,      /* The file */
  sqlite3_int64 i,        /* Offset of the byte to write */
  int v                   /* The int32 to be written */
){
  th3testvfsWriteInt16(pFSys, pFile, i, (v>>16)&0xffff);
  th3testvfsWriteInt16(pFSys, pFile, i+2, v&0xffff);
}

/*
** Write a portion of a file in the testVFS.  The write will not change
** the size of the file.  Only existing portions of the file may be
** overwritte.
**
** Return the number of bytes written.
*/
int th3testvfsWrite(
  th3state *p,               /* The test thread doing the writing */
  const char *zFilename,     /* Name of file from which to write */
  sqlite3_int64 iStart,      /* Begin writing at this offset into the file */
  int n,                     /* Write this many bytes */
  const char *pBuf           /* Take bytes written from this buffer */
){
  th3vfsFSys *pFSys = &p->fsysTest;
  th3vfsFile *pFile;
  sqlite3_int64 i;
  
  pFile = findFile(pFSys, zFilename, 0);
  if( pFile==0 ) return 0;
  if( pFile->sz <= iStart ) return 0;
  if( pFile->sz <= iStart + n ) n = pFile->sz - iStart;
  for(i=0; i<n; i++){
    th3testvfsWriteByte(pFSys, pFile, iStart+i, pBuf[i]);
  }
  return i;
}

/*
** This is the tokenizer for th3testvfsEdit().  Extract a single
** token from the string.  Return a pointer to the start of the token
** and the length of the token.  Return a NULL pointer and zero length
** at end-of-file.
*/
static void th3testvfsEdit_GetToken(
  const char **pzIn,  /* String from which to pull token.  Start at zIn[0] */
  int *pnIn,          /* Characters in zIn.  zIn is not zero-terminated */
  const char **pzOut, /* Write start of token here.  Write 0 on EOF */
  int *pnOut          /* Write length of token here.  Write 0 on EOF */
){
  int i;
  int n = *pnIn;
  const char *z = *pzIn;
  *pzOut = 0;
  *pnOut = 0;
  while( n ){
    if( th3isspace(z[0]) ){
      n--;
      z++;
      continue;
    }
    if( z[0]=='#' || (z[0]=='-' && z[1]=='-') ){
      for(i=1; i<n && z[i]!='\n'; i++){}
      if( i<n && z[i]=='\n' ){ i++; }
      z += i;
      n -= i;
      continue;
    }
    *pzOut = z;
    for(i=1; i<n && !th3isspace(z[i]); i++){}
    *pnOut = i;
    *pnIn -= (z - *pzIn) + i;
    *pzIn = &z[i];
    n = 0;
  }
}

/*
** Transform a token into an integer.  If the token is the name of a BVS
** variable, then use the value of that variable.
*/
static sqlite3_int64 th3testvfsEdit_GetInt(
  th3state *p,       /* Testing context.  Needed for BVS access */
  const char **pz,   /* Extract integer token from this script */
  int *pn            /* Length of the script */
){
  int i;
  const char *z;
  int n;
  th3testvfsEdit_GetToken(pz, pn, &z, &n);
  if( z==0 ) return 0;
  for(i=0; i<TH3_N_BVS; i++){
    th3var *pVar = &p->aVar[i];
    if( pVar->zName
     && (pVar->eType==TH3_BIND_TEXT || pVar->eType==TH3_BIND_INT
             || pVar->eType==TH3_BIND_INT64)
     && memcmp(pVar->zName, z, n)==0
     && pVar->zName[n]==0
    ){
      if( pVar->eType==TH3_BIND_TEXT ){
        return th3atoi64(pVar->u.b.z);
      }else{
        return pVar->u.i;
      }
    }
  }
  return th3atoi64(z);
}

/* Forward declarations */
int th3fileDelete(th3state *p, const char *zFilename);
int th3testpcacheCorrupt(sqlite3_int64 iOffset, int iVal);

/*
** Read and evaluate a script that specifies edits to be made to a file.
** The script consists of keywords separated by whitespace.  The first
** keyword is a verb.  There is zero or one argument depending on the 
** verb.
**
**    seek OFFSET     # Seek to an absolute offset.
**    move AMT        # Move by a number of bytes
**    end             # move to the end of the file
**    tell            # write cursor location into p->zResult
**    write HEX       # store hex content and advance cursor
**    xor HEX         # XOR content and advance the cursor
**    write8 INT      # Convert to 8-bit integer and write. advance cursor
**    write16 INT     # Convert to 16-bit integer and write. advance cursor
**    write32 INT     # convert to 32-bit integer and write. advance cursor
**    alt_pcache HEX  # Write hex content in ALT_PCACHE
**    alt_pcache16 INT # Write a 16-bit integer into the ALT_PCACHE.
**    read32_shm      # Read a 32-bit integer from shared memory
**    write32_shm INT # Write a 32-bit integer into shared memory
**    write16_shm V CNT INCR  # Write CNT copies of INT, incrementing by INCR
**    truncate INT    # truncate the file to the specified size
**    extend INT      # increase the size of the file to INT bytes
**    read COUNT      # read COUNT bytes as hex into p->zResult. advance cursor
**    read8           # read 8-bit integer into p->zResult. advance cursor
**    read16          # read 16-bit integer into p->zResult. advance cursor
**    read32          # read 32-bit integer into p->zResult. advance cursor
**    add8 INT        # Add INT to a 8-bit integer.  advance the cursor
**    add16 INT       # Add INT to a 16-bit integer.  advance the cursor
**    add32 INT       # Add INT to a 32-bit integer.  advance the cursor
**    incr-schema     # Increment the 32-bit schema cookie at offset 40 
**    incr-chng       # Increment the 32-bit change counter at offset 24
**    store VAR       # Store p->zResult in VAR and reset p->zResult
**    delete          # Delete the file.  All subsequent text is ignored 
**    search HEX      # Return index of context HEX or -1 if not found 
**
** Arguments may be BVS variables (elements of p->aVar[]) or literals.
** The "#" character begins a comment which extends to the end of the
** line.
**
** Unless the read32_shm or write32_shm operators are used,
** this routine will zero the headers of both the WAL and the
** wal-index in order to force the database file (being edited) to be the
** authoritative content so that the edits made by this script are not
** overridden by a subsequent checkpoint.
*/
void th3testvfsEdit(
  th3state *p,           /* The test stream doing the editing. */
  const char *zFile,     /* Name of the file to be edited. */
  int nScript,           /* Length of the script.  May be -1. */
  const char *zScript    /* The edit script */
){
  th3vfsFSys *pFSys = &p->fsysTest;  /* Filesystem containing file to edit */
  th3vfsFile *pFile;                 /* The file to be edited */
  sqlite3_int64 iCursor = 0;         /* Cursor location within the file */
  const char *zToken;                /* Next token of edit script */
  int nToken;                        /* Length of zToken in characters */
  sqlite3_int64 v;                   /* Integer value of a token */
  int i;                             /* Loop counter */
  char c;                            /* Byte value for read or insert */
  char *zBuf;                        /* General purpose string buffer */
  int usedShm = 0;                   /* True if a SHM operator was used */
  int fileDeleted = 0;               /* True if the file is deleted */

  pFile = findFile(pFSys, zFile, 0);
  if( pFile==0 ){
    th3testAppendResultTerm(p, 
       th3format(p, "ERROR: cannot find file \"%s\"", zFile)
    );
    return;
  }
  if( nScript<0 ) nScript = strlen(zScript);

 
  while( 1 ){
    th3testvfsEdit_GetToken(&zScript, &nScript, &zToken, &nToken);
    if( zToken==0 ) break;
    if( nToken==4 && memcmp(zToken, "seek", 4)==0 ){
      iCursor = th3testvfsEdit_GetInt(p, &zScript, &nScript);
    }else if( nToken==4 && memcmp(zToken, "move", 4)==0 ){
      iCursor += th3testvfsEdit_GetInt(p, &zScript, &nScript);
    }else if( nToken==3 && memcmp(zToken, "end", 3)==0 ){
      iCursor = pFile->sz;
    }else if( nToken==4 && memcmp(zToken, "tell", 4)==0 ){
      th3testAppendResultTerm(p, th3format(p, "%d", (int)iCursor));
    }else if( nToken==5 && memcmp(zToken, "write", 5)==0 ){
      th3testvfsEdit_GetToken(&zScript, &nScript, &zToken, &nToken);
      while( th3getHexByte(&zToken, &nToken, &c) ){
        th3testvfsWriteByte(pFSys, pFile, iCursor++, c);
      }
    }else if( nToken==3 && memcmp(zToken, "xor", 3)==0 ){
      th3testvfsEdit_GetToken(&zScript, &nScript, &zToken, &nToken);
      while( th3getHexByte(&zToken, &nToken, &c) ){
        char v = th3testvfsReadByte(pFSys, pFile, iCursor);
        th3testvfsWriteByte(pFSys, pFile, iCursor++, c^v);
      }
    }else if( nToken==10 && memcmp(zToken, "alt_pcache", 10)==0 ){
      th3testvfsEdit_GetToken(&zScript, &nScript, &zToken, &nToken);
      for(i=0; th3getHexByte(&zToken, &nToken, &c); i++){
        if( th3testpcacheCorrupt(iCursor + i, c) ){
          th3testAppendResultTerm(p, "ERROR: page not in cache");
          break;
        }
      }
    }else if( nToken==6 && memcmp(zToken, "write8", 6)==0 ){
      v = th3testvfsEdit_GetInt(p, &zScript, &nScript);
      th3testvfsWriteByte(pFSys, pFile, iCursor, (char)v);
      iCursor++;
    }else if( nToken==7 && memcmp(zToken, "write16", 7)==0 ){
      v = th3testvfsEdit_GetInt(p, &zScript, &nScript);
      th3testvfsWriteInt16(pFSys, pFile, iCursor, (int)v);
      iCursor += 2;
    }else if( nToken==12 && memcmp(zToken, "alt_pcache16", 12)==0 ){
      v = th3testvfsEdit_GetInt(p, &zScript, &nScript);
      if( th3testpcacheCorrupt(iCursor, (v>>8)&0xff)
       || th3testpcacheCorrupt(iCursor+1, v&0xff) 
      ){
        th3testAppendResultTerm(p, "ERROR: page not in cache");
      }        
      iCursor += 2;
    }else if( nToken==7 && memcmp(zToken, "write32", 7)==0 ){
      v = th3testvfsEdit_GetInt(p, &zScript, &nScript);
      th3testvfsWriteInt32(pFSys, pFile, iCursor, (int)v);
      iCursor += 4;
    }else if( nToken==8 && memcmp(zToken, "truncate", 8)==0 ){
      v = th3testvfsEdit_GetInt(p, &zScript, &nScript);
      truncateFile(pFSys, pFile, v);
    }else if( nToken==6 && memcmp(zToken, "extend", 6)==0 ){
      v = th3testvfsEdit_GetInt(p, &zScript, &nScript);
      extendFile(pFSys, pFile, v);
    }else if( nToken==4 && memcmp(zToken, "read", 4)==0 ){
      v = th3testvfsEdit_GetInt(p, &zScript, &nScript);
      if( v<0 || v>=200 ){
        th3testAppendResultTerm(p, "ERROR: read is too big");
        break;
      }
      zBuf = th3malloc(p, 2*v+1);
      for(i=0; i<v; i++){
        c = th3testvfsReadByte(pFSys, pFile, iCursor++);
        zBuf[i*2] = "0123456789abcdef"[(c>>4)&0xf];
        zBuf[i*2+1] = "0123456789abcdef"[c&0xf];
      }
      zBuf[i*2] = 0;
      th3testAppendResultTerm(p, zBuf);
      th3free(p, zBuf);
    }else if( nToken==5 && memcmp(zToken, "read8", 5)==0 ){
      i = th3testvfsReadByte(pFSys, pFile, iCursor++);
      th3testAppendResultTerm(p, th3format(p, "%u", i));
    }else if( nToken==6 && memcmp(zToken, "read16", 6)==0 ){
      i = th3testvfsReadInt16(pFSys, pFile, iCursor);
      iCursor += 2;
      th3testAppendResultTerm(p, th3format(p, "%u", i));
    }else if( nToken==6 && memcmp(zToken, "read32", 6)==0 ){
      i = th3testvfsReadInt32(pFSys, pFile, iCursor);
      iCursor += 4;
      th3testAppendResultTerm(p, th3format(p, "%u", i));
    }else if( nToken==4 && memcmp(zToken, "add8", 4)==0 ){
      v = th3testvfsEdit_GetInt(p, &zScript, &nScript);
      i = th3testvfsReadByte(pFSys, pFile, iCursor);
      th3testvfsWriteByte(pFSys, pFile, iCursor, (i+v)&0xff);
      iCursor++;
    }else if( nToken==5 && memcmp(zToken, "add16", 5)==0 ){
      v = th3testvfsEdit_GetInt(p, &zScript, &nScript);
      i = th3testvfsReadInt16(pFSys, pFile, iCursor);
      th3testvfsWriteInt16(pFSys, pFile, iCursor, (int)(i+v));
      iCursor += 2;
    }else if( nToken==5 && memcmp(zToken, "add32", 5)==0 ){
      v = th3testvfsEdit_GetInt(p, &zScript, &nScript);
      i = th3testvfsReadInt32(pFSys, pFile, iCursor);
      th3testvfsWriteInt32(pFSys, pFile, iCursor, (int)(i+v));
      iCursor += 4;
    }else if( nToken==11 && memcmp(zToken, "incr-schema", 11)==0 ){
      i = th3testvfsReadInt32(pFSys, pFile, 40);
      th3testvfsWriteInt32(pFSys, pFile, 40, i+1);
      i = th3testvfsReadInt32(pFSys, pFile, 24);
      th3testvfsWriteInt32(pFSys, pFile, 24, i+1);
      i = th3testvfsReadInt32(pFSys, pFile, 92);
      th3testvfsWriteInt32(pFSys, pFile, 92, i+1);
    }else if( nToken==9 && memcmp(zToken, "incr-chng", 9)==0 ){
      i = th3testvfsReadInt32(pFSys, pFile, 24);
      th3testvfsWriteInt32(pFSys, pFile, 24, i+1);
      i = th3testvfsReadInt32(pFSys, pFile, 92);
      th3testvfsWriteInt32(pFSys, pFile, 92, i+1);
    }else if( nToken==5 && memcmp(zToken, "store", 5)==0 ){
      th3testvfsEdit_GetToken(&zScript, &nScript, &zToken, &nToken);
      zBuf = sqlite3_mprintf("%.*s", nToken, zToken);
      th3bindText(p, zBuf, p->zResult);
      th3testResetResult(p);
      sqlite3_free(zBuf);
    }else if( nToken==6 && memcmp(zToken, "delete", 6)==0 ){
      th3fileDelete(p, pFile->zFilename);
      fileDeleted = 1;
      break;
    }else if( nToken==6 && memcmp(zToken, "search", 6)==0 ){
      int n;
      th3testvfsEdit_GetToken(&zScript, &nScript, &zToken, &nToken);
      zBuf = th3malloc(p, nToken);
      for(n=0; th3getHexByte(&zToken, &nToken, &c); n++){
        zBuf[n] = c;
      }
      i = th3testvfsSearch(p, pFSys, pFile, n, zBuf);
      th3testAppendResultTerm(p, th3format(p, "%d", i));
    }else if( nToken==11 && memcmp(zToken, "write32_shm", 11)==0 ){
      int idx = iCursor/pFile->szShmRegion;
      int ofst = iCursor % pFile->szShmRegion;
      v = th3testvfsEdit_GetInt(p, &zScript, &nScript);
      if( idx<pFile->nShmRegion ){
        *(int*)(pFile->apShm[idx] + ofst) = v;
      }
      iCursor += 4;
      usedShm = 1;
    }else if( nToken==11 && memcmp(zToken, "write16_shm", 11)==0 ){
      int cnt;
      int incr;
      v = th3testvfsEdit_GetInt(p, &zScript, &nScript);
      cnt = th3testvfsEdit_GetInt(p, &zScript, &nScript);
      incr = th3testvfsEdit_GetInt(p, &zScript, &nScript);
      while( (cnt--)>0 ){
        int idx = iCursor/pFile->szShmRegion;
        int ofst = iCursor % pFile->szShmRegion;
        if( idx<pFile->nShmRegion ){
          *(short int*)(pFile->apShm[idx] + ofst) = v;
        }
        iCursor += 2;
        v += incr;
      }
      usedShm = 1;
    }else if( nToken==10 && memcmp(zToken, "read32_shm", 10)==0 ){
      int idx = iCursor/pFile->szShmRegion;
      int ofst = iCursor % pFile->szShmRegion;
      if( idx<pFile->nShmRegion ){
        i = *(int*)(pFile->apShm[idx] + ofst);
      }else{
        i = 0;
      }
      iCursor += 4;
      th3testAppendResultTerm(p, th3format(p, "%u", i));
      usedShm = 1;
    }else if( nToken==9 && memcmp(zToken, "cksum_shm", 9)==0 ){
      /* Recompute the correct checksum for the shared memory header.
      ** Invoke this method after making modifications to the header.
      ** Checksums are recomputed for both copies of the header.
      */
      if( pFile->nShmRegion ){
        u32 s0, s1, *a;
        int ii;
        a = (u32*)pFile->apShm[0];;
        s0 = s1 = 0;
        for(ii=0; ii<10; ii+=2){
          s0 += a[ii] + s1;
          s1 += a[ii+1] + s0;
        }
        a[10] = a[22] = s0;
        a[11] = a[23] = s1;
      }
    }else{
      th3testAppendResultTerm(p,
        th3format(p, "ERROR: unknown token \"%.*s\"", nToken, zToken)
      );
      break;
    }
  }

  /* If running in JOURNAL_WAL mode and the read32_shm and write32_shm
  ** operators were not used, then zero both the WAL and wal-index headers.
  **
  ** This is necessary in order to get the database connection to read
  ** the changes from the database file only.
  */
  if( !fileDeleted && pFile->nShmRegion>0 && !usedShm ){
    char *zWal;
    th3vfsFile *pWalFile;
    u32 *aWIndex;
    assert( (p->config.maskProp & TH3_JOURNAL_WAL)!=0 );
    assert( sizeof(*aWIndex)==4 );
    aWIndex = (u32*)pFile->apShm[0];
    /* mxFrame is aWIndex[4] and nBackfill is aWIndex[24] */
    if( aWIndex[4]>aWIndex[24] ){
      th3testAppendResultTerm(p, th3format(p, 
          "ERROR: --edit with incomplete checkpoint. mxFrame=%d, nBackfill=%d.",
          aWIndex[2], aWIndex[24]));
      return;
    }
    zWal = sqlite3_mprintf("%s-wal", zFile);
    pWalFile = findFile(pFSys, zWal, 0);
    if( pWalFile && pWalFile->sz>=32 ){
      memset(pWalFile->apSector[0]->a, 0, 32);
    }
    sqlite3_free(zWal);
    memset(pFile->apShm[0], 0, 12*4);
  }

}

/*
** A pointer to a non-synced object.  The object can be either
** a sector or a file.
*/
typedef struct th3NotSynced th3NotSynced;
struct th3NotSynced {
  int isSector;
  union {
    th3vfsSector *pSector;
    th3vfsFile *pFile;
  } u;
};

/*
** Make random changes to unsynced elements of the main failsystem.
** Return the number of changes made.
*/
int th3filesystemCrash(th3state *p, int iRand){
  th3vfsSector *pSector;
  th3vfsFile *pFile;
  th3vfsFSys *pFSys = &p->fsysTest;
  int nCorrupt, i;
  int nNotSynced;
  th3NotSynced *aNotSynced;

  /* If there are no non-synced items in this filesystem, then there
  ** is nothing for this routine to do. */
  nNotSynced = pFSys->nNotSynced;
  if( nNotSynced==0 || pFSys->isSequential ) return 0;

  /* Collect all non-synced items into the aNotSynced[] array */
  aNotSynced = th3malloc(p, sizeof(aNotSynced[0])*nNotSynced );
  i = 0;
  for(pSector=pFSys->pSector; pSector; pSector=pSector->pNext){
    if( pSector->notSynced && i<nNotSynced ){
      aNotSynced[i].isSector = 1;
      aNotSynced[i].u.pSector = pSector;
      i++;
    }
  }
  for(pFile=pFSys->pFile; pFile; pFile=pFile->pNext){
    if( pFile->notSynced && i<nNotSynced ){
      aNotSynced[i].isSector = 0;
      aNotSynced[i].u.pFile = pFile;
      i++;
    }
  }
  assert( i==nNotSynced ); 

  /* Scramble order of the non-synced items */
  th3randomReseed(p, iRand);
  for(i=0; i<nNotSynced*3; i++){
    th3NotSynced sTemp;
    int a = th3randomInt(p) % nNotSynced;
    sTemp = aNotSynced[a];
    aNotSynced[a] = aNotSynced[i%nNotSynced];
    aNotSynced[i%nNotSynced] = sTemp;
  }

  /* How many corruptions will we perform.  1..nNotSynced */
  if( pFSys->isAtomic ){
    nCorrupt = 0;
  }else if( pFSys->nNotSynced==1 ){
    nCorrupt = 1;
  }else{
    nCorrupt = th3randomInt(p)%pFSys->nNotSynced + 1;
  }

  /* Do the various corruptions.  Sector corruption must occur first
  ** since file corruption might truncate the file and remove sectors
  ** that are on the list of sectors to be corrupted. */
  for(i=0; i<nCorrupt; i++){
    if( aNotSynced[i].isSector ){
      int r = th3randomByte(p)&7;
      int szSector = pFSys->szSector;
      pSector = aNotSynced[i].u.pSector;
      if( r==0 ){
        /* Zero the whole sector */
        fsTrace(pFSys, "CRASH-zero");
        th3memset(pSector->a, 0, szSector);
      }else if( r==1 ){
        /* Set the whole sector to 0xff */
        fsTrace(pFSys, "CRASH-0xff");
        th3memset(pSector->a, 0xff, szSector);
      }else if( r>=2 && r<=4 ){
        /* Randomness into a prefix the sector */
        int nByte = th3randomInt(p)%szSector;
        fsTrace(pFSys, "CRASH-prefix %d bytes", nByte);
        th3randomBlob(p, pSector->a, nByte);
      }else{
        /* Randomness into a suffix the sector */
        int nByte = th3randomInt(p)%szSector;
        fsTrace(pFSys, "CRASH-suffix %d bytes", nByte);
        th3randomBlob(p, &pSector->a[szSector-nByte], nByte);
      }
      fsTrace(pFSys, " on %s sector %d\n", pSector->pFile->zFilename,
              pSector->idx);
    }
  }
  for(i=0; i<nNotSynced; i++){
    if( aNotSynced[i].isSector==0 ){
      int r = th3randomByte(p);
      pFile = aNotSynced[i].u.pFile;
      if( (pFile->szSync==0 && (r&1)==1) ){
        /* Delete the file */
        fsTrace(pFSys, "CRASH-delete %s\n", pFile->zFilename);
        destroyFile(pFSys, pFile);
      }else{
        /* Truncate the file */
        fsTrace(pFSys, "CRASH-truncate size %lld file %s\n", pFile->szSync,
                pFile->zFilename);
        truncateFile(pFSys, pFile, pFile->szSync);
      }
    }
  }

  /* Free up the memory we allocated */
  th3free(p, aNotSynced);
  return nCorrupt;
}

/*
** The TH3_WORKING_DIRECTORY macro, if defined, specifies a directory
** in which all temporary databases are created.
**
** The working directory name (if it is not blank) should end with
** the directory separator character.  For example:
**
**    -DTH3_WORKING_DIRECTORY="/tmp/th3/"
**
** The directory name cannot be too long or fixed-length buffers
** will overflow.
*/
#ifndef TH3_WORKING_DIRECTORY
#define TH3_WORKING_DIRECTORY ""
#endif


/*
** Make a filename unique across all threads.  The original name
** of the file is zFile.  The converted name is stored in zFN.
** zFN must be able to hold at least 200 characters.
*/
static void th3convertFilename(th3state *p, const char *zFile, char *zFN){
  if( p->config.maskProp & TH3_MEMDB || th3strcmp(zFile, ":memory:")==0 ){
    th3strcpy(zFN, ":memory:");
  }else if( (p->config.maskProp & TH3_TEST_VFS)!=0
               || memcmp(zFile,"file:",5)==0 ){
    th3strcpy(zFN, zFile);
  }else{
    assert( strlen(zFile)+strlen(TH3_WORKING_DIRECTORY)+10<200 );
    sqlite3_snprintf(200, zFN, "%sx%d_%s",
                     TH3_WORKING_DIRECTORY, p->tid, zFile);
  }
}

/*
** Delete a file from the filesystem.
*/
int th3fileDelete(th3state *p, const char *zFilename){
  char *zFN;
  int rc = SQLITE_OK;
  int n;
  int isUri;
  if( th3strcmp(zFilename, ":memory:")==0 ) return rc;
  isUri = memcmp(zFilename, "file:", 5)==0;
  n = strlen(zFilename);
  zFN = th3malloc(p, n+100);
  th3convertFilename(p, &zFilename[isUri*5], zFN);
  if( isUri ){
    int i;
    for(i=0; zFN[i] && zFN[i]!='?' && zFN[i]!='#'; i++){}
    zFN[i] = 0;
  }
  n = strlen(zFN);
  rc = p->pVfs->xDelete(p->pVfs, zFN, 0);
  th3free(p, zFN);
  return rc;
}

/*
** Return true if the given file exists.
*/
int th3fileExists(th3state *p, const char *zFilename){
  char *zFN = th3malloc(p, 200);
  int rc = SQLITE_OK;
  int res = 0;
  th3convertFilename(p, zFilename, zFN);
  rc = p->pVfs->xAccess(p->pVfs, zFN, SQLITE_ACCESS_EXISTS, &res);
  th3free(p, zFN);
  return res;
}

/*
** Close an open file.
*/
void th3fileClose(th3state *p, int id){
  assert( id>=0 && id<TH3_MAX_FILE );
  if( p->apFile[id] ){
    p->apFile[id]->pMethods->xClose(p->apFile[id]);
    th3free(p, p->apFile[id]);
    p->apFile[id] = 0;
  }
}

/*
** Close all open files.
*/
void th3fileCloseAll(th3state *p){
  int i;
  for(i=0; i<TH3_MAX_FILE; i++){
    th3fileClose(p, i);
  }
}

/*
** Clear all entries from the statement cache
*/
void th3dbCacheClear(th3state *p){
  int i;
  struct th3StmtCache *pLine;

  for(i=0, pLine=p->aStmtCache; i<p->nStmtCache; i++, pLine++){
    if( pLine->pStmt ){
      sqlite3_finalize(pLine->pStmt);
      th3memset(pLine, 0, sizeof(*pLine));
    }
  }
  p->iStmtAge = 0;
}

/*
** Change the size of the statement cache.  Any size reduction has the
** effect of clearing the cache.
*/
void th3dbCacheSetSize(th3state *p, int iSize){
  if( iSize<0 ){
    iSize = 0;
  }else if( iSize>TH3_N_STMTCACHE ){
    iSize = TH3_N_STMTCACHE;
  }
  if( iSize<p->nStmtCache ){
    th3dbCacheClear(p);
  }
  p->nStmtCache = iSize;
}

/*
** Find a statement in the statement cache and return a pointer to
** that statement.  Return NULL if not found.  The statement is
** removed from the cache by this action.
*/
sqlite3_stmt *th3dbCacheFind(
  th3state *p,           /* Testing context */
  int iDb,               /* The database connection */
  const char *zSql,      /* Text of the SQL to search for */
  const char **pzTail    /* Tail of the SQL statement text */
){
  int i;
  struct th3StmtCache *pLine;
  sqlite3_stmt *pStmt = 0;
  
  for(i=0, pLine=p->aStmtCache; i<p->nStmtCache; i++, pLine++){
    if( pLine->pStmt && pLine->iDb==iDb
         && memcmp(sqlite3_sql(pLine->pStmt), zSql, pLine->nSql)==0 ){
      /* EVIDENCE-OF: R-10231-33192 This interface can be used to retrieve a
      ** saved copy of the original SQL text used to create a prepared
      ** statement if that statement was compiled using either
      ** sqlite3_prepare_v2() or sqlite3_prepare16_v2().
      **
      ** The fact that sqlite3_sql() is used by the statement cache and
      ** the statment cache works, demonstrates that sqlite3_sql() works.
      */
      pStmt = pLine->pStmt;
      *pzTail = &zSql[pLine->nSql];
      th3memset(pLine, 0, sizeof(*pLine));
      break;
    }
  }
  return pStmt;
}

/*
** Insert a statement into the statement cache using LRU replacement.
**
** This procedure takes responsibility for making sure the statement object
** is freed.  The statement will be freed immediately if it cannot be put
** into the cache.  If it is cached, then it will be freed when it falls
** out of cache.
**
** The cache uses LRU replacement.
*/
void th3dbCacheInsert(th3state *p, int iDb, sqlite3_stmt *pStmt){
  int i;
  struct th3StmtCache *pLine;

  if( p->nStmtCache<=0 || sqlite3_sql(pStmt)==0 ){
    sqlite3_finalize(pStmt);
    return;
  }
  for(i=0, pLine=p->aStmtCache; i<p->nStmtCache; i++, pLine++){
    if( pLine->pStmt==0 ) break;
  }
  if( i>=p->nStmtCache ){
    int iOldest = 0;
    int ageOldest;
    pLine = p->aStmtCache;
    ageOldest = pLine->iAge;
    for(i=1, pLine++; i<p->nStmtCache; i++, pLine++){
      if( pLine->iAge<ageOldest ){ 
        iOldest = i;
        ageOldest = pLine->iAge;
      }
    }
    pLine = &p->aStmtCache[iOldest];
    sqlite3_finalize(pLine->pStmt);
  }
  pLine->pStmt = pStmt;
  pLine->nSql = strlen(sqlite3_sql(pStmt));
  pLine->iDb = iDb;
  pLine->iAge = ++p->iStmtAge;
  assert( p->iStmtAge<0x7fff0000 );
}

/*
** Close an open database connection.  This has the side-effect of
** clearing all statement cache entries, even entries on different
** database connections.
*/
void th3dbClose(th3state *p, int id){
  th3db *pDb;
  assert( id>=0 && id<=TH3_MAX_DB );
  pDb = &p->aDb[id];
  assert( pDb->p==p );
  th3dbCacheClear(p);
  sqlite3_close(pDb->db);
  th3free(p, pDb->zDest);
  pDb->db = 0;
  pDb->zDest = 0;
  pDb->columnMode = 0;
  pDb->typeMode = 0;
}

/*
** Close all open database connections.
*/
void th3dbCloseAll(th3state *p){
  int i;
  for(i=0; i<=TH3_MAX_DB; i++){
    th3dbClose(p, i);
  }
}


/*
** Return the id-th database connection pointer.
*/
sqlite3 *th3dbPointer(th3state *p, int id){
  assert( id>=0 && id<=TH3_MAX_DB );
  return p->aDb[id].db;
}

/*
** Enable the CODEC if there is one.
*/
int th3enableCodec(th3state *p, sqlite3 *db){
  int rc = SQLITE_OK;
#ifdef SQLITE_HAS_CODEC
  if( db && (p->config.maskProp & TH3_CLEARTEXT)==0 ){
    const char *zCodecKey = p->config.zCodecKey ? p->config.zCodecKey : "xyzzy";
    int nCodecKey = strlen(zCodecKey);
    rc = sqlite3_key(db, zCodecKey, nCodecKey);
  }
#endif
  return rc;
}

/*
** Set the pointer on the id-th database connection.
*/
int th3dbSetPointer(th3state *p, int id, sqlite3 *db){
  assert( id>=0 && id<=TH3_MAX_DB );
  th3dbClose(p, id);
  p->aDb[id].db = db;
  return th3enableCodec(p, db);
}

/*
** Put the database connection into a mode whereby all output
** from th3dbEval() is stored in a table named zTableName.
** For each output element, two columns are written which are
** the column name and the column value.
**
** The insert mode is cancelled if zTableName is an empty string
** or NULL.
*/
void th3dbInsertMode(th3state *p, int id, const char *zTableName){
  th3db *pDb;
  assert( id>=0 && id<=TH3_MAX_DB );
  pDb = &p->aDb[id];
  th3free(p, pDb->zDest);
  if( zTableName && zTableName[0] ){
    int n = strlen(zTableName) + 1;
    pDb->zDest = th3malloc(p, n);
    th3memcpy(pDb->zDest, zTableName, n);
  }else{
    pDb->zDest = 0;
  }
}

/*
** Implementation of th3puts().  Append the text value of argv[0] to
** the query result.
*/
static void th3putsFunc(
  sqlite3_context *context,
  int argc,
  sqlite3_value **argv
){
  th3state *p = (th3state*)sqlite3_user_data(context);
  sqlite3_result_value(context, argv[0]);
  th3testAppendResultTerm(p, (char*)sqlite3_value_text(argv[0]));
}

/*
** Implementation of th3random().  Return a random integer.
** This is similar to the random() function built into SQLite except
** that it uses the TH3 PRNG so that we can control the seeding.
*/
static void th3randomFunc(
  sqlite3_context *context,
  int argc,
  sqlite3_value **argv
){
  sqlite_int64 r;
  th3state *p = (th3state*)sqlite3_user_data(context);
  th3randomBlob(p, (char*)&r, sizeof(r));
  if( (r<<1)==0 ) r = 0;  /* Prevent 0x8000.... as the result so that we */
                          /* can always do abs() of the result */
  sqlite3_result_int64(context, r);
}

/*
** Implementation of th3randomblob(N).  Return a random blob
** that is N bytes long.  This is like the built-in randomblob()
** function except that it uses the TH3 PRNG so that we can control
** the seed.
*/
static void th3randomblobFunc(
  sqlite3_context *context,
  int argc,
  sqlite3_value **argv
){
  int n;
  char *buf;
  th3state *p = (th3state*)sqlite3_user_data(context);
  assert( argc==1 );
  n = sqlite3_value_int(argv[0]);
  if( n<1 ){
    n = 1;
  }
  buf = sqlite3_malloc( n );
  if( buf ){
    th3randomBlob(p, buf, n);
    sqlite3_result_blob(context, buf, n, sqlite3_free);
  }
}

/*
** Implementation of th3_load_normal_extension(B).  Script applications
** invoke this routine in order to pull in the extension functions when
** the VFS is not active and the load_extension mechanism will therefore
** not work.
*/
static void th3_load_normal_extension(
  sqlite3_context *context,
  int argc,
  sqlite3_value **argv
){
  sqlite3 *db = sqlite3_context_db_handle(context);
  th3_normal_ext_init(db, 0, 0);
}

/*
** An instance of this structure is passed from th3eval() into
** th3eval_callback() and is used to accumulate the result string.
*/
struct th3eval_result {
  int nAlloc;         /* Space allocated for zResults[] */
  int nUsed;          /* Space used in zResults[] */
  char *zResults;     /* The accumulated results */
  const char *zSep;   /* The element separator string */
  int nSep;           /* Number of characters in zSep */
  int oomErr;         /* Becomes true if we hit an out-of-memory error */
};

/*
** This is the callback from the SQL evaluator of the th3eval()
** implementation below.  Append results to the growing string.
*/
static int th3eval_callback(void *pAppData, int n, char **argv, char **names){
  struct th3eval_result *p = (struct th3eval_result*)pAppData;
  int i;          /* Loop counter */
  int len;        /* Length of a result string */
  const char *z;  /* A result value */
  for(i=0; i<n; i++){
    z = argv[i];
    if( z==0 ) z = "nil";
    len = strlen(z);
    if( p->nUsed + len + p->nSep + 1 >= p->nAlloc ){
      char *zNew;
      p->nAlloc = p->nAlloc*2 + len + p->nSep + 100;
      zNew = sqlite3_realloc(p->zResults, p->nAlloc);
      if( zNew==0 ){
        sqlite3_free(p->zResults);
        p->nAlloc = 0;
        p->nUsed = 0;
        p->oomErr = 1;
        return 1;
      }
      p->zResults = zNew;
      if( p->nUsed>0 ){
        th3memcpy(&p->zResults[p->nUsed], p->zSep, p->nSep);
        p->nUsed += p->nSep;
      }
      th3memcpy(&p->zResults[p->nUsed], z, len);
      p->nUsed += len;
    }
  }
  return 0;
}

/*
** Implementation of th3eval(T,S,R,D) SQL function.
**
**    T    The SQL string to be evaluated
**    S    String to use as an element separator in the result
**    R    String to return if there is an error.  Or if numeric 0, return
**         the error as text rather than propagating the error upward.
**    D    Which database connection to run the SQL in
**
** If S is NULL then a comma is used as the separator.  If R is NULL then
** errors in evaluation of T are propagated back up through th3eval() into
** the caller.  If D is NULL then the sql is run in the same database
** connection as the caller.
**
** Any of S, R, or D may be omitted.  Omitted parameters are treated as
** if they were NULL.
*/
static void th3eval(
  sqlite3_context *context,
  int argc,
  sqlite3_value **argv
){
  sqlite3 *db;
  int rc;
  struct th3eval_result s;
  char *zSql;
  char *zErrMsg = 0;
  int iDb;

  th3memset(&s, 0, sizeof(s));
  if( argc>=2 && sqlite3_value_type(argv[1])!=SQLITE_NULL ){
    s.zSep = (char*)sqlite3_value_text(argv[1]);
    s.nSep = sqlite3_value_bytes(argv[1]);
  }else{
    s.zSep = ",";
    s.nSep = 1;
  }
  if( argc>=4 && sqlite3_value_type(argv[3])!=SQLITE_NULL ){
    th3state *p = sqlite3_user_data(context);
    iDb = sqlite3_value_int(argv[3]);
    assert( iDb>=0 && iDb<=TH3_MAX_DB );
    db = p->aDb[iDb].db;
  }else{
    db = sqlite3_context_db_handle(context);
  }
  zSql = (char*)sqlite3_value_text(argv[0]);
  rc = sqlite3_exec(db, zSql, th3eval_callback, &s, &zErrMsg);
  if( rc!=SQLITE_OK && argc>=3 && sqlite3_value_type(argv[2])!=SQLITE_NULL ){
    if( sqlite3_value_type(argv[2])==SQLITE_INTEGER &&
        sqlite3_value_int(argv[2])==0 ){
      char *z = sqlite3_mprintf("%s %s", th3errorCodeName(rc), zErrMsg);
      sqlite3_result_text(context, z, -1, sqlite3_free);
    }else{
      sqlite3_result_value(context, argv[2]);
    }
    sqlite3_free(zErrMsg);
  }else if( s.oomErr || rc==SQLITE_NOMEM ){
    sqlite3_result_error_nomem(context);
    sqlite3_free(zErrMsg);
  }else if( zErrMsg ){
    sqlite3_result_error(context, zErrMsg, -1);
    sqlite3_free(zErrMsg);
  }else if( s.zResults ){
    sqlite3_result_text(context, s.zResults, s.nUsed, sqlite3_free);
    s.zResults = 0;
  }
  sqlite3_free(s.zResults);
}


/*
** Extra flags allowed in the "flags" argument.
*/
#define TH3_OPEN_RAW       0x10000000   /* Do not do any configuration */
#define TH3_OPEN_NEW       0x20000000   /* Delete the file before opening */
#define TH3_OPEN_CLEARTEXT 0x40000000   /* Do not enable encryption */

/*
** Open a database connection on the file given.  If a previous
** connection already exists on the same id, close the previous
** connection first.
**
** The flags parameter is passed to sqlite3_open_v2() if it is not zero.
*/
int th3dbOpen(th3state *p, int id, const char *zFile, int flags){
  int rc;
  int f2;
  sqlite3 *db;
  int isMem;
  char *zFN;
  char *zBuf;

  zBuf = th3malloc(p, 500);
  zFN = &zBuf[250];
  assert( id>=0 && id<=TH3_MAX_DB );
  th3convertFilename(p, zFile, zFN);
  th3dbClose(p, id);
  isMem = th3strcmp(zFN, ":memory:")==0;
  if( (flags & TH3_OPEN_NEW)!=0 && !isMem ){
    int n;
    n = strlen(zFile);
    th3memcpy(zFN, zFile, n+1);
    th3fileDelete(p, zFN);
    th3memcpy(&zFN[n], "-journal", 9);
    th3fileDelete(p, zFN);
    th3memcpy(&zFN[n], "-wal", 5);
    th3fileDelete(p, zFN);
    th3memcpy(&zFN[n], ".lock", 6);
    th3fileDelete(p, zFN);
    th3convertFilename(p, zFile, zFN);
  }
  f2 = flags & ~(TH3_OPEN_RAW|TH3_OPEN_NEW|TH3_OPEN_CLEARTEXT);
  if( (f2&(SQLITE_OPEN_READONLY|SQLITE_OPEN_READWRITE|SQLITE_OPEN_CREATE))==0 ){
    f2 |= SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE;
  }
  if( (p->config.maskProp & TH3_8_3_NAMES)!=0 && !isMem ){
    sqlite3_snprintf(250, zBuf, "file:%s?8_3_names=1", zFN);
    zFN = zBuf;
    f2 |= SQLITE_OPEN_URI;
  }
  if( (p->config.maskProp & (TH3_TEST_VFS|TH3_ZIPVFS))!=0 ){
    rc = sqlite3_open_v2(zFN, &db, f2, p->pVfs->zName);
  }else if( p->config.zDfltVfs!=0 
            || (f2 & SQLITE_OPEN_URI)!=0
            || f2!=(SQLITE_OPEN_READWRITE|SQLITE_OPEN_CREATE) ){
    rc = sqlite3_open_v2(zFN, &db, f2, p->config.zDfltVfs);
  }else{
    rc = sqlite3_open(zFN, &db);
  }
  th3free(p, zBuf);
  p->aDb[id].db = db;
  if( rc ) return rc;
  if( (flags & TH3_OPEN_CLEARTEXT)==0 ) rc = th3enableCodec(p, db);
  if( rc ) return rc;
  if( flags & TH3_OPEN_RAW ) return rc;
  sqlite3_create_function(db, "th3puts", 1, SQLITE_UTF8, p,
                          th3putsFunc, 0, 0);
  sqlite3_create_function(db, "th3random", 0, SQLITE_UTF8, p,
                          th3randomFunc, 0, 0);
  sqlite3_create_function(db, "th3randomBlob", 1, SQLITE_UTF8, p,
                          th3randomblobFunc, 0, 0);
  sqlite3_create_function(db, "th3_load_normal_extension", 0, SQLITE_ANY, 0,
                          th3_load_normal_extension, 0, 0);
  sqlite3_create_function(db, "th3eval", 1, SQLITE_UTF8, p,
                          th3eval, 0, 0);
  sqlite3_create_function(db, "th3eval", 2, SQLITE_UTF8, p,
                          th3eval, 0, 0);
  sqlite3_create_function(db, "th3eval", 3, SQLITE_UTF8, p,
                          th3eval, 0, 0);
  sqlite3_create_function(db, "th3eval", 4, SQLITE_UTF8, p,
                          th3eval, 0, 0);
  if( (p->config.maskProp & TH3_TEST_VFS)!=0 ){
    sqlite3_create_module(db, "vfs", &th3vfsvtabModule, 
                          (void*)&p->fsysTest);
  }
  sqlite3_create_module(db, "bvs", &th3bvsvtabModule, (void*)p);
  sqlite3_create_module(db, "wholenumber", &wholenumberModule, 0);
  Md5_Register(db);
  if( p->config.szPage ){
    char zBuf[50];
    sqlite3_snprintf(sizeof(zBuf), zBuf,
                            "PRAGMA page_size=%d", p->config.szPage);
    sqlite3_exec(db, zBuf, 0, 0, 0);
  }
#ifdef SQLITE_TESTCTRL_RESERVE
  if( p->nReserve ){
    sqlite3_test_control(SQLITE_TESTCTRL_RESERVE, db, p->nReserve);
  }
#endif
  if( p->config.szCache ){
    char zBuf[50];
    sqlite3_snprintf(sizeof(zBuf), zBuf,
                            "PRAGMA cache_size=%d", p->config.szCache);
    sqlite3_exec(db, zBuf, 0, 0, 0);
  }
  if( p->config.maskProp & TH3_AUTOVACUUM ){
    sqlite3_exec(db, "PRAGMA auto_vacuum=FULL", 0, 0, 0);
  }
  if( p->config.maskProp & TH3_INCRVACUUM ){
    sqlite3_exec(db, "PRAGMA auto_vacuum=INCREMENTAL", 0, 0, 0);
  }
  if( p->config.maskProp & TH3_UTF16LE ){
    sqlite3_exec(db, "PRAGMA encoding=UTF16LE", 0, 0, 0);
  }
  if( p->config.maskProp & TH3_UTF16BE ){
    sqlite3_exec(db, "PRAGMA encoding=UTF16BE", 0, 0, 0);
  }
  if( p->config.maskProp & TH3_FORMAT4 ){
    sqlite3_exec(db, "PRAGMA legacy_file_format=OFF", 0, 0, 0);
  }
  if( p->config.maskProp & TH3_JOURNAL_OFF ){
    sqlite3_exec(db, "PRAGMA journal_mode=OFF", 0, 0, 0);
  }
  if( p->config.maskProp & TH3_JOURNAL_MEMORY ){
    sqlite3_exec(db, "PRAGMA journal_mode=MEMORY", 0, 0, 0);
  }
  if( p->config.maskProp & TH3_JOURNAL_PERSIST ){
    sqlite3_exec(db, "PRAGMA journal_mode=PERSIST", 0, 0, 0);
  }
  if( p->config.maskProp & TH3_JOURNAL_TRUNCATE ){
    sqlite3_exec(db, "PRAGMA journal_mode=TRUNCATE", 0, 0, 0);
  }
  if( p->config.maskProp & TH3_JOURNAL_WAL ){
    sqlite3_exec(db, "PRAGMA journal_mode=WAL", 0, 0, 0);
  }
  if( p->config.maskProp & TH3_LOCKMODE_EXCLUSIVE ){
    sqlite3_exec(db, "PRAGMA locking_mode=EXCLUSIVE", 0, 0, 0);
  }
  if( p->config.maskProp & TH3_TEMPSTORE_FILE ){
    sqlite3_exec(db, "PRAGMA temp_store=FILE", 0, 0, 0);
  }
  if( p->config.maskProp & TH3_TEMPSTORE_MEM ){
    sqlite3_exec(db, "PRAGMA temp_store=MEMORY", 0, 0, 0);
  }
  if( p->config.maskProp & TH3_RECURSIVE_TRIGGERS ){
    sqlite3_exec(db, "PRAGMA recursive_triggers=ON", 0, 0, 0);
  }else{
    sqlite3_exec(db, "PRAGMA recursive_triggers=OFF", 0, 0, 0);
  }
  if( p->config.maskProp & TH3_FOREIGN_KEYS ){
    sqlite3_exec(db, "PRAGMA foreign_keys=ON", 0, 0, 0);
  }else{
    sqlite3_exec(db, "PRAGMA foreign_keys=OFF", 0, 0, 0);
  }
  if( p->config.maskProp & TH3_SECURE_DELETE ){
    sqlite3_exec(db, "PRAGMA secure_delete=ON", 0, 0, 0);
  }else{
    sqlite3_exec(db, "PRAGMA secure_delete=OFF", 0, 0, 0);
  }
#ifdef SQLITE_TESTCTRL_OPTIMIZATIONS
  if( p->config.maskProp & TH3_NO_OPT ){
    sqlite3_test_control(SQLITE_TESTCTRL_OPTIMIZATIONS, db, 0xffff);
  }
#endif
  if( p->config.maskProp & TH3_NO_AUTOINDEX ){
    sqlite3_exec(db, "PRAGMA automatic_index=OFF", 0, 0, 0);
  }
  return rc;
}

/*
** Open a database connection on a new file.  If a previous
** connection already exists on the same id, close the previous
** connection first.  If a file already exists with the same name,
** delete it.
*/
int th3dbNew(th3state *p, int id, const char *zFile){
  return th3dbOpen(p, id, zFile, TH3_OPEN_NEW);
}

/*
** Enable or disable the inclusion of column names in output.
*/
void th3dbEnableColname(th3state *p, int id, int enable){
  assert( id>=0 && id<=TH3_MAX_DB );
  p->aDb[id].columnMode = enable;
}

/*
** Given an SQLite error code, return a string which is the name of
** that error code
*/
const char *th3errorCodeName(int rc){
  const char *z = "Unknown-Error-Code";
  switch( rc ){
    case SQLITE_OK:                  z = "SQLITE_OK";                break;
    case SQLITE_ERROR:               z = "SQLITE_ERROR";             break;
    case SQLITE_INTERNAL:            z = "SQLITE_INTERNAL";          break;
    case SQLITE_PERM:                z = "SQLITE_PERM";              break;
    case SQLITE_ABORT:               z = "SQLITE_ABORT";             break;
    case SQLITE_BUSY:                z = "SQLITE_BUSY";              break;
    case SQLITE_LOCKED:              z = "SQLITE_LOCKED";            break;
    case SQLITE_NOMEM:               z = "SQLITE_NOMEM";             break;
    case SQLITE_READONLY:            z = "SQLITE_READONLY";          break;
    case SQLITE_INTERRUPT:           z = "SQLITE_INTERRUPT";         break;
    case SQLITE_IOERR:               z = "SQLITE_IOERR";             break;
    case SQLITE_CORRUPT:             z = "SQLITE_CORRUPT";           break;
    case SQLITE_NOTFOUND:            z = "SQLITE_NOTFOUND";          break;
    case SQLITE_FULL:                z = "SQLITE_FULL";              break;
    case SQLITE_CANTOPEN:            z = "SQLITE_CANTOPEN";          break;
    case SQLITE_PROTOCOL:            z = "SQLITE_PROTOCOL";          break;
    case SQLITE_EMPTY:               z = "SQLITE_EMPTY";             break;
    case SQLITE_SCHEMA:              z = "SQLITE_SCHEMA";            break;
    case SQLITE_TOOBIG:              z = "SQLITE_TOOBIG";            break;
    case SQLITE_CONSTRAINT:          z = "SQLITE_CONSTRAINT";        break;
    case SQLITE_MISMATCH:            z = "SQLITE_MISMATCH";          break;
    case SQLITE_MISUSE:              z = "SQLITE_MISUSE";            break;
    case SQLITE_NOLFS:               z = "SQLITE_NOLFS";             break;
    case SQLITE_AUTH:                z = "SQLITE_AUTH";              break;
    case SQLITE_FORMAT:              z = "SQLITE_FORMAT";            break;
    case SQLITE_RANGE:               z = "SQLITE_RANGE";             break;
    case SQLITE_NOTADB:              z = "SQLITE_NOTADB";            break;
    case SQLITE_ROW:                 z = "SQLITE_ROW";               break;
    case SQLITE_DONE:                z = "SQLITE_DONE";              break;
    case SQLITE_IOERR_READ:          z = "SQLITE_IOERR_READ";        break;
    case SQLITE_IOERR_SHORT_READ:    z = "SQLITE_IOERR_SHORT_READ";  break;
    case SQLITE_IOERR_WRITE:         z = "SQLITE_IOERR_WRITE";       break;
    case SQLITE_IOERR_FSYNC:         z = "SQLITE_IOERR_FSYNC";       break;
    case SQLITE_IOERR_DIR_FSYNC:     z = "SQLITE_IOERR_DIR_FSYNC";   break;
    case SQLITE_IOERR_TRUNCATE:      z = "SQLITE_IOERR_TRUNCATE";    break;
    case SQLITE_IOERR_FSTAT:         z = "SQLITE_IOERR_FSTAT";       break;
    case SQLITE_IOERR_UNLOCK:        z = "SQLITE_IOERR_UNLOCK";      break;
    case SQLITE_IOERR_RDLOCK:        z = "SQLITE_IOERR_RDLOCK";      break;
    case SQLITE_IOERR_DELETE:        z = "SQLITE_IOERR_DELETE";      break;
    case SQLITE_IOERR_BLOCKED:       z = "SQLITE_IOERR_BLOCKED";     break;
    case SQLITE_IOERR_NOMEM:         z = "SQLITE_IOERR_NOMEM";       break;
    case SQLITE_IOERR_ACCESS:        z = "SQLITE_IOERR_ACCESS";      break;
    case SQLITE_IOERR_CHECKRESERVEDLOCK:
                               z = "SQLITE_IOERR_CHECKRESERVEDLOCK"; break;
    case SQLITE_IOERR_LOCK:          z = "SQLITE_IOERR_LOCK";        break;
  }
  return z;
}

/* Forward declaration */
static void th3verifyNoMemAllocDuringMemMeasurement(sqlite3 *db);

/*
** Evaluate zero or more SQL statements in the zSql argument.
** Append results to the p->zResult string.  When an error is
** seen, append the name of the error code and the error message
** and then abort.
*/
int th3dbEval(th3state *p, int id, const char *zSql){
  sqlite3 *db;                 /* The database connection to run SQL against */
  sqlite3_stmt *pStmt;         /* Next statement to run */
  sqlite3_stmt *pIns = 0;      /* Statement for inserting results */
  const char *zTail;           /* SQL that follows the current statement */
  int i, n;                    /* Loop counters */
  int colFlag;                 /* True if column mode is enabled */
  const char *zDestTab;        /* Write results into this table */
  int use16bitApi = 0;         /* Use UTF-16 interfaces if true */
  unsigned short *z16 = 0;     /* UTF-16 version of zSql */
  int rc, rcReset;             /* API result code */
  int iRow;                    /* Row number of output set */
  int doMemCheck;              /* Do memory checks */

  assert( id>=0 && id<=TH3_MAX_DB );
  db = p->aDb[id].db;
  assert( db );
  colFlag = p->aDb[id].columnMode;
  zDestTab = p->aDb[id].zDest;
  p->nSort = 0;
  p->nStep = 0;

  if( zSql==0 ) return SQLITE_OK;
  doMemCheck = (p->config.maskProp & TH3_CHECK_MEMSIZE)!=0;

  /* The default action is to use utf-8 interfaces.  But if the length
  ** of the SQL is odd and is pure ASCII and the statement cache is
  ** disabled, then use the utf-16 interface instead.  This is done
  ** in order to exercise the utf-16 interface logic.
  */
  if( p->nStmtCache==0 ){
    for(i=0; zSql[i] && (zSql[i]&0x80)==0; i++){}
    if( zSql[i]==0 && (i&1)!=0 ){
      z16 = th3malloc(p, sizeof(z16[0])*(i+1));
      for(i=0; (z16[i] = (unsigned char)zSql[i])!=0; i++){}
      zSql = (char*)z16;
      use16bitApi = 1;
    }
  }

  /*
  ** If in th3dbInsertMode(), then prepare a statement that will be used
  ** to insert results.
  */
  if( zDestTab ){
    char *zInsSql;
    assert( strlen(zDestTab)<100 );
    zInsSql = sqlite3_mprintf("INSERT INTO %s VALUES(?,?,?)", zDestTab);
    rc = sqlite3_prepare_v2(db, zInsSql, -1, &pIns, 0);
    sqlite3_free(zInsSql);
    if( rc ){
      th3testAppendResultTerm(p, th3errorCodeName(rc));
      th3testAppendResultTerm(p, sqlite3_errmsg(db));
      sqlite3_finalize(pIns);
      th3free(p, z16);
      return rc;
    }
  }

  while( zSql[0] || (use16bitApi && zSql[1]!=0) ){
    if( use16bitApi ){
      while( th3isspace(*(unsigned short int*)zSql) ){ zSql += 2; }
      if( p->bUsePrepareV2 ){
        rc = sqlite3_prepare16_v2(db, (void*)(char*)zSql, -1, &pStmt,
                                  (const void**)(char*)&zTail);
      }else{
        rc = sqlite3_prepare16(db, (void*)(char*)zSql, -1, &pStmt,
                                  (const void**)(char*)&zTail);
      }
    }else{
      while( th3isspace(zSql[0]) ){ zSql++; }
      if( (pStmt = th3dbCacheFind(p, id, zSql, &zTail))!=0 ){
        rc = SQLITE_OK;
      }else if( p->bUsePrepareV2 ){
        rc = sqlite3_prepare_v2(db, zSql, -1, &pStmt, &zTail);
      }else{
        rc = sqlite3_prepare(db, zSql, -1, &pStmt, &zTail);
      }
    }
    if( rc ){
      th3testAppendResultTerm(p, th3errorCodeName(rc));
      th3testAppendResultTerm(p, sqlite3_errmsg(db));
      sqlite3_finalize(pIns);
      sqlite3_finalize(pStmt);
      th3free(p, z16);
      return rc;
    }
    if( pStmt==0 ) break;
    zSql = zTail;
  
    /* 
    ** Subtitute bound parameters of the form $property_XXXX
    ** where the XXXX is ALT_PCACHE, ATOMICIO, AUTOVACUUM, etc.
    */
    n = sqlite3_bind_parameter_count(pStmt);
    for(i=1; rc==SQLITE_OK && i<=n; i++){
      const char *zParam = sqlite3_bind_parameter_name(pStmt, i);
      if( zParam==0 ){
        /* Do nothing */
      }else if( memcmp(zParam, "$property_", 10)==0 ){
        int j;
        for(j=0; j<COUNT(th3propName); j++){
          if( th3strcmp(th3propName[j].zName, &zParam[10])==0 ){
            rc = sqlite3_bind_int(pStmt, i,
                  (p->config.maskProp & th3propName[j].iMask)!=0
            );
            break;
          }
        }
      }else if( th3strcmp(zParam, "$pending_byte")==0 ){
        rc = sqlite3_bind_int(pStmt, i, p->config.pendingByte);
      }else if( th3strcmp(zParam, "$sector_size")==0 ){
        rc = sqlite3_bind_int(pStmt, i, p->config.szSector);
      }else if( th3strcmp(zParam, "$configuration")==0 ){
        rc = sqlite3_bind_text(pStmt, i, p->config.zConfigName,
                               -1, SQLITE_STATIC);
      }
    }

    /* If any binding variables exist, bind them into the newly
    ** prepared statement.  Variables with symbolic names (ex: $xyz,
    ** :abc, @def) are bound to parameters with the same name.  Variables
    ** with numeric names (ex: 1, 2, 3) are bound to the Nth parameter.
    */
    for(i=0; rc==SQLITE_OK && i<TH3_N_BVS; i++){
      int j;
      int bNumericBind = 0;
      th3var *pVar = &p->aVar[i];
      if( pVar->zName==0 ) continue;
      j = sqlite3_bind_parameter_index(pStmt, pVar->zName);
      if( j==0 ){
        j = th3atoi64(pVar->zName) & 0xffff;
        bNumericBind = 1;
      }
      if( j>0 ){
        switch( pVar->eType ){
          case TH3_BIND_BLOB: {
            char *pData;
            if( p->xBindFree==sqlite3_free ){
              pData = sqlite3_malloc( pVar->u.b.n );
              if( pData ) th3memcpy(pData, pVar->u.b.z, pVar->u.b.n);
            }else{
              pData = pVar->u.b.z;
            }
            rc = sqlite3_bind_blob(pStmt, j, pData, pVar->u.b.n, p->xBindFree);
            break;
          }
          case TH3_BIND_DOUBLE: {
            rc = sqlite3_bind_double(pStmt, j, pVar->u.r);
            break;
          }
          case TH3_BIND_INT: {
            rc = sqlite3_bind_int(pStmt, j, pVar->u.i);
            break;
          }
          case TH3_BIND_INT64: {
            rc = sqlite3_bind_int64(pStmt, j, pVar->u.i);
            break;
          }
          case TH3_BIND_NULL: {
            rc = sqlite3_bind_null(pStmt, j);
            break;
          }
          case TH3_BIND_TEXT:
          case TH3_BIND_TEXT16: {
            char *pData;
            int nData = pVar->u.b.n;
            if( (p->config.maskProp & TH3_BIND_ZEROTERMINATE)==0 ){
              nData--;
              if( pVar->eType==TH3_BIND_TEXT16 ) nData--;
            }
            if( p->xBindFree==sqlite3_free ){
              pData = sqlite3_malloc( pVar->u.b.n );
              if( pData ) th3memcpy(pData, pVar->u.b.z, pVar->u.b.n);
            }else{
              pData = pVar->u.b.z;
            }
            if( (p->config.maskProp & TH3_BIND_ZEROTERMINATE)!=0 ){
              nData = -1;
            }
            if( pVar->eType==TH3_BIND_TEXT ){
              rc = sqlite3_bind_text(pStmt, j, pData, nData, p->xBindFree);
            }else{
              rc = sqlite3_bind_text16(pStmt, j, pData, nData, p->xBindFree);
            }
            break;
          }
          case TH3_BIND_ZEROBLOB: {
            rc = sqlite3_bind_zeroblob(pStmt, j, pVar->u.b.n);
            break;
          }
        }
        if( bNumericBind && rc==SQLITE_RANGE ) rc = SQLITE_OK;
      }
      if( rc ){
        th3testAppendResultTerm(p, th3errorCodeName(rc));
        th3testAppendResultTerm(p, sqlite3_errmsg(db));
        sqlite3_finalize(pIns);
        sqlite3_finalize(pStmt);
        th3free(p, z16);
        return rc;
      }
    }

    /* Run the prepared statement */
    /* EVIDENCE-OF: R-49744-28344 Return the number of columns in the result
    ** set returned by the prepared statement. 
    **
    ** EVIDENCE-OF: R-15591-29646 This routine returns 0 if pStmt is an SQL
    ** statement that does not return data (for example an UPDATE).
    */
    n = sqlite3_column_count(pStmt);
    assert( n>=0 );

    iRow = 0;
    fsTrace(&p->fsysTest, "sqlite3_step: [%s]\n", sqlite3_sql(pStmt));
    while( (rc = sqlite3_step(pStmt))==SQLITE_ROW ){
      if( doMemCheck && iRow==3 ) th3verifyNoMemAllocDuringMemMeasurement(db);
      iRow++;
      /* EVIDENCE-OF: R-20643-25656 The sqlite3_data_count(P) interface returns
      ** the number of columns in the current row of the result set of prepared
      ** statement P. */
      assert( n==sqlite3_data_count(pStmt) );
      for(i=0; i<n; i++){
        const char *z;
        if( pIns ){
          sqlite3_bind_int(pIns, 1, iRow);
          sqlite3_bind_text(pIns, 2, sqlite3_column_name(pStmt, i), -1,
                            SQLITE_STATIC);
          sqlite3_bind_value(pIns, 3, sqlite3_column_value(pStmt, i));
          sqlite3_step(pIns);
          rc = sqlite3_reset(pIns);
          if( rc ){
            th3testAppendResultTerm(p, th3errorCodeName(rc));
            th3testAppendResultTerm(p, sqlite3_errmsg(db));
            sqlite3_finalize(pStmt);
            sqlite3_finalize(pIns);
            th3free(p, z16);
            return rc;
          }
          continue;
        }
        if( colFlag ){
          th3testAppendResultTerm(p, sqlite3_column_name(pStmt, i));
        }
        z = (const char*)sqlite3_column_text(pStmt, i);
        if( z==0 ) z = "nil";
        th3testAppendResultTerm(p, z);
      }
    }
#ifdef SQLITE_STMTSTATUS_FULLSCAN_STEP
    p->nStep += sqlite3_stmt_status(pStmt, SQLITE_STMTSTATUS_FULLSCAN_STEP, 1);
    p->nSort += sqlite3_stmt_status(pStmt, SQLITE_STMTSTATUS_SORT, 1);
#endif
    if( doMemCheck && iRow<=3 ) th3verifyNoMemAllocDuringMemMeasurement(db);
    rcReset = sqlite3_reset(pStmt);
    /* EVIDENCE-OF: R-60153-11078 If the most recent call to sqlite3_step(S)
    ** for the prepared statement S returned SQLITE_ROW or SQLITE_DONE, or if
    ** sqlite3_step(S) has never before been called on S, then
    ** sqlite3_reset(S) returns SQLITE_OK. */
    assert( (rc!=SQLITE_ROW && rc!=SQLITE_DONE) || rcReset==SQLITE_OK );
    /* EVIDENCE-OF: R-33316-19795 If the most recent call to sqlite3_step(S)
    ** for the prepared statement S indicated an error, then sqlite3_reset(S)
    ** returns an appropriate error code. */
    assert( rc==SQLITE_ROW || rc==SQLITE_DONE || rcReset!=SQLITE_OK );
    rc = rcReset;
    th3dbCacheInsert(p, id, pStmt);
    if( rc ){
      th3testAppendResultTerm(p, th3errorCodeName(rc));
      th3testAppendResultTerm(p, sqlite3_errmsg(db));
      sqlite3_finalize(pIns);
      th3free(p, z16);
      return rc;
    }
  }
  sqlite3_finalize(pIns);
  th3free(p, z16);
  return SQLITE_OK;      
}

/*
** Create a prepared statement in database "id" for SQL in zSql.
** Return a pointer to this prepared statement.  Or return NULL
** if anything goes wrong.
*/
sqlite3_stmt *th3dbPrepare(th3state *p, int id, const char *zSql){
  sqlite3 *db;                 /* The database connection to run SQL against */
  sqlite3_stmt *pStmt;         /* Next statement to run */
  int rc;                      /* Return code from prepare */

  assert( id>=0 && id<=TH3_MAX_DB );
  db = p->aDb[id].db;
  assert( db );
  if( zSql==0 ) return 0;

  if( p->bUsePrepareV2 ){
    rc = sqlite3_prepare_v2(db, zSql, -1, &pStmt, 0);
  }else{
    rc = sqlite3_prepare(db, zSql, -1, &pStmt, 0);
  }
  if( rc ){
    th3testAppendResultTerm(p, th3errorCodeName(rc));
    th3testAppendResultTerm(p, sqlite3_errmsg(db));
  }
  return pStmt;
}

/*
** Step a statement prepared using th3dbPrepare().  Store any output
** in test result buffer.
*/
int th3dbStep(th3state *p, sqlite3_stmt *pStmt){
  int rc;
  rc = sqlite3_step(pStmt);
  if( rc==SQLITE_ROW ){
    int i, nCol;
    nCol = sqlite3_column_count(pStmt);
    for(i=0; i<nCol; i++){
      const char *z = (const char*)sqlite3_column_text(pStmt, i);
      if( z==0 ) z = "nil";
      th3testAppendResultTerm(p, z);
    }
  }
  return rc;
}

/*
** Evaluate zero or more SQL statements in the zSql argument.
** Add the results to the MD5 checksum accumulating in p.
*/
int th3dbMd5(th3state *p, int id, const char *zSql){
  sqlite3 *db;
  sqlite3_stmt *pStmt;
  const char *zTail;
  int i, n;

  int rc;
  assert( id>=0 && id<=TH3_MAX_DB );
  db = p->aDb[id].db;
  assert( db );
  while( zSql && zSql[0] ){
    rc = sqlite3_prepare_v2(db, zSql, -1, &pStmt, &zTail);
    if( rc ){
      sqlite3_finalize(pStmt);
      return rc;
    }
    if( pStmt==0 ){
      return rc;
    }
    zSql = zTail;
    n = sqlite3_column_count(pStmt);
    while( (rc = sqlite3_step(pStmt))==SQLITE_ROW ){
      for(i=0; i<n; i++){
        const char *z;
        int n;
        z = (const char*)sqlite3_column_text(pStmt, i);
        n = sqlite3_column_bytes(pStmt, i);
        if( z==0 ) z = "nil";
        th3md5Step(p, (unsigned const char*)z, n);
      }
    }
    rc = sqlite3_finalize(pStmt);
    if( rc ){
      return rc;
    }
  }
  return SQLITE_OK;      
}

/*
** Create a new thread and have it run xProc().  xProc takes a single
** argument pArg.  
**
** When the procedure returns, the thread is automatically deleted.
*/
void th3threadCreate(void (*xProc)(th3state*), th3state *pArg){
  xProc(pArg);
}

/*
** The thread that calls this routine will yield its timeslice.
*/
void th3threadYield(void){
  return;
}


/*****************************************************************************
** Here are the implementations of the methods of the TEST_VFS virtual
** table.  The declarations for all these methods, and the definition of
** the sqlite3_module object that defines the virtualt able are all given
** above.
*/

/*
** Connect to a virtual filesystem.
*/
static int th3vfsvtabConnect(
  sqlite3 *db,                /* The database connection */
  void *pAux,                 /* Pointer to the th3vfsFSys object */
  int argc,                   /* Number of arguments */
  const char *const*argv,     /* Text of the arguments */
  sqlite3_vtab **ppVTab,      /* Write the new vtab here */
  char **pzErr                /* Error message written here */
){
  th3vfsFSys *pFSys = (th3vfsFSys*)pAux;
  th3vfsvtab *pVtab;
  const char *zSchema;
  int i, rc;
  static const char zDefaultSchema[] = 
    "CREATE TABLE x(nRef,sz,szSync,zerogapStart,zerogapCount,notSynced,"
                   "deleteOnClose,isExclusive,readOnly,nReadlLock,"
                   "mxLock,zFilename,content)";

  pVtab = sqlite3_malloc( sizeof(*pVtab) );
  if( pVtab==0 ){
    *pzErr = sqlite3_mprintf("out of memory");
    return SQLITE_NOMEM;
  }
  th3memset(pVtab, 0, sizeof(*pVtab));
  pVtab->pFSys = pFSys;
  zSchema = zDefaultSchema;
  for(i=0; i<argc; i++){
    if( th3strncmp(argv[i],"schema",6)==0 ){
      zSchema = &argv[i][6];
    }
  }
  rc = zSchema[0] ? sqlite3_declare_vtab(db, zSchema) : SQLITE_OK;
  if( rc ){
    sqlite3_free(pVtab);
  }else{
    *ppVTab = &pVtab->parent;
  }
  return rc;
}

/* Find the best index to use for doing a query against the filesystem.
**
** In this very simple implementation, we only do a full table scan.
*/
static int th3vfsvtabBestIndex(sqlite3_vtab *pVTab, sqlite3_index_info *pInfo){
  pInfo->estimatedCost = (double)100;
  return SQLITE_OK;
}

/* Disconnect from a virtual filesystem.
*/
static int th3vfsvtabDisconnect(sqlite3_vtab *pVTab){
  sqlite3_free(pVTab);
  return SQLITE_OK;
}

/* Open a cursor for scanning the filesystem.
*/
static int th3vfsvtabOpen(sqlite3_vtab *pVTab, sqlite3_vtab_cursor **ppCursor){
  th3vfsvtabCursor *pCur;
  pCur = sqlite3_malloc( sizeof(*pCur) );
  if( pCur==0 ){
    pVTab->zErrMsg = sqlite3_mprintf("out of memory");
    return SQLITE_NOMEM;
  }
  *ppCursor = &pCur->parent;
  pCur->pFile = 0;
  return SQLITE_OK;
}

/* Close a cursor
*/
static int th3vfsvtabClose(sqlite3_vtab_cursor *pCur){
  th3vfsvtabCursor *pVfsCur = (th3vfsvtabCursor*)pCur;
  th3vfsvtab *pVfsVtab = (th3vfsvtab*)pCur->pVtab;
  if( pVfsCur->pFile ){
    th3vfsUnrefFile(pVfsVtab->pFSys, pVfsCur->pFile);
  }
  sqlite3_free(pVfsCur);
  return SQLITE_OK;
}

/* Rewind a cursor back to the beginning of the filesystem.
*/
static int th3vfsvtabFilter(
  sqlite3_vtab_cursor *pCur,   /* The cursor to rewind */
  int idxNum,                   /* Not used */
  const char *idxStr,           /* Not used */
  int argc,                     /* Not used */
  sqlite3_value **argv          /* Not used */
){
  th3vfsvtabCursor *pVfsCur = (th3vfsvtabCursor*)pCur;
  th3vfsvtab *pVfsVtab = (th3vfsvtab*)pCur->pVtab;
  if( pVfsCur->pFile ){
    th3vfsUnrefFile(pVfsVtab->pFSys, pVfsCur->pFile);
  }
  pVfsCur->pFile = pVfsVtab->pFSys->pFile;
  if( pVfsCur->pFile ){
    pVfsCur->pFile->nRef++;
  }
  return SQLITE_OK;
}

/* Advance the cursor to the next file in the filesystem.
*/
static int th3vfsvtabNext(sqlite3_vtab_cursor *pCur){
  th3vfsvtabCursor *pVfsCur = (th3vfsvtabCursor*)pCur;
  th3vfsvtab *pVfsVtab = (th3vfsvtab*)pCur->pVtab;
  if( pVfsCur->pFile ){
    th3vfsUnrefFile(pVfsVtab->pFSys, pVfsCur->pFile);
    pVfsCur->pFile = pVfsCur->pFile->pNext;
  }
  if( pVfsCur->pFile ){
    pVfsCur->pFile->nRef++;
  }
  return SQLITE_OK;
}

/* Return TRUE if we are at the end of the filesystem and there are
** no more files.
*/
static int th3vfsvtabEof(sqlite3_vtab_cursor *pCur){
  th3vfsvtabCursor *pVfsCur = (th3vfsvtabCursor*)pCur;
  return pVfsCur->pFile==0;
}

/* Return the Nth column of the current row.
*/
static int th3vfsvtabColumn(
  sqlite3_vtab_cursor *pCur,
  sqlite3_context *context,
  int N
){
  th3vfsvtabCursor *pVfsCur = (th3vfsvtabCursor*)pCur;
  th3vfsFile *pFile = pVfsCur->pFile;
  if( pFile==0 ){
    return SQLITE_OK;
  }
  switch( N ){
    case 0: {
      sqlite3_result_int(context, pFile->nRef-1);
      break;
    }
    case 1: {
      sqlite3_result_int64(context, pFile->sz);
      break;
    }
    case 2: {
      sqlite3_result_int64(context, pFile->szSync);
      break;
    }
    case 3: {
      sqlite3_result_int(context, pFile->zerogapStart);
      break;
    }
    case 4: {
      sqlite3_result_int(context, pFile->zerogapCount);
      break;
    }
    case 5: {
      sqlite3_result_int(context, pFile->notSynced);
      break;
    }
    case 6: {
      sqlite3_result_int(context, pFile->deleteOnClose);
      break;
    }
    case 7: {
      sqlite3_result_int(context, pFile->isExclusive);
      break;
    }
    case 8: {
      sqlite3_result_int(context, pFile->readOnly);
      break;
    }
    case 9: {
      sqlite3_result_int(context, pFile->nReadLock);
      break;
    }
    case 10: {
      sqlite3_result_int(context, pFile->mxLock);
      break;
    }
    case 11: {
      sqlite3_result_text(context, pFile->zFilename, -1, SQLITE_TRANSIENT);
      break;
    }
  }
  return SQLITE_OK;
}

/* Return the rowid of the current row
*/
static int th3vfsvtabRowid(sqlite3_vtab_cursor *pCur, sqlite3_int64 *pRowid){
  th3vfsvtabCursor *pVfsCur = (th3vfsvtabCursor*)pCur;
  th3vfsFile *pFile = pVfsCur->pFile;
  *pRowid = pFile ? pFile->rowid : 0;
  return SQLITE_OK;
}

/* Notify the virtual table implementation of a virtual table name change */
static int th3vfsvtabRename(sqlite3_vtab *pVtab, const char *zNew){
  return SQLITE_OK;  /* This implementation does not care. */
}

/*
** End of the TEST_VFS virtual table implementation
*****************************************************************************/





/************************************************************************
** Here begins the memory allocation fault simulator logic.
*/
/*
** This structure is used to encapsulate the global state variables used 
** by malloc() fault simulation.
**
** Because this is a global structure (and because the underlying SQLite
** library only has a single memory allocator layer) the OOM tests can
** only be carried out in one thread at a time.
*/
static struct Th3OomState {
  th3state *pThread;      /* The test thread */
  int iCountdown;         /* Number of pending successes before a failure */
  int nRepeat;            /* Number of times to repeat the failure */
  int nBenign;            /* Number of benign failures */
  int nFail;              /* Number of simulated failures */
  int nOverrun;           /* Number of test cases with no failures */
  u8 enable;              /* Enable error tracing */
  u8 inTest;              /* A test case has been started */
  u8 useRepeat;           /* True if doing multi-failure tests */
  u8 isInstalled;         /* True if the fault simulation layer is installed */
  u8 isBenignMode;        /* True if malloc failures are considered benign */
  u8 internalDisable;     /* True to disable for internal use */
  u8 enableAlarm;         /* Raise an exception on th3oomXxxx() calls */
  sqlite3 *interruptDb;   /* Call sqlite3_interrupt() rather than OOM */
  int iTestIter;          /* Test iteration counter */
  char zTestName[100];    /* Name of the test */
  int nTestName;          /* Size of the test base name */
  int initReturn;         /* Value returned by xInit method */
  sqlite3_mem_methods m;  /* Real malloc implementation */
  int nMalloc;            /* Number of calls to th3oomMalloc() */
  int nRealloc;           /* Number of calls to th3oomRealloc() */
  int nFree;              /* Number of calls to th3oomFree() */
  int nUsed;              /* Memory outstanding */
  int mxUsed;             /* Max used */ 
} th3oom;

/*
** Temporarily disable the OOM mechanism.  Internal routines such as
** th3_auth_check() call this to disable OOM for their processing.
*/
static void th3oomInternalDisable(int onoff){
  if( onoff ){
    th3oom.internalDisable++;
  }else{
    assert( th3oom.internalDisable>0 );
    th3oom.internalDisable--;
  }
}

/*
** This routine exists as a place to set a breakpoint that will
** fire on any simulated malloc() failure.
*/
static void th3oomFault(void){
  static int cnt = 0;
  cnt++;
}

/*
** Check to see if a fault should be simulated.  Return true to simulate
** the fault.  Return false if the fault should not be simulated.
**
** In the case of a simulated failure N memory allocation attempts are
** simulated.  For normal memory allocation attempts, N==1.  But in
** the TEST_VFS we simulate a double-allocation attempt.
*/
static int th3oomStep(int N){
  if( !th3oom.enable || th3oom.internalDisable ){
    return 0;
  }
  if( th3oom.iCountdown>0 ){
    th3oom.iCountdown--;
    return 0;
  }
  fsTrace(&th3oom.pThread->fsysTest, "OOM-FAULT\n");
  th3oomFault();
  th3oom.nFail++;
  if( th3oom.interruptDb ){
    sqlite3_interrupt(th3oom.interruptDb);
    th3oom.enable = 0;
    return 0;
  }
  if( th3oom.isBenignMode>0 ){
    th3oom.nBenign++;
  }
  th3oom.nRepeat -= N;
  if( th3oom.nRepeat<=0 ){
    th3oom.enable = 0;
  }
  return 1;  
}

/*
** A version of sqlite3_mem_methods.xMalloc() that includes fault simulation
** logic.
*/
static void *th3oomMalloc(int n){
  void *p = 0;
  assert( !th3oom.enableAlarm );
  th3oom.nMalloc++;
  if( !th3oomStep(1) ){
    p = th3oom.m.xMalloc(n);
    th3oom.nUsed += th3oom.m.xSize(p);
    if( th3oom.nUsed>th3oom.mxUsed ) th3oom.mxUsed = th3oom.nUsed;
  }
  return p;
}


/*
** A version of sqlite3_mem_methods.xRealloc() that includes fault simulation
** logic.
*/
static void *th3oomRealloc(void *pOld, int n){
  void *p = 0;
  assert( !th3oom.enableAlarm );
  th3oom.nRealloc++;
  if( n==0 || !th3oomStep(1) ){
    int oldSize = th3oom.m.xSize(pOld);
    p = th3oom.m.xRealloc(pOld, n);
    if( p ){
      th3oom.nUsed -= oldSize;
      assert( th3oom.nUsed>=0 );
      th3oom.nUsed += th3oom.m.xSize(p);
      if( th3oom.nUsed>th3oom.mxUsed ) th3oom.mxUsed = th3oom.nUsed;
    }
  }
  return p;
}

/* 
** The following method calls are passed directly through to the underlying
** malloc system:
**
**     xFree
**     xSize
**     xRoundup
**     xInit
**     xShutdown
*/
static void th3oomFree(void *p){
  assert( !th3oom.enableAlarm );
  th3oom.nFree++;
  th3oom.nUsed -= th3oom.m.xSize(p);
  assert( th3oom.nUsed>=0 );
  th3oom.m.xFree(p);
}
static int th3oomSize(void *p){
  return th3oom.m.xSize(p);
}
static int th3oomRoundup(int n){
  return th3oom.m.xRoundup(n);
}
static int th3oomInit(void *p){
  if( th3oom.initReturn ){
    return th3oom.initReturn;
  }else{
    return th3oom.m.xInit(th3oom.m.pAppData);
  }
}
static void th3oomShutdown(void *p){
  th3oom.m.xShutdown(th3oom.m.pAppData);
}

static void th3oomBeginBenign(void){
  th3oom.isBenignMode++;
}
static void th3oomEndBenign(void){
  th3oom.isBenignMode--;
}

/*
** Check to make sure that SQLITE_DBSTATUS_SCHEMA_USED and
** SQLITE_DBSTATUS_STMT_USED do not free any memory.
**
** These two measurement functions work by setting a flag that
** causes sqlite3DbFree() to count the size of memory allocations
** rather than actually freeing the allocations, then invoking
** routines to clear the schema or finalize all statements in order
** to get the size measurement.  This routine makes sure those
** routines do not accidently invoke sqlite3_free() instead of
** sqlite3DbFree().
**
** If any memory is allocated or freed, raise an assertion.
*/
static void th3verifyNoMemAllocDuringMemMeasurement(sqlite3 *db){
  if( th3oom.isInstalled ){
    int sz1, sz2;
    th3oom.enableAlarm++;
    sqlite3_db_status(db, SQLITE_DBSTATUS_SCHEMA_USED, &sz1, &sz2, 0);
    sqlite3_db_status(db, SQLITE_DBSTATUS_STMT_USED, &sz1, &sz2, 0);
    th3oom.enableAlarm--;
  }
}


/*
** Add or remove the fault-simulation layer using sqlite3_config(). If
** the argument is non-zero, the fault simulator is added.  If the
** argument is zero it is removed.  
**
** Attempting to install when already installed or remove when already
** removed is a harmless no-op.
**
** Return SQLITE_OK on success or a non-zero error code for a failure.
*/
static int th3oomInstall(int install){
  static struct sqlite3_mem_methods m = {   /* H10155 */
    th3oomMalloc,                   /* xMalloc */
    th3oomFree,                     /* xFree */
    th3oomRealloc,                  /* xRealloc */
    th3oomSize,                     /* xSize */
    th3oomRoundup,                  /* xRoundup */
    th3oomInit,                     /* xInit */
    th3oomShutdown,                 /* xShutdown */
    0                               /* pAppData */
  };
  int rc;

  install = (install ? 1 : 0);
  assert(th3oom.isInstalled==1 || th3oom.isInstalled==0);
  if( install==th3oom.isInstalled ){
    return SQLITE_OK;
  }

  if( install ){
    rc = sqlite3_config(SQLITE_CONFIG_GETMALLOC, &th3oom.m);
    assert(th3oom.m.xMalloc);
    if( rc==SQLITE_OK ){
      rc = sqlite3_config(SQLITE_CONFIG_MALLOC, &m);
    }
    sqlite3_test_control(SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS, 
        th3oomBeginBenign, th3oomEndBenign
    );
    th3oom.nUsed = th3oom.mxUsed = 0;
  }else{
    assert( th3oom.m.xMalloc );
    assert( th3oom.nUsed==0 );
    rc = sqlite3_config(SQLITE_CONFIG_MALLOC, &th3oom.m);
    sqlite3_test_control(SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS, 0, 0);
  }
  if( rc==SQLITE_OK ){
    th3oom.isInstalled = install;
  }
  return rc;
}

/*
** Return the high-water mark for OOM memory.
*/
int th3oomHighwater(int bReset){
  int x = th3oom.mxUsed;
  if( bReset ) th3oom.mxUsed = th3oom.nUsed;
  return x;
}

/*
** Begin a sequence of OOM tests.
*/
void th3oomBegin(th3state *p, const char *zName){
  assert( strlen(zName)<sizeof(th3oom.zTestName)-10 );
  if( (p->config.maskProp & TH3_NO_OOM)!=0 ) return;
  th3strcpy(th3oom.zTestName, zName);
  th3oom.pThread = p;
  th3oom.nOverrun = 0;
  th3oom.nTestName = strlen(th3oom.zTestName);
  th3oom.iTestIter = 0;
  th3oom.nRepeat = 1 + (p->config.softHeapLimit>0);
  th3oom.inTest = 0;
  th3oom.useRepeat = 0;
  th3oom.interruptDb = 0;
  assert( th3oom.internalDisable==0 );
}

/*
** End a test if one is currently in progress.
*/
void th3oomEnd(th3state *p){
  if( (p->config.maskProp & TH3_NO_OOM)==0 && th3oom.inTest ){
    th3testOk(p);
    assert( th3oom.internalDisable==0 );
    th3oom.inTest = 0;
  }
}

/*
** Start the next test in a sequence of OOM tests.  Return true to
** continue testing.  Return false if the test sequence has reached
** its end.
*/
int th3oomNext(th3state *p){
  if( (p->config.maskProp & TH3_NO_OOM)!=0 || !th3oom.isInstalled ){
    return 0;
  }
  assert( (p->config.maskProp & TH3_NO_OOM)==0 );
  th3oomEnd(p);
  if( th3oom.iTestIter>0 && th3oom.nFail==0 ){
    th3oom.nOverrun++;
    if( th3oom.nOverrun>=4 ){
      if( th3oom.useRepeat || th3oom.interruptDb!=0 ) return 0;
      th3oom.useRepeat = 1;
      th3oom.iTestIter = 0;
      th3oom.nOverrun = 0;
    }
  }else{
    th3oom.nOverrun = 0;
  }
  th3oom.iTestIter++;
  sqlite3_snprintf(20, &th3oom.zTestName[th3oom.nTestName], ".%d.%s",
               th3oom.iTestIter,
               th3oom.useRepeat ? "repeat" : "once");
  th3testBegin(p, th3oom.zTestName);
  th3oom.inTest = 1;
  th3oom.iCountdown = th3oom.iTestIter - 1;
  th3oom.nRepeat = th3oom.useRepeat ? 1000 : 1 + (p->config.softHeapLimit>0);
  th3oom.enable = 0;
  th3oom.isBenignMode = 0;
  th3oom.nFail = 0;
  th3oom.nBenign = 0;
  assert( th3oom.internalDisable==0 );
  return 1;
}

/* 
** Enable or disable the simulated OOM errors.
*/
void th3oomEnable(th3state *p, int en){
  assert( (p->config.maskProp & TH3_NO_OOM)==0 );
  th3oom.enable = en;
}

/*
** Return true if a non-benign OOM error was encountered.  If
** no OOM errors were seen or if all OOM errors were benign, then
** return false.
*/
int th3oomHit(th3state *p){
  assert( (p->config.maskProp & TH3_NO_OOM)==0 );
  return (th3oom.nFail - th3oom.nBenign)>0;
}

/*
** If boolean is false, then fail the current test case.  If it is
** true, then show progress by printing the "id".
*/
void th3oomCheck(th3state *p, int id, int boolean){
  assert( (p->config.maskProp & TH3_NO_OOM)==0 );
  if( th3oom.inTest ){
    if( boolean ){
#ifdef TH3_VERBOSE
      char zNum[30];
      sqlite3_snprintf(30, zNum, "%d ", id);
      th3print(p, zNum);
#endif
    }else{
      char zErr[100];
      th3oom.inTest = 0;
      sqlite3_snprintf(100, zErr, "%d", id);
      th3testFailed(p, zErr);
    }
  }
}

/*
** If zTruth does not match the p->zResult fail the test
*/
void th3oomResultCmp(
  th3state *p,
  int id,
  const char *zTruth,
  int (*xCmp)(const char*,const char*)
){
  assert( (p->config.maskProp & TH3_NO_OOM)==0 );
  if( th3oom.inTest ){
    if( 0==(*xCmp)(zTruth, p->zResult) ){
#ifdef TH3_VERBOSE
      char zNum[30];
      sqlite3_snprintf(30, zNum, "%d ", id);
      th3print(p, zNum);
#endif
    }else{
      char zErr[100];
      th3oom.inTest = 0;
      sqlite3_snprintf(100, zErr, "%d", id);
      th3testFailed(p, zErr);
      th3testShowResults(p, zTruth, p->zResult);
    }
  }
}
void th3oomResult(th3state *p, int id, const char *zTruth){
  th3oomResultCmp(p, id, zTruth, th3strcmp);
}
void th3oomResultGlob(th3state *p, int id, const char *zTruth){
  th3oomResultCmp(p, id, zTruth, th3strglob);
}
void th3oomResultNotGlob(th3state *p, int id, const char *zTruth){
  th3oomResultCmp(p, id, zTruth, th3strnotglob);
}


/*
** The all-in-one shortcut.
*/
void th3oomAllInOne(
  th3state *p,            /* Test state */
  const char *zName,      /* Name of the OOM test */
  const char *zSql,       /* SQL statements to be tested */
  const char *zTruth      /* Expected result when no OOM errors seen */
){
  th3oomBegin(p, zName);
  while( th3oomNext(p) ){
    int rc;
    th3dbNew(p, 0, "test.db");
    th3oomEnable(p, 1);
    rc = th3dbEval(p, 0, zSql);
    th3oomEnable(p, 0);
    if( th3oomHit(p) ){
      th3oomCheck(p, 1, rc==SQLITE_NOMEM );
    }else{
      th3oomCheck(p, 2, rc==SQLITE_OK );
      th3oomResult(p,3, zTruth);
    }
  }
  th3oomEnd(p);
}

/************************************************************************
** Here begins the I/O error simulation control logic.
*/

/*
** This routine is invoked whenever a simulated I/O error occurs.
** Use it as a place to set a breakpoint when trouble-shooting
** I/O error handling.
*/
static void th3ioerrFault(void){
  static int cnt = 0;
  cnt++;
}


/*
** Return true if it is time to simulate an I/O error.
** Methods of the TEST_VFS invokes this routine to see if they
** should run to completion or if they should return an error.
*/
static int th3ioerrSimulate(th3vfsFSys *p, int mask){
  if( p->ioerr.iCntdown==0 ) return 0;
  if( p->ioerr.enable==0 ) return 0;
  if( (p->ioerr.mask & mask)==0 ) return 0;
  if( p->ioerr.iCntdown==1 ){
    if( !p->ioerr.useRepeat ){
      /* In single failure mode, reduce the count-down so that no
      ** further errors will ever be generated */
      p->ioerr.iCntdown--;
#if 0
    }else if( p->ioerr.useRepeat && p->ioerr.isHit ){
      return 0;
#endif
    }
    fsTrace(p, "FAULT: %#x\n", mask);
    th3ioerrFault();
    p->ioerr.isHit = 1;
    return 1;
  }
  p->ioerr.iCntdown--;
  return 0;
}

/*
** Begin an I/O Error test loop.  The basename of the loop is given
** by zName.
*/
void th3ioerrBegin(th3state *p, const char *zName){
  if( (p->config.maskProp & TH3_TEST_VFS)==0 ) return;
  assert( strlen(zName)<sizeof(p->fsysTest.ioerr.zTestName)-10 );
  th3strcpy(p->fsysTest.ioerr.zTestName, zName);
  p->fsysTest.ioerr.nTestName = strlen(zName);
  p->fsysTest.ioerr.iCntdown = 0;
  p->fsysTest.ioerr.iTestIter = 0;
  p->fsysTest.ioerr.useRepeat = 0;
  p->fsysTest.ioerr.isHit = 0;
  p->fsysTest.ioerr.mask = TH3VFS_IOERR_ALL;
  p->fsysTest.ioerr.enable = 0;
}

/*
** Enable or disable simulation of I/O errors.
*/
void th3ioerrEnable(th3state *p, int enable){
  p->fsysTest.ioerr.enable = enable;
}

/*
** Return true if one or more I/O errors that have been simulated
** during the current test iteration.
*/
int th3ioerrHit(th3state *p){
  return p->fsysTest.ioerr.isHit>0;
}

/*
** Check to see if a test condition is true.  Terminate the test if
** the condition is false.
*/
void th3ioerrCheck(th3state *p, int id, int boolean){
  if( p->fsysTest.ioerr.inTest ){
    if( boolean ){
#ifdef TH3_VERBOSE
      char zNum[30];
      sqlite3_snprintf(30, zNum, "%d ", id);
      th3print(p, zNum);
#endif
    }else{
      char zErr[100];
      p->fsysTest.ioerr.inTest = 0;
      sqlite3_snprintf(100, zErr, "%d", id);
      th3testFailed(p, zErr);
    }
  }
}

/*
** Compare zTruth against the results of a test.
*/
void th3ioerrResultCmp(
  th3state *p,
  int id,
  const char *zTruth,
  int (*xCmp)(const char*,const char*)
){
  if( p->fsysTest.ioerr.inTest ){
    if( 0==xCmp(zTruth, p->zResult) ){
#ifdef TH3_VERBOSE
      char zNum[30];
      sqlite3_snprintf(30, zNum, "%d ", id);
      th3print(p, zNum);
#endif
    }else{
      char zErr[100];
      p->fsysTest.ioerr.inTest = 0;
      sqlite3_snprintf(100, zErr, "%d", id);
      th3testFailed(p, zErr);
      th3testShowResults(p, zTruth, p->zResult);
    }
  }
}
void th3ioerrResult(th3state *p, int id, const char *zTruth){
  th3ioerrResultCmp(p,id,zTruth,th3strcmp);
}
void th3ioerrResultGlob(th3state *p, int id, const char *zTruth){
  th3ioerrResultCmp(p,id,zTruth,th3strglob);
}
void th3ioerrResultNotGlob(th3state *p, int id, const char *zTruth){
  th3ioerrResultCmp(p,id,zTruth,th3strnotglob);
}


/*
** Terminate an I/O error test
*/
void th3ioerrEnd(th3state *p){
  if( (p->config.maskProp & TH3_TEST_VFS)!=0 && p->fsysTest.ioerr.inTest ){
    th3testOk(p);
    p->fsysTest.ioerr.inTest = 0;
  }
}

/*
** Advance to the next iteration of an I/O test loop.  Return true
** if another iteration is needed.  Return false if testing has finished.
*/
int th3ioerrNext(th3state *p){
  if( (p->config.maskProp & TH3_TEST_VFS)==0 ){
    return 0;
  }
  th3ioerrEnd(p);
  if( p->fsysTest.ioerr.iTestIter>0 && p->fsysTest.ioerr.isHit==0 ){
    p->fsysTest.ioerr.nOverrun++;
    if( p->fsysTest.ioerr.nOverrun>=4 ){
      if( p->fsysTest.ioerr.useRepeat ) return 0;
      p->fsysTest.ioerr.useRepeat = 1;
      p->fsysTest.ioerr.iTestIter = 0;
      p->fsysTest.ioerr.nOverrun = 0;
    }
  }else{
    p->fsysTest.ioerr.nOverrun = 0;
  }
  p->fsysTest.ioerr.iTestIter++;
  sqlite3_snprintf(20,
        &p->fsysTest.ioerr.zTestName[p->fsysTest.ioerr.nTestName], ".%d.%s",
        p->fsysTest.ioerr.iTestIter,
        p->fsysTest.ioerr.useRepeat ? "repeat" : "once"
  );
  th3testBegin(p, p->fsysTest.ioerr.zTestName);
  p->fsysTest.ioerr.inTest = 1;
  p->fsysTest.ioerr.iCntdown = p->fsysTest.ioerr.iTestIter;
  p->fsysTest.ioerr.enable = 0;
  p->fsysTest.ioerr.isHit = 0;
  return 1;
}

/*
** This is a convenience routine for doing I/O error testing on
** a block of SQL.
*/
void th3ioerrAllInOne(
  th3state *p,            /* The test status */
  const char *zName,      /* Base name of the I/O error test */
  const char *zSql,       /* SQL to run */
  const char *zTruth      /* Output if SQL is successful */
){
  th3ioerrBegin(p, zName);
  while( th3ioerrNext(p) ){
    int rc;
    th3dbNew(p, 0, "test.db");
    th3ioerrEnable(p, 1);
    rc = th3dbEval(p, 0, zSql);
    th3ioerrEnable(p, 0);
    if( th3ioerrHit(p) && rc ){
      th3ioerrCheck(p, 1, (rc&0xff)==SQLITE_IOERR || (rc&0xff)==SQLITE_FULL );
    }else{
      th3ioerrCheck(p, 2, rc==SQLITE_OK );
      th3ioerrResult(p,3, zTruth);
    }
  }
  th3ioerrEnd(p);
}
/*
** End of I/O error simulation control logic.
*************************************************************************/

/************************************************************************
** Here begins the alternative page cache implementation
*/

/* Forward reference to the object that stores a complete ALT_PCACHE */
typedef struct th3testpcache th3testpcache;

/*
** Global data used by this test implementation.  There is no
** mutexing, which means this page cache will not work in a
** multi-threaded test.
*/
typedef struct th3testpcacheGlobalType th3testpcacheGlobalType;
struct th3testpcacheGlobalType {
  void *pDummy;                 /* Dummy allocation to check for leaks */
  int nInstance;                /* Number of current instances */
  unsigned discardChance;       /* Chance of discarding on an unpin */
  unsigned stressChance;        /* Chance of allocation failure on fetch */
  unsigned prngSeed;            /* Seed for the PRNG */
  int initReturn;               /* Value returned by xInit() when no errors */
  int mxPage;                   /* Maximum number of pages to cache */
  th3testpcache *pCorruptible;  /* Pcache capable of being corrupted */
  int factorR;                  /* Extra space on each page */
  int factorR2;                 /* Second value for R used with ZIPVFS */
  int nInit;                    /* Number of xInit() calls */
  int nShutdown;                /* Number of xDestroy() calls */
  int nCreate;                  /* Number of xCreate calls, total */
  int nCreatePurgeable;         /* Nr. of xCreate() with bPurgeable true */
};
static th3testpcacheGlobalType th3testpcacheGlobal = { 
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
};

/*
** Initializer.
**
** Verify that the initializer is only called when the system is
** uninitialized.  Allocate some memory and report SQLITE_NOMEM if
** the allocation fails.  This provides a means to test the recovery
** from a failed initialization attempt.  It also verifies that the
** the destructor always gets call - otherwise there would be a
** memory leak.
*/
static int th3testpcacheInit(void *pArg){

  /* EVIDENCE-OF: R-40691-50734 The xInit() method is passed a copy of the
  ** sqlite3_pcache_methods.pArg value. */
  assert( pArg==(void*)&th3testpcacheGlobal );

  /* EVIDENCE-OF: R-58778-10776 The xInit() method is called once for each
  ** effective call to sqlite3_initialize()
  **
  ** EVIDENCE-OF: R-25048-46581 SQLite will never invoke xInit() more than
  ** once without an intervening call to xShutdown(). */
  assert( th3testpcacheGlobal.pDummy==0 );

  assert( th3testpcacheGlobal.nInstance==0 );
  if( th3testpcacheGlobal.initReturn ){
    return th3testpcacheGlobal.initReturn;
  }
  th3testpcacheGlobal.pDummy = sqlite3_malloc(10);
  if( th3testpcacheGlobal.pDummy==0 ){
    return SQLITE_NOMEM;
  }
  th3testpcacheGlobal.nInit++;
  return SQLITE_OK;
}

/*
** Destructor
**
** Verify that this is only called after initialization.
** Free the memory allocated by the initializer.
*/
static void th3testpcacheShutdown(void *pArg){
  assert( pArg==(void*)&th3testpcacheGlobal );
  assert( th3testpcacheGlobal.pDummy!=0 );
  assert( th3testpcacheGlobal.nInstance==0 );
  sqlite3_free( th3testpcacheGlobal.pDummy );
  th3testpcacheGlobal.pDummy = 0;
  th3testpcacheGlobal.nShutdown++;
}

/*
** Number of pages in a cache
*/
#define TESTPCACHE_MXPAGE    353
#define TESTPCACHE_RESERVE   17
#define TESTPCACHE_NHASH     101

/*
** Magic numbers used to determine validity of the page cache.
*/
#define TESTPCACHE_VALID  0x364585fd
#define TESTPCACHE_CLEAR  0xd42670d4

/*
** Private implementation of a page cache.
*/
typedef struct th3testpcachePage th3pcachePage;
struct th3testpcachePage {
  unsigned key;              /* The key for this page. 0 means unallocated */
  int isPinned;              /* True if the page is pinned */
  void *pData;               /* Data for this page */
  th3pcachePage **ppPrev;    /* Previous element of collision chain */
  th3pcachePage *pNext;      /* Hash collision chain */
};
struct th3testpcache {
  int szPage;               /* Size of each page.  Multiple of 8. */
  int bPurgeable;           /* True if the page cache is purgeable */
  int nFree;                /* Number of unused slots in a[] */
  int nPinned;              /* Number of pinned slots in a[] */
  th3prng sRand;            /* State of the PRNG */
  unsigned iPcacheMagic;                    /* Magic number for sanity */
  th3pcachePage a[TESTPCACHE_MXPAGE];       /* Cache content */
  th3pcachePage *apHash[TESTPCACHE_NHASH];  /* Hash table */
};

#define TESTPCACHE_HASH(pgno)  (((pgno)&0x7fffffff)%TESTPCACHE_NHASH)

/*
** Get a random number using the PRNG in the given page cache.
*/
static unsigned th3testpcacheRandom(th3testpcache *p){
  p->sRand.x = (p->sRand.x>>1) ^ (-(p->sRand.x&1) & 0xd0000001);
  p->sRand.y = p->sRand.y*1103515245 + 12345;
  return p->sRand.x ^ p->sRand.y;
}

#ifndef SQLITE_CONFIG_GETPCACHE
typedef struct sqlite3_pcache sqlite3_pcache;
#endif

/*
** Insert a testpcache page into its hash chain.
*/
static void th3testpcacheLink(
  struct th3testpcache *pCache,
  th3pcachePage *pPage
){
  int h = TESTPCACHE_HASH(pPage->key);
  pPage->pNext = pCache->apHash[h];
  if( pPage->pNext ) pPage->pNext->ppPrev = &pPage->pNext;
  pPage->ppPrev = &pCache->apHash[h];
  pCache->apHash[h] = pPage;
}

/*
** Look up a page and return a pointer to it.  Return NULL if not found.
*/
static th3pcachePage *th3testpcacheLookup(
  struct th3testpcache *pCache,
  int key
){
  th3pcachePage *p;
  int h = TESTPCACHE_HASH(key);
  for(p=pCache->apHash[h]; p && p->key!=key; p=p->pNext){}
  return p;
}

/*
** Unlink a page from the hash chain.
*/
static void th3testpcacheRelink(
  struct th3testpcache *pCache,
  th3pcachePage *pPage,
  int newKey
){
  if( pPage->pNext ) pPage->pNext->ppPrev = pPage->ppPrev;
  *pPage->ppPrev = pPage->pNext;
  pPage->key = newKey;
  th3testpcacheLink(pCache, pPage);
}

/*
** Allocate a new page cache instance.
**
** EVIDENCE-OF: R-33368-33178 The first parameter, szPage, is the size in
** bytes of the pages that must be allocated by the cache.
*/
static sqlite3_pcache *th3testpcacheCreate(int szPage, int bPurgeable){
  int nMem;
  char *x;
  th3testpcache *p;
  int i, pow2, factorR;
  int szPageRoundup;
  th3pcachePage *pPage;

  /* EVIDENCE-OF: R-62352-57724 szPage will not be a power of two. */
  assert( (szPage&(szPage-1))!=0 );

  /* EVIDENCE-OF: R-01831-31796 szPage will the page size of the database
  ** file that is to be cached plus an increment (here called "R") of less
  ** than 250.
  */
  for(pow2=512; pow2*2<szPage; pow2=pow2*2){}
  factorR = szPage - pow2;
  assert( factorR>0 && factorR<250 );

  /* EVIDENCE-OF: R-52909-18113 R is constant for a particular build of
  ** SQLite.  Except, there are two distinct values of R when SQLite is
  ** compiled with the proprietary ZIPVFS extension. */
#ifndef SQLITE_ENABLE_ZIPVFS
  assert( th3testpcacheGlobal.factorR==0
          || th3testpcacheGlobal.factorR==factorR );
  th3testpcacheGlobal.factorR = factorR;
#else
  assert( th3testpcacheGlobal.factorR==0
          || th3testpcacheGlobal.factorR==factorR
          || th3testpcacheGlobal.factorR2==0
          || th3testpcacheGlobal.factorR2==factorR
  );
  if( th3testpcacheGlobal.factorR==0 || th3testpcacheGlobal.factorR==factorR ){
    th3testpcacheGlobal.factorR = factorR;
  }else{
    th3testpcacheGlobal.factorR2 = factorR;
  }
#endif

  assert( th3testpcacheGlobal.pDummy!=0 );
  szPageRoundup = (szPage+8+7)&~7;
  nMem = sizeof(th3testpcache) + TESTPCACHE_MXPAGE*(szPageRoundup + 8) + 16;
  p = sqlite3_malloc( nMem );
  if( p==0 ) return 0;
  memset(p, 0, sizeof(th3testpcache));
  x = (char*)&p[1];
  p->szPage = szPage;
  p->nFree = TESTPCACHE_MXPAGE;
  p->nPinned = 0;
  p->sRand.y = th3testpcacheGlobal.prngSeed;
  p->sRand.x = p->sRand.y | 1;
  p->bPurgeable = bPurgeable;
  p->iPcacheMagic = TESTPCACHE_VALID;
  for(i=0, pPage=p->a; i<TESTPCACHE_MXPAGE; i++, x += szPageRoundup, pPage++){
    x += 8;
    pPage->pData = (void*)x;
    ((th3pcachePage**)x)[-1] = pPage;
    memset(&x[szPage], 0, 8);  /* Allow for up to 8-byte overread */
    pPage->key = 0;
    th3testpcacheLink(p, pPage);
  }
  th3testpcacheGlobal.nInstance++;
  th3testpcacheGlobal.nCreate++;
  if( bPurgeable ) th3testpcacheGlobal.nCreatePurgeable++;
  return (sqlite3_pcache*)p;
}

/*
** Set the cache size.
**
** ALT_PCACHE ignores the cache size setting.  The cache size is fixed
** at TESTPCACHE_MXPAGE pages.  However, if an attempt is made to set
** the cache size to the magic number 8888, then the pcache becomes
** the "corruptible pcache" that can be written to (and thereby 
** corrupted for testing purposes) using the th3testpcacheCorrupt()
** interface.  There is only a single corruptible pcache.  When a new
** corruptible pcache is set, the old one is overridden.
*/
static void th3testpcacheCachesize(sqlite3_pcache *pCache, int newSize){
  th3testpcache *p = (th3testpcache*)pCache;
  assert( p->iPcacheMagic==TESTPCACHE_VALID );
  assert( th3testpcacheGlobal.pDummy!=0 );
  assert( th3testpcacheGlobal.nInstance>0 );
  if( newSize==8888 ){
    th3testpcacheGlobal.pCorruptible = p;
  }
}

/*
** Return the number of pages in the cache that are being used.
** This includes both pinned and unpinned pages.
*/
static int th3testpcachePagecount(sqlite3_pcache *pCache){
  th3testpcache *p = (th3testpcache*)pCache;
  assert( p->iPcacheMagic==TESTPCACHE_VALID );
  assert( th3testpcacheGlobal.pDummy!=0 );
  assert( th3testpcacheGlobal.nInstance>0 );
  return TESTPCACHE_MXPAGE - p->nFree;
}

/*
** Fetch a page.
*/
static void *th3testpcacheFetch(
  sqlite3_pcache *pCache,
  unsigned key,
  int createFlag
){
  th3testpcache *p = (th3testpcache*)pCache;
  int i, j, sc;
  th3pcachePage *pPage;
  assert( p->iPcacheMagic==TESTPCACHE_VALID );
  assert( th3testpcacheGlobal.pDummy!=0 );
  assert( th3testpcacheGlobal.nInstance>0 );

  /* EVIDENCE-OF: R-54020-18969 The minimum key value is 1. */
  assert( key>=1 );

  /* See if the page is already in cache.  Return immediately if it is */
  pPage = th3testpcacheLookup(p, key);
  if( pPage ){
    if( !pPage->isPinned ){
      p->nPinned++;
      assert( p->nPinned <= TESTPCACHE_MXPAGE - p->nFree );
      pPage->isPinned = 1;
    }
    assert( ((th3pcachePage**)pPage->pData)[-1]==pPage );
    return pPage->pData;
  }

  /* If createFlag is 0, never allocate a new page */
  if( createFlag==0 ){
    return 0;
  }

  /* When th3testpcacheGlobal.stressChance is the chance (0 = not possible
  ** and 100 == certainty) that allocations with createFlag less than 2
  ** will fail.  Failed allocates provoke calls to pagerStress()
  */
  sc = th3testpcacheGlobal.stressChance;
  if( createFlag<2 && sc>0 && (100-sc) <= (th3testpcacheRandom(p)%100) ){
    return 0;
  }

  /* If no pages are available, always fail */
  if( p->nPinned==TESTPCACHE_MXPAGE ){
    if( !p->bPurgeable ){
      th3panic("ALT_PCACHE overflow on a non-purgeable cache");
    }
    return 0;
  }

  /* Do not allocate the last TESTPCACHE_RESERVE pages unless createFlag is 2 */
  if( p->nPinned>=(th3testpcacheGlobal.mxPage-TESTPCACHE_RESERVE)
   && createFlag<2
  ){
    return 0;
  }

  /* Find a free page to allocate if there are any free pages.
  ** Withhold TESTPCACHE_RESERVE free pages until createFlag is 2.
  */
  if( p->nFree>TESTPCACHE_RESERVE || (createFlag==2 && p->nFree>0) ){
    pPage = th3testpcacheLookup(p, 0);
    assert( pPage!=0 );
    th3testpcacheRelink(p, pPage, key);
    pPage->isPinned = 1;
    th3memset(pPage->pData, 0, p->szPage);
    p->nPinned++;
    p->nFree--;
    assert( p->nPinned <= TESTPCACHE_MXPAGE - p->nFree );
    assert( ((th3pcachePage**)pPage->pData)[-1]==pPage );
    return pPage->pData;
  }

  /* If there are no free pages, recycle a page.  The page to
  ** recycle is selected at random from all unpinned pages.
  */
  j = th3testpcacheRandom(p) % TESTPCACHE_MXPAGE;
  for(i=0; i<TESTPCACHE_MXPAGE; i++, j = (j+1)%TESTPCACHE_MXPAGE){
    pPage = &p->a[j];
    if( pPage->key>0 && pPage->isPinned==0 ){
      /* Only a purgeable cache can contain unpinned pages */
      assert( p->bPurgeable );
      th3testpcacheRelink(p, pPage, key);
      pPage->isPinned = 1;
      th3memset(pPage->pData, 0, p->szPage);
      p->nPinned++;
      assert( p->nPinned <= TESTPCACHE_MXPAGE - p->nFree );
      assert( ((th3pcachePage**)pPage->pData)[-1]==pPage );
      return pPage->pData;
    }
  }

  /* The previous loop always finds a page to recycle. */
  assert(0);
  return 0;
}

/*
** Unpin a page.
*/
static void th3testpcacheUnpin(
  sqlite3_pcache *pCache,
  void *pOldPage,
  int discard
){
  th3testpcache *p = (th3testpcache*)pCache;
  int dc;
  th3pcachePage *pPage;
  assert( p->iPcacheMagic==TESTPCACHE_VALID );
  assert( th3testpcacheGlobal.pDummy!=0 );
  assert( th3testpcacheGlobal.nInstance>0 );

  /* EVIDENCE-OF: R-39150-60222 On a cache where bPurgeable is false,
  ** SQLite will never invoke xUnpin() except to deliberately delete a
  ** page. */
  assert( p->bPurgeable || discard );

  /* Randomly discard pages as they are unpinned according to the
  ** discardChance setting.  If discardChance is 0, the random discard
  ** never happens.  If discardChance is 100, it always happens.
  */
  dc = th3testpcacheGlobal.discardChance;
  if( dc>0 && (100-dc) <= (th3testpcacheRandom(p)%100) ){
    discard = 1;
  }

  pPage = ((th3pcachePage**)pOldPage)[-1];
  assert( pPage->pData==pOldPage );
  assert( pPage->isPinned );
  pPage->isPinned = 0;
  p->nPinned--;
  assert( p->nPinned>=0 );
  if( discard ){
    th3testpcacheRelink(p, pPage, 0);
    p->nFree++;
    assert( p->nFree<=TESTPCACHE_MXPAGE );
  }
}


/*
** Modify a single byte of the payload of a page in the corruptible pcache.
**
** The "corruptible pcache" is the pcache which most recently had its cache
** size set to 8888 using "PRAGMA cache_size=8888;".  If there is no 
** corruptible pcache, then change nothing and return non-zero.
**
** If the byte of the database file at offset iOffset is contained within
** the pcache, then change the value of that byte to iVal and return zero.
** If that byte is not within the pcache, then this routine makes not
** changes to the pcache and returns non-zero.
**
** In other words, attempt to change the cached value of the iOffset-th byte
** of the database file to iVal, returning zero on success or non-zero if
** no changes could be made.
*/
int th3testpcacheCorrupt(sqlite3_int64 iOffset, int iVal){
  th3testpcache *p;  /* The ALT_PCACHE whose content is to be changed */
  int szDbPage;      /* Page size of the underlying database file */
  unsigned int pgno; /* Page number of the database file to change */
  int idx;           /* Index into database page of byte to change */
  u8 *pCachedPage;   /* Cached page content */
  th3pcachePage *pPage;  /* Page to be corrupted */

  p = th3testpcacheGlobal.pCorruptible;
  if( p==0 ) return 1;

  for(szDbPage=512; szDbPage*2<p->szPage; szDbPage *= 2){}
  pgno = 1 + iOffset/szDbPage;

  /* Look for the page in the cache */
  pPage = th3testpcacheLookup(p, pgno);
  if( pPage ){
    pCachedPage = pPage->pData;
    assert( ((th3pcachePage**)pCachedPage)[-1]==pPage );
    idx = iOffset - (pgno-1)*szDbPage;
    idx += sqlite3_test_control(SQLITE_TESTCTRL_PGHDRSZ);
    pCachedPage[idx] = iVal;
    return 0;
  }

  /* Page not found */
  return 1;
}

/*
** Rekey a single page.
*/
static void th3testpcacheRekey(
  sqlite3_pcache *pCache,
  void *pOldPage,
  unsigned oldKey,
  unsigned newKey
){
  th3testpcache *p = (th3testpcache*)pCache;
  th3pcachePage *pPage;
  assert( p->iPcacheMagic==TESTPCACHE_VALID );
  assert( th3testpcacheGlobal.pDummy!=0 );
  assert( th3testpcacheGlobal.nInstance>0 );

  /* If there already exists another page at newKey, verify that
  ** the other page is unpinned and discard it.
  */
  assert( newKey!=0 );
  pPage = th3testpcacheLookup(p, newKey);
  if( pPage ){
    assert( pPage->isPinned==0 );
    th3testpcacheRelink(p, pPage, 0);
    p->nFree++;
    assert( p->nFree<=TESTPCACHE_MXPAGE );
  }

  /* Find the page to be rekeyed and rekey it.
  */
  assert( oldKey!=0 );
  pPage = th3testpcacheLookup(p, oldKey);
  assert( pPage );
  /* The oldKey and pOldPage parameters match */
  assert( pPage->pData==pOldPage );
  /* Page to be rekeyed must be pinned */
  assert( pPage->isPinned );
  th3testpcacheRelink(p, pPage, newKey);
}


/*
** Truncate the page cache.  Every page with a key of iLimit or larger
** is discarded.
*/
static void th3testpcacheTruncate(sqlite3_pcache *pCache, unsigned iLimit){
  th3testpcache *p = (th3testpcache*)pCache;
  unsigned int i;
  th3pcachePage *pPage;
  assert( p->iPcacheMagic==TESTPCACHE_VALID );
  assert( th3testpcacheGlobal.pDummy!=0 );
  assert( th3testpcacheGlobal.nInstance>0 );
  for(i=0, pPage=p->a; i<TESTPCACHE_MXPAGE; i++, pPage++){
    if( pPage->key>=iLimit ){
      th3testpcacheRelink(p, pPage, 0);
      if( pPage->isPinned ){
        p->nPinned--;
        assert( p->nPinned>=0 );
      }
      p->nFree++;
      assert( p->nFree<=TESTPCACHE_MXPAGE );
    }
  }
}

/*
** Destroy a page cache.
**
** EVIDENCE-OF: R-19808-29370 The xDestroy() method is used to delete a
** cache allocated by xCreate().
*/
static void th3testpcacheDestroy(sqlite3_pcache *pCache){
  th3testpcache *p = (th3testpcache*)pCache;
  assert( p->iPcacheMagic==TESTPCACHE_VALID );
  assert( th3testpcacheGlobal.pDummy!=0 );
  assert( th3testpcacheGlobal.nInstance>0 );

  /* EVIDENCE-OF: R-02532-17411 After calling the xDestroy() method, SQLite
  ** considers the sqlite3_pcache* handle invalid, and will not use it with
  ** any other sqlite3_pcache_methods functions.
  **
  ** Proof of the above is that iPcacheMagic is set to a value other than
  ** TESTPCACHE_VALID and will thus fail assert()s on other methods.
  ** Further proof is that the sqlite3_pcache object is deallocated,
  ** so further access attempts will cause a heap fault in valgrind and
  ** in memsys2.
  */
  p->iPcacheMagic = TESTPCACHE_CLEAR;
  if( th3testpcacheGlobal.pCorruptible==p ){
    th3testpcacheGlobal.pCorruptible = 0;
  }
  sqlite3_free(p);
  th3testpcacheGlobal.nInstance--;
}


/*
** Invoke this routine to register or unregister the testing pager cache
** implemented by this file.
**
** Install the test pager cache if installFlag is 1 and uninstall it if
** installFlag is 0.
**
** When installing, discardChance is a number between 0 and 100 that
** indicates the probability of discarding a page when unpinning the
** page.  0 means never discard (unless the discard flag is set).
** 100 means always discard.
*/
void th3testpcacheInstall(
  int installFlag,            /* True to install.  False to uninstall. */
  unsigned discardChance,     /* 0-100.  Chance to discard on unpin */
  unsigned prngSeed,          /* Seed for the PRNG */
  unsigned stressChance       /* Chance of allocation failure */
){
  static const sqlite3_pcache_methods testPcache = {
    (void*)&th3testpcacheGlobal,
    th3testpcacheInit,
    th3testpcacheShutdown,
    th3testpcacheCreate,
    th3testpcacheCachesize,
    th3testpcachePagecount,
    th3testpcacheFetch,
    th3testpcacheUnpin,
    th3testpcacheRekey,
    th3testpcacheTruncate,
    th3testpcacheDestroy,
  };
  static sqlite3_pcache_methods defaultPcache;
  static int isInstalled = 0;
  sqlite3_pcache_methods x;

  assert( th3testpcacheGlobal.nInstance==0 );
  assert( th3testpcacheGlobal.pDummy==0 );
  assert( discardChance<=100 );
  assert( stressChance<=100 );
  th3testpcacheGlobal.mxPage = TESTPCACHE_MXPAGE;
  th3testpcacheGlobal.stressChance = stressChance;
  th3testpcacheGlobal.discardChance = discardChance;
  th3testpcacheGlobal.prngSeed = prngSeed ^ (prngSeed<<16);
  if( installFlag!=isInstalled ){
    if( installFlag ){
      sqlite3_config(SQLITE_CONFIG_PCACHE, &defaultPcache);
      sqlite3_config(SQLITE_CONFIG_GETPCACHE, &defaultPcache);
      assert( defaultPcache.xInit!=0 );
      assert( defaultPcache.xCreate!=th3testpcacheCreate );
      memcpy(&x, &testPcache, sizeof(x));
      /* EVIDENCE-OF: R-05211-22178 The sqlite3_config(SQLITE_CONFIG_PCACHE,
      ** ...) interface can register an alternative page cache implementation
      ** by passing in an instance of the sqlite3_pcache_methods structure. */
      sqlite3_config(SQLITE_CONFIG_PCACHE, &x);
      /* EVIDENCE-OF: R-59693-18818 The contents of the sqlite3_pcache_methods
      ** structure are copied to an internal buffer by SQLite within the call
      ** to sqlite3_config. Hence the application may discard the parameter
      ** after the call to sqlite3_config() returns. */
      memset(&x, 0, sizeof(x));
    }else{
      assert( defaultPcache.xCreate!=0 );
      sqlite3_config(SQLITE_CONFIG_PCACHE, &defaultPcache);
    }
    isInstalled = installFlag;
  }
}
/*
** End of the alternative page cache implementation
*************************************************************************/

/************************************************************************
** Here begins the script-test module.
*/

/*
** Find the length of the next line of input.  Also do some
** primitive parsing of the line:
**
** If the line begins with "--command" then make
** *pnCmd be the number of characters in "command".
** If --command has an argument, make *piArg be the
** index of the first character of that argument and
** make *pnArg be the number of characters in that
** argument.  (Whitespace at the beginning and end of
** the argument is removed.)  If --command has no
** argument, then *piCmd and *pnCmd are both set to 0.
**
** Return the number of characters in the line including the
** \n that terminates the line.
*/
static int th3testScriptLine(
  const char *z,     /* The line of script to be parsed */
  int *pnCmd,        /* Write command length here.  Or 0 if not a command */
  int *piArg,        /* First character of argument */
  int *pnArg         /* Length of argument */
){
  int i, j;
  *piArg = 0;
  *pnArg = 0;
  *pnCmd = 0;
  if( z[0]=='-' && z[1]=='-' && th3isalpha(z[2]) ){
    for(i=3; th3isalnum(z[i]) || z[i]=='-' || z[i]=='_'; i++){}
    *pnCmd = i-2;
    while( z[i]!='\n' && th3isspace(z[i]) ){ i++; }
    if( z[i]=='\n' ){
      return i+1;
    }
    *piArg = i;
    while( z[i]!='\n' ){ assert(z[i]!=0); i++; }
    for(j=i-1; th3isspace(z[j]); j--){}
    *pnArg = j - *piArg + 1;
    return i+1;
  }
  for(i=0; z[i]!='\n'; i++){ assert(z[i]!=0); }
  return i+1;
}

/*
** Append scan and sort counts to the results
*/
static void th3testAppendScan(th3state *p){
  th3testAppendResultTerm(p, "scan");
  th3testAppendResultTerm(p, th3format(p, "%d", p->nStep));
  th3testAppendResultTerm(p, "sort");
  th3testAppendResultTerm(p, th3format(p, "%d", p->nSort));
}

/*
** This routine exists as a place to set a breakpoint in a debugger.
** The breakpoint will fire when a comment of the form --breakpoint
** is seen in a script.
*/
static void test_breakpoint(void){
  static int cnt = 0;
  cnt++;
  return;
}

/*
** Read and process the script given in zScript[].  The script
** is guaranteed to end with a \n followed by a \000.
**
** Special comments within the script are used to identify tests.
**
**    --testcase NAME
**    --result TRUTH
**    --glob TRUTH-PATTERN
**    --notglob PATTERN-NOT-MATCHED
**    --oom
**    --oom-err
**    --oom-ck
**    --ioerr
**    --if EXPR
**    --else
**    --endif
**    --column-names
**    --scan-count
**    --filename NAME
**    --store VARIABLE
**    --store-raw VARIABLE
**    --table TABLE
**    --run N
**    --bind-reset
**    --convert-filename
**    --new-filename
**    --new FILE
**    --raw-new FILE
**    --open FILE ?ro?
**    --raw-open FILE ?ro?
**    --db N
**    --auth-log DB
**    --auth-check DB
**    --date TIMESTAMP
**    --edit FILENAME
**    --checkpoint
**    --autocheckpoint N
**    --stmt-cache N
**    --stmt-cache-reset
**    --prepare_v2
**    --snapshot
**    --commit-snapshot
**    --revert
**    --close N|all
**    --reserve N
**    --readonly PREFIX
**    --cklog PATTERN
**    --call PROCEDURE    # MIXED modules only
**
** For debugging:
**
**    --breakpoint
**    --trace 0|1
**    --exit
*/
void th3testScript(
  th3state *p,
  const char *zScript,
  void (*callList[])(th3state*,int,char*)
){
  int i;                   /* For looping through zScript[] */
  int n;                   /* Number of characters in the next line */
  int iTestcase = 0;       /* Start of the test case name */
  int nTestcase = 0;       /* Length of the test case name */
  int iStart = 0;          /* Start of current test case */
  int nCmd;                /* Length of command */
  int iArg;                /* Index of argument to command */
  int nArg;                /* Length of argument */
  int oomTest;             /* 1: --oom. 4: --oom-ck  5: --oom-err */
  int ioerrTest;           /* True to run an I/O error test loop */
  int ioerrMask;           /* Mask of errors to simulate */
  int revertTest;          /* True if revert during current test */
  int disabledByIf = 0;    /* Disable most processing if non-zero */
  int iDb = 0;             /* Which database connection to use */
  int enableScan = 0;      /* True to report scan and sort counts */
  int traceOn = 0;         /* True for debug tracing */
  char *z;                 /* Generic string pointer */
  int openFlags;           /* Flags used to open the database */
  char zOpenDb[100];       /* Name of a database file to open */

  th3dbNew(p, 0, "test.db");    /* Initially open one database, number 0 */
  oomTest = 0;                  /* OOM testing initially turned off */
  ioerrTest = 0;                /* I/O error testing is initially turned off */
  revertTest = 0;               /* Revert testing is initially off */
  zOpenDb[0] = 0;               /* Disable reopens in --oom tests */

  /* Loop over the entire script, processing on line at a time */
  for(i=0; zScript[i]; i+=n){

    /* Extract the next line of text from the input script. */
    n = th3testScriptLine(&zScript[i], &nCmd, &iArg, &nArg);
    if( traceOn ){
      th3Nprint(p, &zScript[i], n);
      th3flush(p);
    }


    /* If the current line of text begins with "--" and a command, then
    ** process that command.
    */
    if( nCmd ){
      const char *zCmd = &zScript[i+2];

      /* Evaluate the --if argument using a SELECT statement.  If the result is
      ** false (zero) then disable everything through the corresponding --endif
      */
      if( nCmd==2 && memcmp(zCmd, "if", 2)==0 ){
        if( disabledByIf ){
          disabledByIf++;
        }else{
          th3testResetResult(p);
          th3dbEval(p, iDb, th3format(p,"SELECT %.*s", nArg, &zScript[i+iArg]));
          if( p->zResult && p->zResult[0] && th3atoi64(p->zResult)==0 ){
            disabledByIf = 1;
          }
          th3testResetResult(p);
        }
      }else

      /* The --else command: If currently disabled at the top-level,
      ** the enable processing.
      */
      if( nCmd==4 && memcmp(zCmd, "else", 4)==0 ){
        if( disabledByIf==1 ){
          disabledByIf = 0;
          iStart = i + n;
        }else if( disabledByIf==0 ){
          disabledByIf = 1;
        }
      }else

      /* The --endif command decrements the if counter and reenables
      ** processing when it reaches zero.
      */
      if( nCmd==5 && memcmp(zCmd, "endif", 5)==0 ){
        if( disabledByIf ){
          disabledByIf--;
          iStart = i + n;
        }
      }else

      /* Do no other processing if currently disabled.
      */
      if( disabledByIf ){
        /* Skip all other processing while disabled. */
      }else

      /* the "--testcase NAME" command marks the beginning of a test
      ** case named NAME
      */
      if( nCmd==8 && memcmp(zCmd, "testcase", 8)==0 ){
        iTestcase = iArg+i;
        nTestcase = nArg;
        iStart = i + n;
        th3testBegin(p, th3format(p, "%.*s", nTestcase, &zScript[iTestcase]));
      }else

      /* The "--result ANSWER" command runs all unprocessed SQL text.
      ** The results of this SQL is compared against ANSWER.  The test
      ** is successful if results are identical and the test fails
      ** fails if there is any difference in results.
      **
      ** If "--glob PATTERN" is used, then the result must match
      ** the glob-pattern rather than be an exact answer.  If the
      ** "--notglob PATTERN" is used, then the test is a success if
      ** the result does not match the pattern.
      **
      ** Further --result commands are disabled until another --testcase
      ** is seen.  If results are currently disabled, no SQL is evaluted.
      **
      ** If the --oom comment appears within the SQL text, then the code
      ** is run in an OOM loop.  If --new or --open also appear in the SQL
      ** text, then the database is reopened on each iteration of the OOM
      ** loop.  When neither --new nor --open appear in the SQL, then the
      ** OOM loop is run within a transaction that is rolled back before
      ** each repeat of the OOM loop and commits on the very last cycle.
      **
      ** If --revert appears within an --oom test, then the snapshot is
      ** reverted before each cycle of the test.
      **
      ** If the --ioerr comment appears within the SQL text, and --new or
      ** --open also appear and TEST_VFS is enabled, then the SQL is run
      ** in an I/O error loop.  A snapshot of the filesystem is taken before
      ** the first cycle and the filesystem is restored to the snapshot before
      ** the start of each cycle.  Restoring the snapshot means that all
      ** database connections must be closed at the start of each cycle.
      ** Only the current database connection is reopened according to
      ** the --new or --open comment.
      **
      ** A bare --ioerr without a --new or --open can be used but will
      ** probably not work except for corner cases such as when the failing
      ** operation is restricted (ex: --ioerr symlockbusy) in such a way
      ** that it does not leave the connection in an unrecoverable state.
      */
      if( (nCmd==6 && memcmp(zCmd, "result", 6)==0)
       || (nCmd==4 && memcmp(zCmd, "glob", 4)==0)
       || (nCmd==7 && memcmp(zCmd, "notglob", 7)==0)
      ){
        int (*xCmp)(const char*,const char*);
        if( nCmd==6 ){
          xCmp = th3strcmp;
        }else if( nCmd==4 ){
          xCmp = th3strglob;
        }else{
          xCmp = th3strnotglob;
        }
        if( oomTest && ((p->config.maskProp & TH3_MEMDB)==0 || zOpenDb[0]==0) ){
          int needCommit = 0;
          int needRevert = 0;
          th3testCheckInt(p, 1, 1);
          th3oomBegin(p, th3format(p, "%.*s", nTestcase, &zScript[iTestcase]));
          while( th3oomNext(p) ){
            int rc;
            if( needRevert ){
              th3dbCloseAll(p);
              th3filesystemRevert(p);
            }
            if( zOpenDb[0] ){
              th3dbOpen(p, iDb, zOpenDb, openFlags);
            }else if( !revertTest ){
              if( needCommit ) th3dbEval(p, iDb, "ROLLBACK");
              th3dbEval(p, iDb, "BEGIN");
              needCommit = 1;
              th3testResetResult(p);
            }
            th3oomEnable(p, 1);
            rc = th3dbEval(p, iDb, 
                          th3format(p, "%.*s", i-iStart, &zScript[iStart]));
            th3oomEnable(p, 0);
            if( th3oomHit(p) || (rc==SQLITE_NOMEM && th3oom.nFail>0) ){
              if( oomTest==1 ){        /* --oom */
                th3oomCheck(p, 0, rc==SQLITE_NOMEM );
              }else if( oomTest==5 ){  /* --oom-err */
                th3oomCheck(p, 1, rc!=SQLITE_OK );
              }else if( oomTest==7 ){  /* --oom-integ */
                th3testResetResult(p);
                th3dbEval(p, iDb, "PRAGMA integrity_check");
                th3oomResult(p, 4, "ok");
              }else{                   /* --oom-ck */
                th3oomCheck(p, 2,
                    rc!=SQLITE_OK || th3strcmp(p->zResult, "ok")!=0
                );
              }
            }else{
              char *zTruth;
              if( enableScan ) th3testAppendScan(p);
              zTruth = th3format(p, "%.*s", nArg, &zScript[iArg+i]);
              th3oomResultCmp(p, 3, zTruth, xCmp);
            }
            needRevert = revertTest;
          }
          th3oomEnd(p);
          if( needCommit ) th3dbEval(p, iDb, "COMMIT");
        }else if( ioerrTest ){
          th3testCheckInt(p, 1, 1);
          th3ioerrBegin(p, th3format(p, "%.*s", nTestcase,&zScript[iTestcase]));
          if( !revertTest && zOpenDb[0] ) th3filesystemSnapshot(p);
          p->fsysTest.ioerr.useRepeat = (ioerrMask & TH3VFS_IOERR_REPEAT)!=0;
          p->fsysTest.ioerr.mask = ioerrMask;
          while( th3ioerrNext(p) ){
            int rc;
            if( zOpenDb[0] ){
              th3dbCloseAll(p);
              th3filesystemRevert(p);
              th3dbOpen(p, iDb, zOpenDb, openFlags);
            }
            th3ioerrEnable(p, 1);
            rc = th3dbEval(p, iDb, 
                          th3format(p, "%.*s", i-iStart, &zScript[iStart]));
            th3ioerrEnable(p, 0);
            if( th3ioerrHit(p) && rc!=SQLITE_OK ){
              th3ioerrCheck(p, 1, rc!=SQLITE_OK );
            }else{
              char *zTruth;
              if( enableScan ) th3testAppendScan(p);
              zTruth = th3format(p, "%.*s", nArg,&zScript[iArg+i]);
              th3ioerrResultCmp(p, 2, zTruth, xCmp);
            }
          }
          th3ioerrEnd(p);
        }else{
          char *zTruth;
          th3dbEval(p, iDb, th3format(p, "%.*s", i-iStart, &zScript[iStart]));
          if( enableScan ) th3testAppendScan(p);
          zTruth = th3format(p, "%.*s", nArg, &zScript[iArg+i]);
          th3testCheckCmp(p, zTruth, xCmp);
        }
        oomTest = 0;
        ioerrTest = 0;
        revertTest = 0;
        zOpenDb[0] = 0;
        iStart = i + n;
      }else

      /* The "--store VARIABLE" command runs all unprocessed SQL text.
      ** The output of that SQL is stored in the binding variable named
      ** VARIABLE.   "--store-raw VARIABLE" works the same way except that
      ** the output of the SQL is not quoted.
      **
      ** The "--store VARIABLE SQL" command runs the SQL text supplied
      ** and stores the result in the output variable.  The --store-raw
      ** form also accepts the extra SQL argument.  Example uses:
      **
      **    --store $pgsz PRAGMA page_size
      **    --store $enc PRAGMA encoding
      */
      if( (nCmd==5 && memcmp(zCmd, "store", 5)==0)
        || (nCmd==9 && memcmp(zCmd, "store-raw", 9)==0)
       ){
        int rc;
        int j, k, n1, n2;
        th3testResetResult(p);
        p->bRawResult = nCmd==9 ? 1 : 0;
        n1 = nArg;
        n2 = 0;
        for(j=0; j<nArg; j++){
          if( zScript[iArg+i+j]==' ' ){
            n1 = k = j;
            while( k<nArg && zScript[iArg+i+k]==' ' ){ k++; }
            n2 = nArg - k;
            break;
          }
        }
        if( n2==0 ){
          rc = th3dbEval(p, iDb, th3format(p,"%.*s",i-iStart,&zScript[iStart]));
          iStart = i + n;
        }else{
          rc = th3dbEval(p, iDb, th3format(p,"%.*s",n2,&zScript[iArg+i+k]));
        }
        p->bRawResult = 0;
        z = th3strndup(p, &zScript[iArg+i], n1);
        th3bindText(p, z, p->zResult);
        th3free(p, z);
        zOpenDb[0] = 0;
        th3testResetResult(p);
      }else

      /* The "--table TABLE" command runs all unprocessed SQL text.
      ** The output of that SQL is stored in table named TABLE.
      */
      if( nCmd==5 && memcmp(zCmd, "table", 5)==0 ){
        int rc;
        z = th3strndup(p, &zScript[iArg+i], nArg);
        th3dbInsertMode(p, iDb, z);
        rc = th3dbEval(p, iDb, th3format(p, "%.*s", i-iStart,&zScript[iStart]));
        th3dbInsertMode(p, iDb, 0);
        iStart = i + n;
        zOpenDb[0] = 0;
        if( rc ){
          th3print(p, th3format(p, "ERROR: %s\n", p->zResult));
          p->nFail++;
        }
        th3free(p, z);
      }else

      /* The "--run N" command runs all unprocessed SQL text.
      ** The commands are run in database connection N.
      ** The output of the SQL discarded, though error message text is printed.
      */
      if( nCmd==3 && memcmp(zCmd, "run", 3)==0 ){
        int rc;
        int N;
        N = (int)th3atoi64(&zScript[iArg+i]);
        rc = th3dbEval(p, N, th3format(p, "%.*s", i-iStart,&zScript[iStart]));
        iStart = i + n;
        zOpenDb[0] = 0;
        if( rc ){
          th3print(p, th3format(p, "ERROR: %s\n", p->zResult));
          p->nFail++;
        }
        th3testResetResult(p);
      }else

      /* The --oom, --oom-err, and --oom-ck comments each set
      ** a flag which causes the next --result to run a full OOM test
      ** if OOM testing is enabled by the configuration.  This command
      ** only invokes OOM testing in the next --result seen.  If OOM testing
      ** is disabled in the current configuration, then this comment is a
      ** no-op.
      */
      if( (nCmd==3 && memcmp(zCmd, "oom", 3)==0)
       || (nCmd==7 && memcmp(zCmd, "oom-err", 7)==0)
       || (nCmd==6 && memcmp(zCmd, "oom-ck", 6)==0)
       || (nCmd==9 && memcmp(zCmd, "oom-integ", 9)==0)
      ){
        if( (p->config.maskProp & TH3_NO_OOM)==0 ){
          oomTest = nCmd-2;
        }
      }else

      /* The --ioerr comment set a flag which causes the
      ** next --result to run a full I/O error test if TEST_VFS is
      ** enabled by the configuration.  If TEST_VFS is
      ** not eanbled, this comment is a no-op.
      **
      ** The optional argument can be used to restrict the types of
      ** I/O errors simulated.  See the th3ioerrType[] array for
      ** details.
      */
      if( nCmd==5 && memcmp(zCmd, "ioerr", 5)==0 ){
        if( (p->config.maskProp & TH3_TEST_VFS)!=0 ){
          int ii;
          const char *z = &zScript[iArg+i];
          ioerrTest = 1;
          ioerrMask = TH3VFS_IOERR_ALL;
          for(ii=0; ii<COUNT(th3ioerrType); ii++){
            if( memcmp(z, th3ioerrType[ii].zName, nArg)==0
             && th3ioerrType[ii].zName[nArg]==0 
            ){
              ioerrMask = th3ioerrType[ii].mask;
              break;
            }
          }
        }
      }else

      /* The command "--scan-count BOOLEAN" enables or disables the
      ** appending of text "scan N sort N" to the end result string of
      ** working --result commands.  BOOLEAN should be "0" or "1"
      */
      if( nCmd==10 && memcmp(zCmd, "scan-count", 10)==0 ){
        enableScan = (int)th3atoi64(&zScript[iArg+i]);
      }else

      /* The command "--column-names BOOLEAN" enables or disables the
      ** insertion of result set column names prior to result values in
      ** the output of working --result commands.  BOOLEAN should be "0"
      ** or "1"
      */
      if( nCmd==12 && memcmp(zCmd, "column-names", 12)==0 ){
        th3dbEnableColname(p, 0, (int)th3atoi64(&zScript[iArg+i]));
      }else

      /* The "--new FILENAME" command closes the current database
      ** connection, deletes file FILENAME, and then reopens the
      ** current database connection against FILENAME.  If this command
      ** occurs in between --testcase and --result of an --oom test, then
      ** the close and reopen is repeated for each iteration of the OOM
      ** test.  The "--raw-new FILENAME" command does likewise except that
      ** it does not initialize the connection.
      */
      if( (nCmd==3 && memcmp(zCmd, "new", 3)==0)
       || (nCmd==7 && memcmp(zCmd, "raw-new", 7)==0)
      ){
        if( nArg>sizeof(zOpenDb)-1 ) th3panic("filename too big");
        th3memcpy(zOpenDb, &zScript[iArg+i], nArg);
        zOpenDb[nArg] = 0;
        openFlags = TH3_OPEN_NEW | (zCmd[0]=='r' ? TH3_OPEN_RAW : 0);
        th3dbOpen(p, iDb, zOpenDb, openFlags);
      }else

      /* The "--open FILENAME" command closes the current database
      ** connection and then reopens the
      ** current database connection against FILENAME.  If this command
      ** occurs in between --testcase and --result of an --oom test, then
      ** the close and reopen is repeated for each iteration of the OOM
      ** test.  The "--raw-open FILENAME" command does likewise except that
      ** it does not initialize the connection.  If the FILENAME ends with
      ** "\040ro" then the "\040ro" is removed and the connection is opened
      ** read-only.  The "\040uri" suffix add SQLITE_OPEN_URI.
      */
      if( (nCmd==4 && memcmp(zCmd, "open", 4)==0)
       || (nCmd==8 && memcmp(zCmd, "raw-open", 8)==0)
      ){
        if( nArg>sizeof(zOpenDb)-1 ) th3panic("filename too big");
        th3memcpy(zOpenDb, &zScript[iArg+i], nArg);
        zOpenDb[nArg] = 0;
        openFlags = 0;
        if( nCmd==8 ) openFlags = TH3_OPEN_RAW;
        if( nArg>3 && memcmp(&zOpenDb[nArg-3]," ro",3)==0 ){
          zOpenDb[nArg-3] = 0;
          openFlags |= SQLITE_OPEN_READONLY;
        }
        if( nArg>4 && memcmp(&zOpenDb[nArg-4]," uri",4)==0 ){
          zOpenDb[nArg-4] = 0;
          openFlags |= SQLITE_OPEN_URI;
        }
        th3dbOpen(p, iDb, zOpenDb, openFlags);
      }else

      /* The "--db N" command changes the current database connection to
      ** number N.  N must be between 0 and 5.  Only 0 is initially open.
      ** if other connections are used, there must be a --new or --open
      ** prior to the first --store or --result.
      */
      if( nCmd==2 && memcmp(zCmd, "db", 2)==0 ){
        iDb = (int)th3atoi64(&zScript[iArg+i]);
      }else

      /* The "--convert-filename NAME" command transforms the filename NAME
      ** into the form appropriate for use during the current test, depending
      ** on configuration settings.  That filename is then stored in the
      ** ":filename" bind variable where it can be used by ATTACH statements.
      **
      ** The "--new-filename NAME command is similar but takes the additional
      ** step of erasing the file and its journal if they already exist.
      */
      if( (nCmd==16 && memcmp(zCmd, "convert-filename", 16)==0)
       || (nCmd==12 && memcmp(zCmd, "new-filename", 12)==0) ){
        char *zName;
        char *zNewName;
        zName = th3strndup(p, &zScript[iArg+i], nArg);
        zNewName = th3malloc(p, nArg+201);
        th3convertFilename(p, zName, zNewName);
        th3bindText(p, ":filename", zNewName);
        if( zCmd[0]=='n' ){
          th3fileDelete(p, zName);
          th3strcpy(zNewName, zName);
          th3strcpy(&zNewName[nArg], "-journal");
          th3fileDelete(p, zNewName);
          th3strcpy(&zNewName[nArg], "-wal");
          th3fileDelete(p, zNewName);
          th3strcpy(&zNewName[nArg], ".lock");
          th3fileDelete(p, zNewName);
        }
        th3free(p, zNewName);
        th3free(p, zName);
      }else

      /* The --bind-reset comment invokes the th3bindReset() interface
      ** to reset all variable bindings.
      */
      if( nCmd==10 && memcmp(zCmd, "bind-reset", 10)==0 ){
        th3bindReset(p);
      }else

      /* The "--auth-log N" comment activates the logging authorizer
      ** function using database connection N as the logging database.
      ** N must be different from the current database.  An N value
      ** out of range cancels the authorizer.
      */
      if( nCmd==8  && memcmp(zCmd, "auth-log", 8)==0 ){
        int n = th3atoi64(&zScript[iArg+i]);
        if( n>=0 && n<=TH3_MAX_DB ){
          sqlite3_set_authorizer(p->aDb[iDb].db, th3_auth_log, &p->aDb[n]);
        }else{
          sqlite3_set_authorizer(p->aDb[iDb].db, 0, 0);
        }
      }else

      /* The "--auth-check N" comment activates the checking authorizer
      ** function using database connection N as the logging database.
      ** N must be different from the current database.  An N value
      ** out of range cancels the authorizer.
      */
      if( nCmd==10  && memcmp(zCmd, "auth-check", 10)==0 ){
        int n = th3atoi64(&zScript[iArg+i]);
        if( n>=0 && n<=TH3_MAX_DB ){
          sqlite3_set_authorizer(p->aDb[iDb].db, th3_auth_check, &p->aDb[n]);
        }else{
          sqlite3_set_authorizer(p->aDb[iDb].db, 0, 0);
        }
      }else

      /* The "--date SECONDS" comment sets the system time for the TEST_VFS
      ** to the date given in the argument.  The argument is a unix-epoch
      ** timestamp - seconds since 1970.
      */
      if( nCmd==4  && memcmp(zCmd, "date", 4)==0 ){
        p->fsysTest.iNow = th3atoi64(&zScript[iArg+i])*1000
                             + 8640000*(sqlite3_int64)24405875;
      }else

      /* The "--checkpoint" comment invokes the sqlite3_wal_checkpoint()
      ** interface on the current database if and only if the JOURNAL_WAL
      ** mode is set.
      */
      if( nCmd==10 && memcmp(zCmd, "checkpoint", 10)==0 ){
        if( p->config.maskProp & TH3_JOURNAL_WAL ){
          sqlite3_wal_checkpoint(p->aDb[iDb].db, 0);
        }
      }else

      /* The "--autocheckpoint N" comment invokes the
      ** sqlite3_wal_autocheckpoint(*,N) interface on the current
      ** database connection.
      */
      if( nCmd==14 && memcmp(zCmd, "autocheckpoint", 14)==0 ){
        int n = th3atoi64(&zScript[iArg+i]);
        sqlite3_wal_autocheckpoint(p->aDb[iDb].db, n);
      }else

      /* The "--edit FILENAME" comment makes changes to the file FILENAME
      ** as specified by prior script.  The "--shmedit FILENAME" comment
      ** does the same thing except that it does *not* do a checkpoint prior
      ** to the edit.
      */
      if( (nCmd==4  && memcmp(zCmd, "edit", 4)==0)
       || (nCmd==7  && memcmp(zCmd, "shmedit", 7)==0)
      ){
        if( (p->config.maskProp & TH3_TEST_VFS)==0 ){
          th3panic("The --edit and --shmedit commands requires TEST_VFS");
        }
        th3testResetResult(p);
        if( zCmd[0]!='s' ) sqlite3_wal_checkpoint(p->aDb[iDb].db, 0);
        z = th3strndup(p, &zScript[iArg+i], nArg);
        th3testvfsEdit(p, z, i-iStart, &zScript[iStart]);
        th3free(p, z);
        iStart = i + n;
      }else

      /* The "--snapshot" comment make a snapshot of the TEST_VFS filesystem.
      ** This only work for TEST_VFS.
      */
      if( nCmd==8  && memcmp(zCmd, "snapshot", 8)==0 ){
        th3filesystemSnapshot(p);
      }else

      /* The "--commit-snapshot" comment make arrangements to cause a
      ** snapshot of the TEST_VFS filesystem to be made just before the next
      ** file deletion.  Presumably the file being deleted is a rollback
      ** journal, which means a transaction is committing.
      */
      if( nCmd==15  && memcmp(zCmd, "commit-snapshot", 15)==0 ){
        p->fsysTest.ssCntdown = 1;
        p->fsysTest.ssOmitMask = TH3VFS_IOERR_PREDELETE | TH3VFS_IOERR_ALL;
      }else

      /* The "--revert" comment restores the filesystem from the most
      ** recent snapshot.  This only work for TEST_VFS.  All database
      ** connections are closed.  This comment must be followed by a
      ** --new or --open.
      */
      if( nCmd==6  && memcmp(zCmd, "revert", 6)==0 ){
        th3dbCloseAll(p);
        th3filesystemRevert(p);
        revertTest = 1;
      }else

      /* The "--close N" comment closes database connection N or
      ** if N is "all", closes all database connections.
      */
      if( nCmd==5 && memcmp(zCmd,"close", 5)==0 ){
        if( memcmp(&zScript[iArg+i],"all",3)==0 ){
          th3dbCloseAll(p);
        }else{
          int n = th3atoi64(&zScript[iArg+i]);
          th3dbClose(p, n);
        }
      }else

      /* The "--stmt-cache N" comment sets the size of the statement cache
      ** to N entries.  Reducing the statement cache size clears the cache.
      */
      if( nCmd==10  && memcmp(zCmd, "stmt-cache", 10)==0 ){
        th3dbCacheSetSize(p, th3atoi64(&zScript[iArg+i]));
      }else

      /* The "--stmt-cache-reset" comment clears the statement cache
      ** without changing its size.
      */
      if( nCmd==16  && memcmp(zCmd, "stmt-cache-reset", 16)==0 ){
        th3dbCacheClear(p);
      }else

      /* The "--prepare_v2 BOOLEAN" causes statements to be prepared using
      ** sqlite3_prepare_v2() or sqlite3_prepare().
      */
      if( nCmd==10  && memcmp(zCmd, "prepare_v2", 10)==0 ){
        p->bUsePrepareV2 = th3atoi64(&zScript[iArg+i]);
      }else

      /* The "--reserve N" comment sets the size of the reserve space held
      ** at the end of each database page for all subsequent open operations.
      */
      if( nCmd==7  && memcmp(zCmd, "reserve", 7)==0 ){
        p->nReserve = th3atoi64(&zScript[iArg+i]);
      }else

      /* The "--readonly GLOB" comment sets the read-only glob pattern for
      ** the file system.  GLOB can be zero or more glob patterns separated
      ** by "|".  A file that matches any pattern is assumed to be read-only.
      ** This only works for TEST_VFS.
      */
      if( nCmd==8  && memcmp(zCmd, "readonly", 8)==0 ){
        int n = nArg;
        if( n>=sizeof(p->fsysTest.zReadonly) ){
          th3panic("--readonly argument too big");
        }
        th3memcpy(p->fsysTest.zReadonly, &zScript[iArg+i], n);
        p->fsysTest.zReadonly[n] = 0;
      }else

      /* The "--cklog TEXT" comment checks the output of sqlite3_log()
      ** generated by the most recent test case.  This only operates if
      ** the LOG property is enabled.  If LOG is not defined, no error log
      ** is generated and this comment is a no-op.
      */
      if( nCmd==5  && memcmp(zCmd, "cklog", 5)==0 ){
        th3testCheckLog(p, &zScript[iArg+i], nArg);
      }else

      /* The "--call N ?ARG?" comment invokes the Nth element of the calllist.
      */
      if( nCmd==4  && memcmp(zCmd, "call", 4)==0 ){
        const char *z = &zScript[iArg+i];
        int nX = th3atoi64(z);
        int j;
        char zArg[50];
        for(j=0; j<nArg && z[j]!=' '; j++){}
        while( j<nArg && z[j]==' ' ){ j++; }
        assert( nArg-j<sizeof(zArg)-1 );
        memcpy(zArg, &z[j], nArg-j);
        zArg[nArg-j] = 0;
        callList[nX](p, iDb, zArg);
      }else

      /* DEBUGGING:  --breakpoint invokes the test_breakpoint() function.
      ** This allows one to set a breakpoint on the test_breakpoint function
      ** in a debugger that will stop the debugger at a certain point in
      ** the script.
      */
      if( nCmd==10 && memcmp(zCmd, "breakpoint", 10)==0 ){
        test_breakpoint();
      }else

      /* DEBUGGING:  The "--trace BOOLEAN" command turns tracing on and off.
      */
      if( nCmd==5 && memcmp(zCmd, "trace", 5)==0 ){
        traceOn = th3atoi64(&zScript[iArg+i]);
        p->fsysTest.trace = traceOn;
      }else

      /* DEBUGGING:  The "--exit" command terminates the script
      */
      if( nCmd==4 && memcmp(zCmd, "exit", 4)==0 ){
        return;
      }else

      /* Lines that begin with "--" must match one of the above commands
      ** or else there is an error.
      */
      {
        th3print(p,
            th3format(p, "*** unknown script command: %.*s\n",
                          n-1, &zScript[i])
        );
      }
    }
  }
}

/*
** End of the script-test module.
*************************************************************************/

#ifdef SQLITE_ENABLE_ZIPVFS
/************************************************************************
** Compression routines for ZIPVFS testing.
**
** In this implementation, we use a very simply compression in which
** between 1 and 256 0x00 bytes are represented as two bytes: 0x00, N-1
** where N is the number of consecutive 0x00 bytes.
**
** Maximum compression growth is for a buffer with alternating 0x00
** and non-0x00 bytes; maximum size is ((n+1)/2)*2 + n/2 if n is the
** initial size.
*/
static int th3zipvfsCompressBound(void *pCtx, int n){
  th3state *p = (th3state*)pCtx;
  assert( p->config.maskProp & TH3_ZIPVFS );
  assert( memcmp(p->pVfs->zName, "zipvfs", 6)==0 );
  return ((n+1)/2)*2 + n/2;
}
static int th3zipvfsCompress(
  void *pCtx,
  char *aOut, int *pnOut,
  char *aIn,  int nIn
){
  int i, j, k;
  th3state *p = (th3state*)pCtx;
  assert( p->config.maskProp & TH3_ZIPVFS );
  assert( memcmp(p->pVfs->zName, "zipvfs", 6)==0 );
  for(i=j=0; i<nIn; i++){
    if( (aOut[j++] = aIn[i])==0 ){
      for(k=0; k<255 && k+i+1<nIn && aIn[k+i+1]==0; k++){}
      aOut[j++] = k;
      i += k;
    }
  }
  *pnOut = j;
  return SQLITE_OK;
}
static int th3zipvfsUncompress(
  void *pCtx,
  char *aOut, int *pnOut,
  char *aIn,  int nIn
){
  int i, j, k;
  th3state *p = (th3state*)pCtx;
  assert( p->config.maskProp & TH3_ZIPVFS );
  assert( memcmp(p->pVfs->zName, "zipvfs", 6)==0 );
  for(i=j=0; i<nIn; i++){
    if( (aOut[j++] = aIn[i])==0 ){
      k = ((unsigned char*)aIn)[++i];
      while( (k--)>0 ){ aOut[j++] = 0; }
    }
  }
  *pnOut = j;
  return SQLITE_OK;
}
static int th3zipvfsCompressOpen(
  void *pCtx,
  const char *zFilename,
  void **ppLocalCtx
){
  *ppLocalCtx = pCtx;
  return SQLITE_OK;
}
static int th3zipvfsCompressClose(void *pCtx){
  th3state *p = (th3state*)pCtx;
  assert( p->config.maskProp & TH3_ZIPVFS );
  assert( memcmp(p->pVfs->zName, "zipvfs", 6)==0 );
  return SQLITE_OK;
}
/*
** End of the ZIPVFS compression routines.
*************************************************************************/
#endif /* SQLITE_ENABLE_ZIPVFS */


};##################################################### END OF C-CODE PREFIX

# List of modules and configurations
#
set listOfModules {}
set listOfConfigurations {}
set listOfPatterns {}
set listOfIncompatibilities {}

# List of files already included into th3.c. If an 'INCLUDE' header 
# directive is encountered, any filenames specified as arguments that
# are already in this list are ignored.
#
set listOfIncludes {}

##############################################################################
# Insert the test module code
#
set globargv {}
foreach filename $argv {
  if {[regexp {^-+skip=(.+)$} $filename all pattern]} {
    lappend listOfPatterns -$pattern
    continue
  }
  if {[regexp {^-+run=(.+)$} $filename all pattern]} {
    lappend listOfPatterns +$pattern
    continue
  }
  if {[string index $filename 0]=="-"} continue
  if {[regexp {\.testplan$} $filename]} {
    set f [open $filename r]
    while {![eof $f]} {
      set line [string trim [gets $f]]
      if {$line==""} continue
      if {[regexp {^#} $line]} continue
      if {[regexp {^run +(.+)} $line all pattern]} {
        lappend listOfPatterns +$pattern
        continue
      }
      if {[regexp {^skip +(.+)} $line all pattern]} {
        lappend listOfPatterns -$pattern
        continue
      }
      error "bad line in $filename: $line"
    }
    close $f
    continue
  }
  foreach x [lsort [glob -nocomplain $filename]] {
    lappend globargv $x
  }
}
foreach filename $globargv {
  set f [open $filename r]
  set n [expr {(74 - [string length $filename])/2}]
  set stars [string range ************************************************ 0 $n]
  lcputs "/$stars $filename $stars/"
  set module_name {}
  unset -nocomplain required_prop
  unset -nocomplain disallowed_prop
  set minheap 0
  set mindisk 0
  set mintemp 0
  set maxstr 10000
  set seenHeader 0
  set isConfig 0
  set config_name {}
  unset -nocomplain config_prop
  set lookaside {0 0}
  set pagecache {0 0}
  set scratch {0 0}
  set heap {0 0}
  set sector 1024
  set disk 10000
  set tempdisk 10000
  set szPage 0
  set szCache 0
  set altpcache_discard 50
  set altpcache_stress 0
  set dflt_vfs {}
  set isScriptModule 0
  set scriptStarted 0
  set nCharOnLine 0
  set pendingByte [expr {1024*1024*1024}]
  set codeckey {}
  set softHeapLimit 0
  set nStmtCache -1
  set prngSeed 12345
  set callList {}
  set ifclause {}
  set initializerProc {}
  set finalizerProc {}
  set skipConfig {}
  set onlyConfig {}
  set includeList [list]                   ;# Files to include after header
  set iLine 0                              ;# Current line of source file

  while {![eof $f]} {
    set line [gets $f]
    incr iLine
    if {!$seenHeader} {
      lcputs $line
      if {[regexp {^\*\* ([A-Z_]+): *(.*)} $line all tag arglist]} {
        switch $tag {
          MODULE_NAME {   # TestModule.zModuleName
            set module_name [lindex $arglist 0]
          }
          SCRIPT_MODULE_NAME {    # TestModule.zModuleName
            set module_name [lindex $arglist 0]
            set isScriptModule 1
          }
          MIXED_MODULE_NAME {    # TestModule.zModuleName
            set module_name [lindex $arglist 0]
            set isScriptModule 2
          }
          REQUIRED_PROPERTIES {   # TestModule.maskReq
            foreach p $arglist {
              if {![info exists valid_prop($p)]} {
                puts stderr "$filename: unknown property: $p"
              } else {
                set required_prop($p) 1
              }
            }
          }
          DISALLOWED_PROPERTIES {  # TestModule.maskOmit
            foreach p $arglist {
              if {![info exists valid_prop($p)]} {
                puts stderr "$filename: unknown property: $p"
              } else {
                set disallowed_prop($p) 1
              }
            }
          }
          MINIMUM_HEAPSIZE {       # TestModule.minHeap
            set minheap [lindex $arglist 0]
          }
          MINIMUM_DISK {           # TestModule.minDisk
            set mindisk [lindex $arglist 0]
          }
          MINIMUM_TEMPDISK {       # TestModule.minTemp
            set mintemp [lindex $arglist 0]
          }
          MAXIMUM_STRING {         # TestModule.maxFormat
            set maxstr [lindex $arglist 0]
          }
          STATEMENT_CACHE_SIZE {   # TestModule.nStmtCache
                                   # also: Configuration.nStmtCache
            set nStmtCache [lindex $arglist 0]
          }
          INCOMPATIBLE_WITH {      # TestModule.zInompatible
            foreach p $arglist {lappend skipConfig $p}
          }
          COMPATIBLE_ONLY_WITH {   # TestModule.zCompatible
            foreach p $arglist {lappend onlyConfig $p}
          }

      ########## {Test module fields above. Configuration fields below. #######}

          CONFIGURATION_NAME {     # Configuration.zConfigName
            set config_name [lindex $arglist 0]
          }
          PROPERTIES {             # Configuration.maskProp
            foreach p $arglist {
              if {![info exists valid_prop($p)]} {
                puts stderr "$filename: unknown property: $p"
              } else {
                set config_prop($p) 1
              }
            }
          }
          PAGE {                   # Configuration.szPage
            set szPage [lindex $arglist 0]
          }
          CACHE {                  # Configuration.szCache
            set szCache [lindex $arglist 0]
          }
          LOOKASIDE {              # Configuration.szLookaside & .nLookaside
            set lookaside [lrange $arglist 0 1]
          }
          PAGECACHE {              # Configuration.szPagecache & .nPagecache
            set pagecache [lrange $arglist 0 1]
          }
          SCRATCH {                # Configuration.szScratch & .nScratch
            set scratch [lrange $arglist 0 1]
          }
          HEAP {                   # Configuration.szHeap & .mnHeapAlloc
            set heap [lrange $arglist 0 1]
          }
          SECTOR {                 # Configuration.szSector
            set sector [lindex $arglist 0]
          }
          DISK {                   # Configuration.szDisk
            set disk [lindex $arglist 0]
          }
          TEMPDISK {               # Configuration.szTemp
            set tempdisk [lindex $arglist 0]
          }
          ALTPCACHE_DISCARD {      # Configuration.discardChange
            set altpcache_discard [lindex $arglist 0]
          }
          ALTPCACHE_STRESS {       # Configuration.stressChange
            set altpcache_stress [lindex $arglist 0]
            if {$altpcache_stress>0} {
              set config_prop(ALT_PCACHE_STRESS) 1
            }
          }
          PENDING_BYTE {           # Configuration.pendingByte
            set pendingByte [lindex $arglist 0]
          }
          SOFT_HEAP_LIMIT {        # Configuration.softHeapLimit
            set softHeapLimit [lindex $arglist 0]
          }
          DEFAULT_VFS {            # Configuration.zDfltVfs
            set dflt_vfs [lindex $arglist 0]
          }
          ENCRYPTION_KEY {         # Configuration.zCodecKey
            set codeckey [lindex $arglist 0]
          }
          INCLUDE {
	    foreach incl $arglist {
	      set includefile [file join [file dirname $filename] $incl]
              if {[lsearch $listOfIncludes $includefile] < 0} {
		lappend listOfIncludes $includefile
		lappend includeList $includefile
	      }
            }
          }
          PRNG_SEED {             # Configuration.prngSeed
            set prngSeed [lindex $arglist 0]
          }
          IF {
            lappend ifclause [string trim $arglist]
          }
          INITIALIZER {           # Configuration.xInitializer
            set initializerProc [lindex $arglist 0]
          }
          FINALIZER {             # Configuration.xFinalizer
            set finalizerProc [lindex $arglist 0]
          }

          default {
            puts stderr "$filename: unknown configuration: $tag"
          }
        }
      }
      if {[string trim $line]=="*/"} {
        set seenHeader 1
        if {[llength $ifclause]>1} {
          set ifclause "([join $ifclause {) && (}])"
        }
        if {$module_name=="" && $config_name==""} {
          puts stderr "$filename: no MODULE_NAME or CONFIGURATION_NAME found"
        }
        if {$module_name!=""} {
          if {$skipConfig==""} {
            set skipConfig 0
          } else {
            set skipConfig "\"[join $skipConfig {|}]\""
          }
          if {$onlyConfig==""} {
            set onlyConfig 0
          } else {
            set onlyConfig "\"[join $onlyConfig {|}]\""
          }
          set rec $module_name
          lappend rec [array names required_prop]
          lappend rec [array names disallowed_prop]
          lappend rec $minheap $mindisk $mintemp $maxstr $nStmtCache
          lappend rec $skipConfig $onlyConfig $ifclause
          lappend listOfModules $rec
          if {[info exists includeList]} {
            foreach incl $includeList {
              lcputs "#line 1 \"$incl\""
              set fd [open $incl]
              while {![eof $fd]} {
                lcputs [gets $fd]
              }
              close $fd
              lcputs "#line [expr $iLine+1] \"$filename\""
            }
            unset includeList
          }
        } else {
          if {[info exists config_prop(MEMDB)]} {
            set codeckey {}   ;# Do not encrypt :memory: databases
          }
          if {$codeckey=="" && ![info exists config_prop(ZIPVFS)]} {
            # Set CLEARTEXT if not encrypting or compressing
            set config_prop(CLEARTEXT) 1
          } else {
            # Remove the CLEARTEXT if encrypting or compressing
            unset -nocomplain config_prop(CLEARTEXT)
          }
          set rec $config_name
          lappend rec [array names config_prop]
          lappend rec $szPage $szCache
          lappend rec $lookaside $pagecache $scratch $heap
          lappend rec $sector $disk $tempdisk $altpcache_discard
          lappend rec $altpcache_stress $pendingByte
          lappend rec $softHeapLimit $nStmtCache $prngSeed $dflt_vfs $codeckey
          if {$initializerProc==""} {set initializerProc 0}
          if {$finalizerProc==""} {set finalizerProc 0}
          lappend rec $initializerProc $finalizerProc $ifclause
          lappend listOfConfigurations $rec
        }
        if {$ifclause!=""} {
          lcputs "#if $ifclause"
        }
        lcputs "#line [expr {$iLine+1}] \"$filename\""
      }
    } elseif {$isScriptModule} {
      if {!$scriptStarted} {
        if {$isScriptModule<2 || [regexp {^--} $line]} {
          lcputs "static const char ${module_name}_script\[\] = \173"
          set scriptStarted 1
        }
      }
      if {!$scriptStarted} {
        lcputs $line
      } elseif {[regexp {^(/\*|\*\*|\*/)} $line]||[regexp {^--[^a-z]} $line]} {
        # skip comments */
      } elseif {[regexp {^#(if|elif|endif|else)} $line]} {
        if {$nCharOnLine>0} {
          puts ""
          incr nLine
          set nCharOnLine 0
        }
        lcputs $line
      } else {
        if {[regexp {^--call +([a-zA-Z0-9_]+)(.*)} $line all procname tail]} {
          set n [lsearch $callList $procname]
          if {$n<0} {
            set n [llength $callList]
            lappend callList $procname
          }
          set line "--call $n$tail"
        }
        append line \n
        set n [string length $line]
        for {set i 0} {$i<$n} {incr i} {
          if {$nCharOnLine==0} {puts -nonewline "    "}
          scan [string index $line $i] %c c
          puts -nonewline [format {%3d, } $c]
          incr nCharOnLine
          if {$nCharOnLine>=14} {
            puts ""
            incr nLine
            set nCharOnLine 0
          }
        }
      }
    } else {
      lcputs $line
    }
  }
  if {$isScriptModule} {
    if {$nCharOnLine>0} {
      puts ""
      incr nLine
    }
    lcputs "0\175; /* End of the ${module_name}_script\[\] initializer */"
    lcputs "int ${module_name}(th3state *p)\173"
    if {[llength $callList]} {
      lcputs "  static void\
                (*${module_name}_calls\[\])(th3state*,int,char*) = \173"
      foreach procname $callList {
        lcputs "    $procname,"
      }
      lcputs "  \175;"
      lcputs "  th3testScript(p, ${module_name}_script, ${module_name}_calls);"
    } else {
      lcputs "  th3testScript(p, ${module_name}_script, 0);"
    }
    lcputs "  return 0;"
    lcputs "\175"
  }
  if {$ifclause!=""} {
    lcputs "#endif /* $ifclause */"
  }
  close $f
  
  set n [expr {(67 - [string length $filename])/2}]
  set stars [string range ************************************************ 0 $n]
  lcputs "#line $nLine \"th3.c\""
  lcputs "/$stars end of $filename $stars/"
}

# Convert a list of symbols into an OR-ed array of constants.
#
proc listToOr {lx} {
  set c {}
  foreach s $lx {
    append c "|TH3_$s"
  }
  if {[string length $c]>0} {
    return [string range $c 1 end]
  } else {
    return 0
  }
}

# Generate the list of exclude and include patterns.
#
lcputs "static const char *azTestPlan\[\] = \173"
foreach rec $listOfPatterns {
  lcputs "  \"$rec\","
}
lcputs "0\175;"

# Generate the array of TestConfiguration structures
#
lcputs "static const TestConfiguration aConfig\[\] = \173"
foreach rec $listOfConfigurations {
  foreach {name prop szPage szCache lookaside pagecache scratch heap
           sec disk tdisk altp_dis altp_stress pbyte softheap
           nStmtCache prngSeed dfltvfs codeckey initProc finalProc
           ifclause} $rec break
  if {$ifclause!=""} {
    lcputs "#if $ifclause"
  }
  lcputs "  \173 \"$name\","
  if {[lsearch $prop JOURNAL_*]<0} {lappend prop JOURNAL_DELETE}
  if {[lsearch $prop MEMDB]>=0 && [lsearch $prop TEST_VFS]>=0} {
    error "MEMDB and TEST_VFS are incompatible properties: choose one\
           or the other but not both"
  }
  lcputs "    [listToOr $prop],"
  lcputs "    $szPage, $szCache,"
  lcputs "    [lindex $lookaside 0], [lindex $lookaside 1],"
  lcputs "    [lindex $pagecache 0], [lindex $pagecache 1],"
  lcputs "    [lindex $scratch 0], [lindex $scratch 1],"
  lcputs "    [lindex $heap 0], [lindex $heap 1],"
  lcputs "    $sec, $disk, $tdisk, $altp_dis, $altp_stress, $pbyte,"
  lcputs "    $softheap, $nStmtCache, $prngSeed,"
  lcputs "    $initProc, $finalProc,"
  if {$dfltvfs==""} {
    set dfltvfs 0
  } else {
    set dfltvfs \"[string map {\\ \\\\ \" \"\"} $dfltvfs]\"
  }
  if {$codeckey==""} {
    set codeckey 0
  } else {
    set codeckey \"[string map {\\ \\\\ \" \"\"} $codeckey]\"
  }
  lcputs "    $dfltvfs, $codeckey \175,"
  if {$ifclause!=""} {
    lcputs "#endif /* $ifclause */"
  }
}
lcputs "\175;"

# Generate the array of TestModule structures, one per test module.
#
lcputs "static const TestModule aTest\[\] = \173"
foreach rec $listOfModules {
  foreach {name req dis minheap mindisk mintemp maxstr
           nStmtCache skipConfig onlyConfig ifclause} $rec break
  if {$ifclause!=""} {lcputs "#if $ifclause"}
  lcputs "  \173 \"$name\", $name,"
  lcputs "    [listToOr $req],"
  lcputs "    [listToOr $dis],"
  lcputs "    $minheap, $mindisk, $mintemp, $maxstr, $nStmtCache,\
              $skipConfig, $onlyConfig \175,"
  if {$ifclause!=""} {lcputs "#endif /* $ifclause */"}
}
lcputs "\175;"
 
# Insert text at the end of the test module.
#
lcputs {#line 10005 "mkth3.tcl"
/*
** Setup a state variable.  The p->tid and p->config fields have already
** been set.
*/
static void th3_setup_state(th3state *p){
  int i;
  p->mxMem = 0;
  if( p->config.maskProp & TH3_TEST_VFS ){
    sqlite3_snprintf(sizeof(p->zVfsName), p->zVfsName, "vfs%d", p->tid);
    p->testVfs = th3vfsObjTemplate;
    p->testVfs.zName = p->zVfsName;
    p->testVfs.pAppData = (void*)&p->fsysTest;
    p->fsysTest.p = p;
    p->fsysTest.szSector = p->config.szSector;
    p->fsysTest.noTruncate = (p->config.maskProp & TH3_NO_TRUNCATE)!=0;
    p->fsysTest.mxSector = p->config.szDisk/p->config.szSector;
    p->fsysTest.pFsysSS = &p->fsysSS;
    if( p->config.maskProp & TH3_ATOMICIO ){
      p->fsysTest.isAtomic = 1;
      p->fsysTest.devChar |= SQLITE_IOCAP_ATOMIC;
    }
    if( p->config.maskProp & TH3_SEQUENTIALIO ){
      p->fsysTest.isSequential = 1;
      p->fsysTest.devChar |= SQLITE_IOCAP_SEQUENTIAL;
    }
    if( p->config.maskProp & TH3_SAFEAPPEND ){
      p->fsysTest.isSafeAppend = 1;
      p->fsysTest.devChar |= SQLITE_IOCAP_SAFE_APPEND;
    }
    if( p->config.maskProp & TH3_UNDELETABLE_WHEN_OPEN ){
      p->fsysTest.undeletableWhenOpen = 1;
      p->fsysTest.devChar |= SQLITE_IOCAP_UNDELETABLE_WHEN_OPEN;
    }
    if( p->config.maskProp & TH3_ZEROSIZE_FILES_EXIST ){
      p->fsysTest.zerosizeFilesExist = 1;
    }
    sqlite3_vfs_register(&p->testVfs, 0);
    p->pVfs = &p->testVfs;
  }else{
    p->pVfs = sqlite3_vfs_find(0);
  }
#ifdef SQLITE_ENABLE_ZIPVFS
  if( p->config.maskProp & TH3_ZIPVFS ){
    char zZipvfsName[20];
    sqlite3_snprintf(sizeof(zZipvfsName), zZipvfsName, "zipvfs%d", p->tid);
    if( p->config.zCodecKey && p->config.zCodecKey[0] ){
      zipvfs_create_vfs_v2(
          zZipvfsName, p->pVfs->zName, p,
          th3zipvfsCompressBound,
          th3zipvfsCompress,
          th3zipvfsUncompress,
          th3zipvfsCompressOpen,
          th3zipvfsCompressClose
      );
    }else{
      zipvfs_create_vfs(
          zZipvfsName, p->pVfs->zName, p,
          th3zipvfsCompressBound,
          th3zipvfsCompress,
          th3zipvfsUncompress
      );
    }
    p->pVfs = sqlite3_vfs_find(zZipvfsName);
  }
#endif
  if( p->tid>0 ){
    char *zFile = th3malloc(p, 200);
    th3convertFilename(p, "out.txt", zFile);
    p->out = th3openLogFile(zFile, 1);
    th3free(p, zFile);
  }
  if( p->config.maskProp & TH3_BIND_TRANSIENT ){
    p->xBindFree = SQLITE_TRANSIENT;
  }else if( p->config.maskProp & TH3_BIND_FREE ){
    p->xBindFree = sqlite3_free;
  }else{
    p->xBindFree = SQLITE_STATIC;
  }
  for(i=0; i<=TH3_MAX_DB; i++){
    p->aDb[i].p = p;
  }
}

/*
** Unregister the ZIPVFS and/or the TEST_VFS from a state variable.
*/
static void th3_unregister(th3state *p){
#ifdef SQLITE_ENABLE_ZIPVFS
  char zZipvfsName[20];
  sqlite3_snprintf(sizeof(zZipvfsName), zZipvfsName, "zipvfs%d", p->tid);
  zipvfs_destroy_vfs(zZipvfsName);
#endif
  if( p->config.maskProp & TH3_TEST_VFS ){
    sqlite3_vfs_unregister(&p->testVfs);
  }
}

/*
** Cleanup a state variable.
*/
static void th3_cleanup_state(th3state *p){
  if( p->tid>0 ){
    th3closeLogFile(p->out);
    p->out = 0;
  }
  th3bindReset(p);
}

#ifdef TH3_UNIX_TIMER
#include <sys/time.h>
/*
** Compute the current wall-clock time in microseconds.
*/
static sqlite3_int64 th3_current_time(void){
  struct timeval sNow;
  gettimeofday(&sNow, 0);
  return 1000000*(sqlite3_int64)sNow.tv_sec + sNow.tv_usec;
}
#endif /* TH3_UNIX_TIMER */



/*
** The p->config parameter has been set.
** Run all compatible test modules in a random order.
**
** The following initialization has already occurred:
**
**   *  The PRNG has been seeded
**   *  All non-threadsafe SQLite setup (ex: sqlite_config()) calls have
**      been completed.
*/
static void th3_run_thread(th3state *p){
  th3prng sRandSaved;          /* Saved PRNG state */
  const TestModule **apModule; /* Test modules in scrambled order */
  int nModule;                 /* Number of test modules */
  int i, j;                    /* Loop counters */
  u64 maskConfig;              /* Mask of configuration properties */
#ifdef TH3_UNIX_TIMER
  sqlite3_int64 iTimer;        /* Timing */
  char zTimer[100];            /* Timing as text */
#endif
  char zTxt[100];

  sRandSaved = p->sRand;
  nModule = COUNT(aTest);
  apModule = th3mallocRaw( sizeof(apModule[0])*nModule );
  if( apModule==0 ) return;
  maskConfig = p->config.maskProp;
#if !defined(SQLITE_TEMP_STORE) || SQLITE_TEMP_STORE==1
  if( (maskConfig & (TH3_TEMPSTORE_FILE|TH3_TEMPSTORE_MEM))==0 ){
    maskConfig |= TH3_TEMPSTORE_FILE;
  }
#elif SQLITE_TEMP_STORE==0
  maskConfig |= TH3_TEMPSTORE_FILE;
#elif SQLITE_TEMP_STORE==3
  maskConfig |= TH3_TEMPSTORE_MEM;
#else
  if( (maskConfig & (TH3_TEMPSTORE_FILE|TH3_TEMPSTORE_MEM))==0 ){
    maskConfig |= TH3_TEMPSTORE_MEM;
  }
#endif

  /* The INITIALIZE_OK property is set except for when ZIPVFS is run
  ** incombination with MEMSYS5 or MEMSYS3.  Space to hold the ZIPVFS
  ** VFS object is obtained from sqlite3_malloc() and will be overwritten
  ** by MEMSYS3 or MEMSYS5 if sqlite3_initialize() is called.
  */
#if !defined(SQLITE_ENABLE_ZIPVFS) || (!defined(SQLITE_ENABLE_MEMSYS5) && !defined(SQLITE_ENABLE_MEMSYS3))
  maskConfig |= TH3_INITIALIZE_OK;
#endif

  for(i=j=0; i<nModule; i++){
    const TestModule *pM = &aTest[i];
    if( (pM->maskReq & maskConfig)!=pM->maskReq ) continue;
    if( (pM->maskOmit & maskConfig)!=0 ) continue;
    if( p->config.szHeap>0 && pM->minHeap>p->config.szHeap ) continue;
    if( p->config.szDisk>0 && pM->minDisk>p->config.szDisk ) continue;
    if( p->config.szTemp>0 && pM->minTemp>p->config.szTemp ) continue;
    apModule[j++] = &aTest[i];
  }
  nModule = j;

  /* Scramble the test module order */
  for(i=0; i<nModule*3; i++){
    const TestModule *pTemp;
    int a = th3randomInt(p) % nModule;
    pTemp = apModule[a];
    apModule[a] = apModule[i%nModule];
    apModule[i%nModule] = pTemp;
  }

  /* Run the tests */
  for(i=0; i<nModule; i++){
    /* VFS setup */
    p->sRand = sRandSaved;
    p->module = *apModule[i];
    if( th3strglobAny(p->module.zIncompatible, p->config.zConfigName) ){
      continue;
    }
    if( p->module.zCompatible
     && !th3strglobAny(p->module.zCompatible, p->config.zConfigName)
    ){
      continue;
    }
    th3snprintf(zTxt, sizeof(zTxt), "%s.%s",
                p->config.zConfigName, p->module.zModuleName);
    for(j=0; azTestPlan[j]; j++){
      if( th3strglob(&azTestPlan[j][1], zTxt)==0 ) break;
    }
    if( azTestPlan[j] && azTestPlan[j][0]=='-' ) continue;
    sqlite3_soft_heap_limit64(p->config.softHeapLimit);
    if( p->module.nStmtCache<0 ){
      th3dbCacheSetSize(p, p->config.nStmtCache);
    }else{
      th3dbCacheSetSize(p, p->module.nStmtCache);
    }
    p->nReserve = 0;
    p->bUsePrepareV2 = 1;
    th3randomReseed(p, p->config.prngSeed);
    th3print(p, "Begin ");
    th3print(p, zTxt);
    th3print(p, "\n");
    th3flush(p);
#ifdef TH3_UNIX_TIMER
    iTimer = th3_current_time();
#endif
    p->module.xProc(p);
    th3dbCloseAll(p);
    th3filesystemReset(&p->fsysTest);
    assert( p->fsysTest.nNotSynced==0 );
    th3filesystemReset(&p->fsysSS);
    /* VFS breakdown */
    if( (p->config.maskProp & (TH3_NO_MEMSTATUS|TH3_THREADS|TH3_ZIPVFS))==0 ){
      sqlite3_shutdown();
      th3testBegin(p, "memleak");
      if( sqlite3_memory_used() ){
        th3testFailed(p,
          th3format(p, "leaked %lld bytes", sqlite3_memory_used())
        );
      }else{
        th3testOk(p);
      }
      sqlite3_initialize();
    }
    th3print(p, "End ");
    th3print(p, p->config.zConfigName);
    th3print(p, ".");
    th3print(p, p->module.zModuleName);
#ifdef TH3_UNIX_TIMER
    iTimer = th3_current_time() - iTimer;
    th3snprintf(zTimer, sizeof(zTimer), " %d.%06d",
        (int)(iTimer/1000000), (int)(iTimer%1000000));
    th3print(p, zTimer);
#endif
    if( (p->config.maskProp & (TH3_NO_MEMSTATUS|TH3_THREADS))==0
     && p->config.szHeap>0
    ){
      sqlite3_int64 nUsed = sqlite3_memory_highwater(1);
      if( nUsed>p->config.szHeap/10 ){
        int pctUsed = (int)((1000*(sqlite3_int64)nUsed)/p->config.szHeap);
        sqlite3_snprintf(sizeof(zTxt), zTxt, " memory used: %lld (%d.%d)",
            nUsed, pctUsed/10, pctUsed%10);
        th3print(p, zTxt);
      }
    }
    th3print(p, "\n");
    th3flush(p);
    th3bindReset(p);
    th3freeAll(p);
    p->fsysTest.pMethods = 0;
    p->pTestData = 0;
  }

  /* Cleanup and exit */
  sqlite3_snprintf(sizeof(zTxt), zTxt, "Config-end %s. TH3 memory used: %d\n",
                   p->config.zConfigName, p->mxMem);
  th3print(p, zTxt);
  th3_unregister(p);
  if( (p->config.maskProp & (TH3_NO_MEMSTATUS|TH3_THREADS))==0 ){
    sqlite3_shutdown();
  }
  th3freeRaw(apModule);
  p->config.zConfigName = 0;
}

/*
** The number of parallel threads to run on TH3_THREAD configurations.
*/
#ifndef NTHREAD
#define NTHREAD  1
#endif

/*
** If the argument is negative, return 0.  Otherwise, return the
** argument.
*/
static int th3pos(int x){
  if( x<0 ) x = 0;
  return x;
}

/* Needed for the setrlimit() system call on unix */
#if defined(unix)
#include <sys/resource.h>
#endif

/*
** Attempt to limit the amount of memory available to this process to 250MB.
** It is important to limit available memory so that we can get calls to
** to system malloc() to fail by requesting oversize allocations.
*/
static void limitMemory(void){
#if defined(unix)
  struct rlimit x;

  getrlimit(RLIMIT_DATA, &x);
  x.rlim_cur = 500000000;
  setrlimit(RLIMIT_DATA, &x);
  getrlimit(RLIMIT_AS, &x);
  x.rlim_cur = 500000000;
  setrlimit(RLIMIT_AS, &x);
#endif  
}

/*
** The main routine.
*/
int main(int argc, char **argv){
  int i, j;             /* Loop counters */
  int nConfig;          /* Number of configurations to test */
  int nFail = 0;        /* Number of failed test cases */
  int nOk = 0;          /* Number of successful test cases */
  th3state *s;          /* State vectors for all threads */
  char *pHeap = 0;      /* Buffer used for heap, pagecache, & scratch */
  char *pToFree = 0;    /* Memory to free after final configuration */
  sqlite3_mutex_methods sMutex;   /* For checking mutex method results */
  int sz, szMax;        /* Size variables */
  FILE *s0out;          /* Copy of s[0].out */

  limitMemory();

  /* EVIDENCE-OF: R-02824-47636 Cautious programmers might include assert()
  ** statements in their application to verify that values returned by
  ** these interfaces match the macros in the header, and thus insure that
  ** the application is compiled with matching library and header files.
  ** assert( sqlite3_libversion_number()==SQLITE_VERSION_NUMBER ); assert(
  ** strcmp(sqlite3_sourceid(),SQLITE_SOURCE_ID)==0 ); assert(
  ** strcmp(sqlite3_libversion(),SQLITE_VERSION)==0 );
  **
  ** EVIDENCE-OF: R-35210-63508 The sqlite3_libversion_number() function
  ** returns an integer equal to SQLITE_VERSION_NUMBER.
  **
  ** EVIDENCE-OF: R-63124-39300 The sqlite3_sourceid() function returns a
  ** pointer to a string constant whose value is the same as the
  ** SQLITE_SOURCE_ID C preprocessor macro.
  */
  assert( sqlite3_libversion_number()==SQLITE_VERSION_NUMBER );
  assert( th3strcmp(sqlite3_libversion(),SQLITE_VERSION)==0 );
  assert( th3strcmp(sqlite3_sourceid(),SQLITE_SOURCE_ID)==0 );
  th3Argc = argc;
  th3Argv = argv;
  s = th3mallocRaw( NTHREAD * sizeof(s[0]) );
#ifdef TH3_LOG_FILE
  s[0].out = th3openLogFile(TH3_LOG_FILE, 0);
#else
  s[0].out = 0;
#endif
  s0out = s[0].out;
  th3print(&s[0], "With SQLite " SQLITE_VERSION " " SQLITE_SOURCE_ID "\n" );
  nConfig = COUNT(aConfig);

  /* Loop through all configs and find the largest memory-wise */
  szMax = 0;
  for(i=0; i<nConfig; i++){
    sz = th3pos(aConfig[i].szHeap)
       + th3pos(aConfig[i].szPagecache*aConfig[i].nPagecache)
       + th3pos(aConfig[i].szScratch*aConfig[i].nScratch)
       + 16;
    if( sz>szMax ){
      szMax = sz;
    }
  }
  /* Allocate sufficient memory for largest heap, page-cache, and scratch */
  pToFree = th3mallocRaw(szMax);

  for(i=0; i<nConfig; i++){
    int isThreadsafe = sqlite3_threadsafe();

    th3memset(s, 0, sizeof(s[0]));
    s[0].out = s0out;
    s[0].config = aConfig[i];
    if( s[0].config.maskProp & TH3_THREADS ){
      s[0].config.maskProp |= TH3_NO_OOM;    /* OOM testing is not threadsafe */
      s[0].config.maskProp &= ~TH3_ALT_PCACHE;   /* ALT_PCACHE not threadsafe */
      s[0].config.maskProp &= ~TH3_TEST_MUTEX;   /* TEST_MUTEX not threadsafe */
      s[0].config.maskProp &= ~TH3_NO_MUTEX_TRY; /* not threadsafe */
      s[0].config.maskProp &= ~TH3_LOG;          /* not multithread testable */
    }
    th3randomReseed(&s[0], s[0].config.prngSeed);
    sqlite3_shutdown();

#if !defined(SQLITE_HAS_CODEC) && !defined(SQLITE_ENABLE_ZIPVFS)
    /* Every configuration is CLEARTEXT if there is no codec and we are
    ** not using the ZIPVFS */
    s[0].config.maskProp |= TH3_CLEARTEXT;
#endif

    sqlite3_test_control(SQLITE_TESTCTRL_PENDING_BYTE, s[0].config.pendingByte);
    sqlite3_test_control(SQLITE_TESTCTRL_PRNG_RESET);
    if( s[0].config.maskProp & TH3_LOG ){
      sqlite3_config(SQLITE_CONFIG_LOG, th3logger, &s[0]);
    }else{
      sqlite3_config(SQLITE_CONFIG_LOG, 0, 0);
    }
    sqlite3_config(SQLITE_CONFIG_URI, 
       (s[0].config.maskProp & (TH3_URI|TH3_8_3_NAMES))!=0 );

#if !defined(SQLITE_THREADSAFE) || SQLITE_THREADSAFE>0
    if( s[0].config.maskProp & (TH3_TEST_MUTEX|TH3_NO_MUTEX_TRY) ){
      sqlite3_config(SQLITE_CONFIG_MUTEX, &th3mutexTestMethods);
      th3mutexGlobal.enableMutexTry =
                (s[0].config.maskProp & TH3_NO_MUTEX_TRY)==0;
      th3mutexGlobal.mutexInitReturn = SQLITE_OK;
      sqlite3_config(SQLITE_CONFIG_GETMUTEX, &sMutex);
      assert( memcmp(&sMutex, &th3mutexTestMethods, sizeof(sMutex))==0 );
    }else{
      sqlite3_config(SQLITE_CONFIG_MUTEX, &th3mutexNullMethods);
      sqlite3_config(SQLITE_CONFIG_GETMUTEX, &sMutex);
      assert( memcmp(&sMutex, &th3mutexNullMethods, sizeof(sMutex))==0 );
    }
#endif

    /* Setup memory for heap, page-cache, and scratch */
    pHeap = pToFree;

    th3oomInstall(0);
    if( (i&1)==0 ){
      /* Heap memory comes before page cache and scratch on even
      ** configurations */
      sz = s[0].config.szHeap;
      if( sz>0 ){
        sqlite3_config(SQLITE_CONFIG_HEAP, pHeap,
                       s[0].config.szHeap, s[0].config.mnHeapAlloc);
        pHeap += (sz+7)&~7;
      }else{
        sqlite3_config(SQLITE_CONFIG_HEAP, 0, 0, 0);
      }
    }

    sqlite3_config(SQLITE_CONFIG_LOOKASIDE,
                   s[0].config.szLookaside, s[0].config.nLookaside);
    assert( sqlite3_threadsafe()==isThreadsafe );

    if( s[0].config.szPagecache>0 || s[0].config.nPagecache>0 ){
      sz = s[0].config.szPagecache*s[0].config.nPagecache;
      if( sz<=0 ) sz = 1;
      sqlite3_config(SQLITE_CONFIG_PAGECACHE, pHeap,
                       s[0].config.szPagecache, s[0].config.nPagecache);
      pHeap += (sz+7)&~7;
    }else{
      sqlite3_config(SQLITE_CONFIG_PAGECACHE, 0, 0, 0);
    }
    assert( sqlite3_threadsafe()==isThreadsafe );

    if( s[0].config.szScratch || s[0].config.nScratch ){
      sz = s[0].config.szScratch*s[0].config.nScratch;
      if( sz<=0 ) sz = 1;
      sqlite3_config(SQLITE_CONFIG_SCRATCH, pHeap,
                       s[0].config.szScratch, s[0].config.nScratch);
      pHeap += (sz+7)&~7;
    }else{
      sqlite3_config(SQLITE_CONFIG_SCRATCH, 0, 0, 0);
    }
    assert( sqlite3_threadsafe()==isThreadsafe );

    if( (i&1)==1 ){
      /* Heap memory comes after page cache and scratch on odd configurations */
      sz = s[0].config.szHeap;
      if( sz>0 ){
        sqlite3_config(SQLITE_CONFIG_HEAP, pHeap,
                       s[0].config.szHeap, s[0].config.mnHeapAlloc);
      }else{
        sqlite3_config(SQLITE_CONFIG_HEAP, 0, 0, 0);
      }
    }

    th3oomInstall( (s[0].config.maskProp & TH3_NO_OOM)==0 );

    sqlite3_config(SQLITE_CONFIG_MEMSTATUS,
                    (aConfig[i].maskProp & TH3_NO_MEMSTATUS)==0);

    assert( sqlite3_threadsafe()==isThreadsafe );
    if( aConfig[i].maskProp & TH3_SINGLETHREAD ){
      int rc = sqlite3_config(SQLITE_CONFIG_SINGLETHREAD);
      assert( rc==(sqlite3_threadsafe()?SQLITE_OK:SQLITE_ERROR) );
    }else if( aConfig[i].maskProp & TH3_MULTITHREAD ){
      int rc = sqlite3_config(SQLITE_CONFIG_MULTITHREAD);
      assert( rc==(sqlite3_threadsafe()?SQLITE_OK:SQLITE_ERROR) );
    }else{
      int rc = sqlite3_config(SQLITE_CONFIG_SERIALIZED);
      assert( rc==(sqlite3_threadsafe()?SQLITE_OK:SQLITE_ERROR) );
    }
    /* EVIDENCE-OF: R-51445-09984 The return value of the
    ** sqlite3_threadsafe() function shows only the compile-time setting of
    ** thread safety, not any run-time changes to that setting made by
    ** sqlite3_config(). In other words, the return value from
    ** sqlite3_threadsafe() is unchanged by calls to sqlite3_config(). */
    assert( sqlite3_threadsafe()==isThreadsafe );



    th3testpcacheInstall(
      (s[0].config.maskProp & TH3_ALT_PCACHE)!=0,
      s[0].config.discardChance,
      1,
      s[0].config.stressChance
    );

    sqlite3_enable_shared_cache( (aConfig[i].maskProp & TH3_SHARED_CACHE)!=0 );

    if( aConfig[i].xInitializer ) aConfig[i].xInitializer();

    sqlite3_initialize();

#ifndef SQLITE_ENABLE_ZIPVFS
    /* Skip configurations that specify ZIPVFS if ZIPVFS is not available. */
    if( s[0].config.maskProp & TH3_ZIPVFS ){
      /* noop */
    }else
#endif
    /* Only run this configuration if the specified VFS exists */
    if( aConfig[i].zDfltVfs && sqlite3_vfs_find(aConfig[i].zDfltVfs)==0 ){
      s[0].module.maxFormat = 10000;
      th3print(&s[0],
        th3format(&s[0], "Skip %s: no such VFS: %s\n",
                          aConfig[i].zConfigName, aConfig[i].zDfltVfs)
      );
    }else{
      th3_setup_state(&s[0]);
      if( s[0].config.maskProp & TH3_THREADS ){
        for(j=1; j<NTHREAD; j++){
          s[j].tid = j;
          s[j].config = s[0].config;
          th3_setup_state(&s[j]);        
          th3threadCreate(th3_run_thread, &s[j]);
        }
      }
      th3_run_thread(&s[0]);
      nFail += s[0].nFail;
      nOk += s[0].nOk;
      if( s[0].config.maskProp & TH3_THREADS ){
        for(j=1; j<NTHREAD; j++){
          while( s[j].config.zConfigName ){
            th3threadYield();
          }
          nFail += s[j].nFail;
          nOk += s[j].nOk;
          th3_cleanup_state(&s[j]);
        }
      }
    }
    if( i==nConfig-1 ){
      static int one = 1;
      s[0].module.maxFormat = 10000;
      nFail += th3verifyAllPathsCovered(&s[0]);
      th3print(&s[0], 
        th3format(&s[0], 
          "%s: architecture: %d-bit %s-endian\n"
          "%s: %d errors out of %d tests in %d configurations\n"
          "%s: SQLite " SQLITE_VERSION " " SQLITE_SOURCE_ID "\n",
          argv[0], sizeof(s)*8, ((char*)&one)[0]==1 ? "little" : "big",
          argv[0], nFail, nFail+nOk, nConfig,
          argv[0]
        )
      );
#ifdef TH3_LOG_FILE
      th3print(&s[0],
        th3format(&s[0],
          "%s: output in file \"%s\"\n",
          argv[0], TH3_LOG_FILE
        )
      );
#endif
    }
    sqlite3_shutdown();
    if( aConfig[i].xFinalizer ) aConfig[i].xFinalizer();

    /* deconfigure */
    if( (s[0].config.maskProp & TH3_NO_MEMSTATUS)==0
     && (s[0].config.maskProp & TH3_THREADS)!=0
    ){

      th3testBegin(&s[0], "memleak");
      if( sqlite3_memory_used() ){
        th3testFailed(&s[0],
          th3format(&s[0], "leaked %lld bytes", sqlite3_memory_used())
        );
      }else{
        th3testOk(&s[0]);
      }
    }
    th3freeAll(&s[0]);
    th3_cleanup_state(&s[0]);
  }
  sqlite3_shutdown();
  th3freeRaw(pToFree);
  th3freeRaw(s);
  return nFail;
}
}; ########################################################## END FOOTER
